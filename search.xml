<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>RocketMQ系列12--Producer 事务消息</title>
      <link href="/2018/09/01/RocketMQ%E7%B3%BB%E5%88%9712--Producer%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/09/01/RocketMQ%E7%B3%BB%E5%88%9712--Producer%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>RocketMQ除了支持普通消息，顺序消息，另外还支持事务消息。首先讨论一下什么是事务消息以及支持事务消息的必要性。我们以一个转帐的场景为例来说明这个问题：Bob向Smith转账100块。</p><p><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">转账业务</a></p><h1 id="1-事务消息"><a href="#1-事务消息" class="headerlink" title="1. 事务消息"></a>1. 事务消息</h1><p>通过消息的异步事务,可以保证本地事务和消息发送同时执行成功或者失败,从而保证了数据的最终一致性.</p><p>rocketmq事务消息是发生在 producer和broker之间,是事务的二阶段提交，如图：</p><p><img src="http://lifestack.cn/wp-content/uploads/2015/09/%E4%BA%8B%E5%8A%A1%E9%80%BB%E8%BE%91.jpg" alt=""></p><p>只有在消息发送成功，并且本地操作执行成功时，才发送提交事务消息，做事务提交；</p><p>其他的情况，例如消息的发送失败，则直接发送回滚消息，进行回滚，或者发送消息成功，但是本地执行操作失败，也是发送回滚消息，进行回滚。</p><p>阶段解读：</p><p><strong>一阶段(步骤 1 2 3)</strong>:Producer 向Broker发送一条 PROPERTY_TRANSACTION_PREPARED 的消息，Broker接收到消息后保存在 CommitLog中，然后返回结果给 Producer,但是该类型的消息对Consumer是不可见的，Consumer无法消费。因为该类型消息在保存的时候，commitLogOffset没有被保存到 consumerQueue 中，所以客户端通过 consumerQueue 取不到 consumerQueue,所以无法被消费。</p><p><strong>二阶段(步骤 4 5)</strong>: Producer端的 tranExecuter.executeLocalTransaction 执行本地操作，返回本地事务的状态，然后发送一条类型为TransactionCommitType或者TransactionRollbackType的消息到Broker确认提交或者回滚。<br>Broker通过Request中的commitLogOffset，获取到上面状态为TransactionPreparedType的消息（简称消息A），然后重新构造一条与消息A内容相同的消息B，设置状态为TransactionCommitType或者TransactionRollbackType，然后保存。其中TransactionCommitType类型的，会放commitLogOffset到consumerQueue中，TransactionRollbackType类型的，消息体设置为空，不会放commitLogOffset到consumerQueue中。</p><p>所以，整个事务消息过程中，broker一共保存2条消息。</p><h1 id="2-producer端"><a href="#2-producer端" class="headerlink" title="2. producer端"></a>2. producer端</h1><p>在最新版本 4.4.0-SNAPSHOT 中，TransactionMQProducer已经把 本地执行事务的代码 和 broker回查 producer本地事务的方法封装到了一个监听器中TransactionListener。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionMQProducer extends DefaultMQProducer &#123;</span><br><span class="line">    private TransactionListener transactionListener;</span><br><span class="line"></span><br><span class="line">    private ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionListener &#123;</span><br><span class="line">    /**</span><br><span class="line">     * When send transactional prepare(half) message succeed, this method will be invoked to execute local transaction.</span><br><span class="line">     *</span><br><span class="line">     * @param msg Half(prepare) message</span><br><span class="line">     * @param arg Custom business parameter</span><br><span class="line">     * @return Transaction state</span><br><span class="line">     */</span><br><span class="line">    LocalTransactionState executeLocalTransaction(final Message msg, final Object arg);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * When no response to prepare(half) message. broker will send check message to check the transaction status, and this</span><br><span class="line">     * method will be invoked to get local transaction status.</span><br><span class="line">     *</span><br><span class="line">     * @param msg Check message</span><br><span class="line">     * @return Transaction state</span><br><span class="line">     */</span><br><span class="line">    LocalTransactionState checkLocalTransaction(final MessageExt msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionProducer &#123;</span><br><span class="line">    public static void main(String[] args) throws MQClientException, InterruptedException &#123;</span><br><span class="line">        // 本地事务执行逻辑及broker回查事务状态实现类.</span><br><span class="line">        TransactionListener transactionListener = new TransactionListenerImpl();</span><br><span class="line">        TransactionMQProducer producer = new TransactionMQProducer(&quot;Transaction_MQProducer_Group&quot;);</span><br><span class="line">        //设置 nameserver地址.</span><br><span class="line">        producer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line"></span><br><span class="line">        //设置broker回查prodducer的并发数</span><br><span class="line">        ExecutorService executorService = new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2000), new ThreadFactory() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Thread newThread(Runnable r) &#123;</span><br><span class="line">                Thread thread = new Thread(r);</span><br><span class="line">                thread.setName(&quot;client-transaction-msg-check-thread&quot;);</span><br><span class="line">                return thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        String[] tags = new String[] &#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;&#125;;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Message msg = new Message(&quot;TopicTest1234&quot;, </span><br><span class="line">                        tags[i % tags.length], &quot;KEY&quot; + i,</span><br><span class="line">                        (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                </span><br><span class="line">                SendResult sendResult = producer.sendMessageInTransaction(msg, i);</span><br><span class="line">                System.out.printf(&quot;%s%n&quot;, sendResult);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(10);</span><br><span class="line">            &#125; catch (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 根据业务需要，自己实现 TransactionListener接口中的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionListenerImpl implements TransactionListener &#123;</span><br><span class="line">    private AtomicInteger transactionIndex = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    private ConcurrentHashMap&lt;String, Integer&gt; localTrans = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        int value = transactionIndex.getAndIncrement();</span><br><span class="line">        int status = value % 3;</span><br><span class="line">        localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">        return LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;</span><br><span class="line">        Integer status = localTrans.get(msg.getTransactionId());</span><br><span class="line">        if (null != status) &#123;</span><br><span class="line">            switch (status) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    return LocalTransactionState.UNKNOW;</span><br><span class="line">                case 1:</span><br><span class="line">                    return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                case 2:</span><br><span class="line">                    return LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-consumer端"><a href="#3-consumer端" class="headerlink" title="3. consumer端"></a>3. consumer端</h1><p>同普通消息消费一样。</p><h1 id="4-发送消息详解"><a href="#4-发送消息详解" class="headerlink" title="4. 发送消息详解"></a>4. 发送消息详解</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public TransactionSendResult sendMessageInTransaction(final Message msg,</span><br><span class="line">                                                          final TransactionListener tranExecuter, final Object arg)</span><br><span class="line">        throws MQClientException &#123;</span><br><span class="line"></span><br><span class="line">        // 判断是否有本地事务监听器</span><br><span class="line">        if (null == tranExecuter) &#123;</span><br><span class="line">            throw new MQClientException(&quot;tranExecutor is null&quot;, null);</span><br><span class="line">        &#125;</span><br><span class="line">        // 校验message信息.</span><br><span class="line">        Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">        // 标记该消息为 事务消息.</span><br><span class="line">        SendResult sendResult = null;</span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;);</span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());</span><br><span class="line">        // 第一次发送消息.</span><br><span class="line">        try &#123;</span><br><span class="line">            sendResult = this.send(msg);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new MQClientException(&quot;send message Exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">        Throwable localException = null;</span><br><span class="line">        switch (sendResult.getSendStatus()) &#123;</span><br><span class="line">            case SEND_OK: &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (sendResult.getTransactionId() != null) &#123;</span><br><span class="line">                        msg.putUserProperty(&quot;__transactionId__&quot;, sendResult.getTransactionId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                    if (null != transactionId &amp;&amp; !&quot;&quot;.equals(transactionId)) &#123;</span><br><span class="line">                        // 将 transactionId 设置到消息中.</span><br><span class="line">                        msg.setTransactionId(transactionId);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 执行本地事务.*********重要.</span><br><span class="line">                    // 判断 localTransactionState 是否是 COMMIT_MESSAGE状态.</span><br><span class="line">                    localTransactionState = tranExecuter.executeLocalTransaction(msg, arg);</span><br><span class="line">                    if (null == localTransactionState) &#123;</span><br><span class="line">                        localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) &#123;</span><br><span class="line">                        log.info(&quot;executeLocalTransactionBranch return &#123;&#125;&quot;, localTransactionState);</span><br><span class="line">                        log.info(msg.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    log.info(&quot;executeLocalTransactionBranch exception&quot;, e);</span><br><span class="line">                    log.info(msg.toString());</span><br><span class="line">                    localException = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            case FLUSH_DISK_TIMEOUT:</span><br><span class="line">            case FLUSH_SLAVE_TIMEOUT:</span><br><span class="line">            case SLAVE_NOT_AVAILABLE:</span><br><span class="line">                localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">// 第二次发送消息.</span><br><span class="line">            this.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.warn(&quot;local transaction execute &quot; + localTransactionState + &quot;, but end broker transaction failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 构造返回信息 TransactionSendResult</span><br><span class="line">        TransactionSendResult transactionSendResult = new TransactionSendResult();</span><br><span class="line">        transactionSendResult.setSendStatus(sendResult.getSendStatus());</span><br><span class="line">        transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</span><br><span class="line">        transactionSendResult.setMsgId(sendResult.getMsgId());</span><br><span class="line">        transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</span><br><span class="line">        transactionSendResult.setTransactionId(sendResult.getTransactionId());</span><br><span class="line">        transactionSendResult.setLocalTransactionState(localTransactionState);</span><br><span class="line">        return transactionSendResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void endTransaction(</span><br><span class="line">        final SendResult sendResult,</span><br><span class="line">        final LocalTransactionState localTransactionState,</span><br><span class="line">        final Throwable localException) throws RemotingException, MQBrokerException, InterruptedException, UnknownHostException &#123;</span><br><span class="line">        // 得到message的地址信息</span><br><span class="line">        final MessageId id;</span><br><span class="line">        if (sendResult.getOffsetMsgId() != null) &#123;</span><br><span class="line">            id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            id = MessageDecoder.decodeMessageId(sendResult.getMsgId());</span><br><span class="line">        &#125;</span><br><span class="line">        // 得到事务消息的Id</span><br><span class="line">        String transactionId = sendResult.getTransactionId();</span><br><span class="line">        // 根据brokerName 找到broker的地址.</span><br><span class="line">        final String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());</span><br><span class="line"></span><br><span class="line">        // 构造结束事务请求头信息.</span><br><span class="line">        EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader();</span><br><span class="line">        requestHeader.setTransactionId(transactionId);</span><br><span class="line">        requestHeader.setCommitLogOffset(id.getOffset());</span><br><span class="line">        switch (localTransactionState) &#123;</span><br><span class="line">            case COMMIT_MESSAGE:</span><br><span class="line">                requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">                break;</span><br><span class="line">            case ROLLBACK_MESSAGE:</span><br><span class="line">                requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line">                break;</span><br><span class="line">            case UNKNOW:</span><br><span class="line">                requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());</span><br><span class="line">        requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());</span><br><span class="line">        requestHeader.setMsgId(sendResult.getMsgId());</span><br><span class="line">        String remark = localException != null ? (&quot;executeLocalTransactionBranch exception: &quot; + localException.toString()) : null;</span><br><span class="line"></span><br><span class="line">        // oneway 形式发送事务应答信息.</span><br><span class="line">        this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,</span><br><span class="line">            this.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="5-推荐及参考"><a href="#5-推荐及参考" class="headerlink" title="5. 推荐及参考"></a>5. 推荐及参考</h1><p>【1】 <a href="https://yq.aliyun.com/articles/55630" target="_blank" rel="noopener">事务消息</a></p><p>【2】 <a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> Producer </tag>
            
            <tag> 事务消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列10--Producer介绍</title>
      <link href="/2018/08/31/RocketMQ%E7%B3%BB%E5%88%9710--Producer%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/08/31/RocketMQ%E7%B3%BB%E5%88%9710--Producer%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>rocketmq支持3种形式的消息:</p><ul><li>普通消息</li><li>顺序消息</li><li>事务消息</li></ul><p>同时支持3种不同的发送方式</p><ul><li>同步</li><li>异步</li><li>One-Way</li></ul><p>本篇将以 DefaultMQProducer(普通消息)为例讲解 producer的一些属性配置、发送机制和消息结果的处理事项。</p><h1 id="1-MQProducer属性配置"><a href="#1-MQProducer属性配置" class="headerlink" title="1. MQProducer属性配置"></a>1. MQProducer属性配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"># Producer 组名，多个 Producer 如果属于一个应用，发送同样的消息，则应该将它们归为同一组</span><br><span class="line">   private String producerGroup;</span><br><span class="line"></span><br><span class="line">   # 在发送消息时，自动创建服务器不存在的topic，需要指定 Key。</span><br><span class="line"># 建议线下测试时开启，线上环境关闭</span><br><span class="line">   private String createTopicKey = MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC;</span><br><span class="line"></span><br><span class="line">   # 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">   private volatile int defaultTopicQueueNums = 4;</span><br><span class="line"></span><br><span class="line">   # 发送消息超时时间，单位毫秒</span><br><span class="line">   private int sendMsgTimeout = 3000;</span><br><span class="line"></span><br><span class="line"># 消息 Body 超过多大开始压缩（Consumer收到消息会自动解压缩），单位字节</span><br><span class="line">   private int compressMsgBodyOverHowmuch = 1024 * 4;</span><br><span class="line"></span><br><span class="line"># 消息同步发送失败最大重试次数，超过这个设置次数后，需要开发者自己去解决。</span><br><span class="line">   private int retryTimesWhenSendFailed = 2;</span><br><span class="line"></span><br><span class="line"># 消息异步发送失败最大重试次数，超过这个设置次数后，需要开发者自己去解决。</span><br><span class="line">   private int retryTimesWhenSendAsyncFailed = 2;</span><br><span class="line"></span><br><span class="line">   # 如果发送消息返回 sendResult，但是 sendStatus!=SEND_OK，是否重试发送</span><br><span class="line">   private boolean retryAnotherBrokerWhenNotStoreOK = false;</span><br><span class="line"></span><br><span class="line">   # 客户端限制的消息大小，超过报错，同时服务端也会限制</span><br><span class="line">   private int maxMessageSize = 1024 * 1024 * 4; // 4M</span><br></pre></td></tr></table></figure><h1 id="2-发送消息"><a href="#2-发送消息" class="headerlink" title="2.发送消息"></a>2.发送消息</h1><h2 id="2-1-构造Message"><a href="#2-1-构造Message" class="headerlink" title="2.1 构造Message"></a>2.1 构造Message</h2><p>发送消息，第一步构造消息对象 Message。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Message(String topic, String tags, String keys, int flag, byte[] body, boolean waitStoreMsgOK) &#123;</span><br><span class="line">        this.topic = topic;</span><br><span class="line">        this.flag = flag;</span><br><span class="line">        this.body = body;</span><br><span class="line"></span><br><span class="line">        if (tags != null &amp;&amp; tags.length() &gt; 0)</span><br><span class="line">            this.setTags(tags);</span><br><span class="line"></span><br><span class="line">        if (keys != null &amp;&amp; keys.length() &gt; 0)</span><br><span class="line">            this.setKeys(keys);</span><br><span class="line"></span><br><span class="line">        this.setWaitStoreMsgOK(waitStoreMsgOK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　一个应用尽可能用一个 Topic，消息子类型用 tags 来标识，tags 可以由应用自由设置。只有发送消息设置了tags，消费方在订阅消息时，才可以利用 tags 在 broker 做消息过滤。</p><p>　　每个消息在业务局面的唯一标识码，要设置到 keys 字段，方便将来定位消息丢失问题。服务器会为每个消息创建索引（哈希索引），应用可以通过 topic，key 来查询返条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证 key 尽可能唯一，返样可以避免潜在的哈希冲突。</p><blockquote><p>如在订单业务中，可以将订单号设置进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String orderId = &quot;20034568923546&quot;;</span><br><span class="line">message.setKeys(orderId);</span><br></pre></td></tr></table></figure></p></blockquote><p>将具体的消息放到 body 字段中，waitStoreMsgOK标识是否等待Broker处存放消息ok.</p><h2 id="2-2-发送消息"><a href="#2-2-发送消息" class="headerlink" title="2.2 发送消息"></a>2.2 发送消息</h2><p>构造好Message消息后，调用 producer.send()方法完成对消息的发送。<br>底层调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public SendResult send(Message msg,</span><br><span class="line">       long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">       return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://www.iocoder.cn/images/RocketMQ/2017_04_18/02.png" alt=""></p><p>步骤：获取消息路由信息，选择要发送到的消息队列，执行消息发送核心方法，并对发送结果进行封装返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">private SendResult sendDefaultImpl(</span><br><span class="line">        Message msg,</span><br><span class="line">        final CommunicationMode communicationMode,</span><br><span class="line">        final SendCallback sendCallback,</span><br><span class="line">        final long timeout</span><br><span class="line">    ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">        // 校验 Producer 处于运行状态(ServiceState.RUNNING)</span><br><span class="line">        this.makeSureStateOK();</span><br><span class="line">        // 校验消息格式</span><br><span class="line">        Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">        // 调用编号,调用时间,用于下面打印日志,标记为同义词发送消息,为监控平台链路追踪</span><br><span class="line">        final long invokeID = random.nextLong();</span><br><span class="line">        long beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line">        long beginTimestampPrev = beginTimestampFirst;</span><br><span class="line">        long endTimestamp = beginTimestampFirst;</span><br><span class="line"></span><br><span class="line">        // 从namesrv中获取Topic的路由信息.</span><br><span class="line">        TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">        if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">            boolean callTimeout = false; // 判断是否发送超时</span><br><span class="line">            MessageQueue mq = null;      // 最后选择消息要发送的队列</span><br><span class="line">            Exception exception = null;</span><br><span class="line">            SendResult sendResult = null; // 最后一次的发送结果.</span><br><span class="line">            // 判断发送模式是否是同步,同步的话可能需要发送多次.</span><br><span class="line">            int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1;</span><br><span class="line">            int times = 0;  // 第几次发送.</span><br><span class="line">            String[] brokersSent = new String[timesTotal]; // 存储每次发送消息选择的broker名</span><br><span class="line">            // 循环调用发送消息，直到成功</span><br><span class="line">            for (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">                String lastBrokerName = null == mq ? null : mq.getBrokerName();</span><br><span class="line">                // 选择要发送的消息队列.</span><br><span class="line">                MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">                if (mqSelected != null) &#123;</span><br><span class="line">                    mq = mqSelected;</span><br><span class="line">                    brokersSent[times] = mq.getBrokerName();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                        long costTime = beginTimestampPrev - beginTimestampFirst;</span><br><span class="line">                        if (timeout &lt; costTime) &#123;</span><br><span class="line">                            callTimeout = true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 调用发送消息的核心方法.</span><br><span class="line">                        sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        // 更新broker的可用性信息.</span><br><span class="line">                        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);</span><br><span class="line">                        switch (communicationMode) &#123;</span><br><span class="line">                            case ASYNC:</span><br><span class="line">                                return null;</span><br><span class="line">                            case ONEWAY:</span><br><span class="line">                                return null;</span><br><span class="line">                            case SYNC:</span><br><span class="line">                                // 同步发送成功但存储有问题时 &amp;&amp; 配置存储异常时重新发送开关 时，进行重试</span><br><span class="line">                                if (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                                    if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                        continue;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                return sendResult;</span><br><span class="line">                            default:</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (RemotingException e) &#123; // 打印异常，更新Broker可用性信息，更新继续循环</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);</span><br><span class="line">                        log.warn(String.format(&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125; catch (MQClientException e) &#123; // 打印异常，更新Broker可用性信息，继续循环</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);</span><br><span class="line">                        log.warn(String.format(&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125; catch (MQBrokerException e) &#123; // 打印异常，更新Broker可用性信息，部分情况下的异常，直接返回，结束循环</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);</span><br><span class="line">                        log.warn(String.format(&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        switch (e.getResponseCode()) &#123;</span><br><span class="line">                            case ResponseCode.TOPIC_NOT_EXIST:</span><br><span class="line">                            case ResponseCode.SERVICE_NOT_AVAILABLE:</span><br><span class="line">                            case ResponseCode.SYSTEM_ERROR:</span><br><span class="line">                            case ResponseCode.NO_PERMISSION:</span><br><span class="line">                            case ResponseCode.NO_BUYER_ID:</span><br><span class="line">                            case ResponseCode.NOT_IN_CURRENT_UNIT:</span><br><span class="line">                                continue;</span><br><span class="line">                            default:</span><br><span class="line">                                if (sendResult != null) &#123;</span><br><span class="line">                                    return sendResult;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                throw e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);</span><br><span class="line">                        log.warn(String.format(&quot;sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">                        log.warn(&quot;sendKernelImpl exception&quot;, e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        throw e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 返回发送结果</span><br><span class="line">            if (sendResult != null) &#123;</span><br><span class="line">                return sendResult;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 根据不同情况，抛出不同的异常</span><br><span class="line">            String info = String.format(&quot;Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s&quot;,</span><br><span class="line">                times,</span><br><span class="line">                System.currentTimeMillis() - beginTimestampFirst,</span><br><span class="line">                msg.getTopic(),</span><br><span class="line">                Arrays.toString(brokersSent));</span><br><span class="line"></span><br><span class="line">            info += FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);</span><br><span class="line"></span><br><span class="line">            MQClientException mqClientException = new MQClientException(info, exception);</span><br><span class="line">            if (callTimeout) &#123;</span><br><span class="line">                throw new RemotingTooMuchRequestException(&quot;sendDefaultImpl call timeout&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (exception instanceof MQBrokerException) &#123;</span><br><span class="line">                mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode());</span><br><span class="line">            &#125; else if (exception instanceof RemotingConnectException) &#123;</span><br><span class="line">                mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION);</span><br><span class="line">            &#125; else if (exception instanceof RemotingTimeoutException) &#123;</span><br><span class="line">                mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT);</span><br><span class="line">            &#125; else if (exception instanceof MQClientException) &#123;</span><br><span class="line">                mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throw mqClientException;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Namesrv找不到异常</span><br><span class="line">        List&lt;String&gt; nsList = this.getmQClientFactory().getMQClientAPIImpl().getNameServerAddressList();</span><br><span class="line">        if (null == nsList || nsList.isEmpty()) &#123;</span><br><span class="line">            throw new MQClientException(</span><br><span class="line">                &quot;No name server address, please set it.&quot; + FAQUrl.suggestTodo(FAQUrl.NAME_SERVER_ADDR_NOT_EXIST_URL), null).setResponseCode(ClientErrorCode.NO_NAME_SERVER_EXCEPTION);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 消息路由找不到异常</span><br><span class="line">        throw new MQClientException(&quot;No route info of this topic, &quot; + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),</span><br><span class="line">            null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="3-消息发送结果处理"><a href="#3-消息发送结果处理" class="headerlink" title="3.消息发送结果处理"></a>3.消息发送结果处理</h1><p>　　消息发送成功或者失败，要打印消息日志，务必要打印 sendresult 和 key 字段。<br>send 消息方法，只要不抛异常，就代表发送成功。但是发送成功会有多个状态，在 sendResult 里定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum SendStatus &#123;</span><br><span class="line">    // 消息发送成功</span><br><span class="line">    SEND_OK,</span><br><span class="line">    // 消息发送成功，但是服务器刷盘超时，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失</span><br><span class="line">    FLUSH_DISK_TIMEOUT,</span><br><span class="line">    // 消发发送成功，但是服务器同步到 Slave 时超时，消息已经迕入服务器队列，只有此时服务器宕机，消息才会丢失</span><br><span class="line">    FLUSH_SLAVE_TIMEOUT,</span><br><span class="line">    // 消息发送成功，但是此时 slave 不可用，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失</span><br><span class="line">    SLAVE_NOT_AVAILABLE,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-发送形式"><a href="#4-发送形式" class="headerlink" title="4.发送形式"></a>4.发送形式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息发送模式</span><br><span class="line"> */</span><br><span class="line">public enum CommunicationMode &#123;</span><br><span class="line">    SYNC,   //同步.</span><br><span class="line">    ASYNC,  //异步.</span><br><span class="line">    ONEWAY, //只管发送</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SYNC<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.send(msg)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>　　同步的发送方式，会等待发送结果后才返回。可以用 send(msg, timeout) 的方式指定等待时间，如果不指定，就是默认的 3000ms. 这个timeout 最终会被设置到 ResponseFuture 里，在发送完消息后，用 countDownLatch 去 await timeout的时间，如果过期，就会抛出异常。</p></blockquote><ul><li>ASYNC<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">producer.send(msg, new SendCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSuccess(SendResult sendResult) &#123;</span><br><span class="line">        System.out.printf(&quot;%-10d OK %s %n&quot;, index, sendResult.getMsgId());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onException(Throwable e) &#123;</span><br><span class="line">        System.out.printf(&quot;%-10d Exception %s %n&quot;, index, e);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>　　异步的发送方式，发送完后，立刻返回。Client 在拿到 Broker 的响应结果后，会回调指定的 callback. 这个 API 也可以指定 Timeout，不指定也是默认的 3000ms.</p></blockquote><ul><li>ONEWAY</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.sendOneway(msg);</span><br></pre></td></tr></table></figure><blockquote><p>一个 RPC 调用，通常是这样一个过程</p><ol><li>客户端发送请求到服务器</li><li>服务器处理该请求</li><li>服务器吐客户端返回应答</li></ol><p>　　 所以一个 RPC 的耗时时间是上述三个步骤的总和，而某些场景要求耗时非常短，但是对可靠性要求并不高，例如<br>日志收集类应用，此类应用可以采用 oneway 形式调用，oneway 形式只发送请求并等待应答，而发送请求在客<br>户端实现局面仅仅是一个 os 系统调用的开销，即将数据写入客户端的 socket 缓冲区，此过程耗时通常在微秒级。</p></blockquote>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> Producer </tag>
            
            <tag> 发送消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列11--Producer 顺序消息</title>
      <link href="/2018/08/31/RocketMQ%E7%B3%BB%E5%88%9711--Producer%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/08/31/RocketMQ%E7%B3%BB%E5%88%9711--Producer%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>顺序消息（FIFO消息）是MQ提供的一种严格按照顺序进行发布和消费的消息类型。顺序消息指消息发布和消息消费都按照顺序进行。</p><ul><li>顺序发布: 对于指定的一个Topic,客户端将按照一定的先后顺序发送消息；</li><li>顺序消费: 对于指定的一个Topic,按照一定的先后顺序接收消息，即先发送的消息一定会被消费段先接受到并处理。</li></ul><p>　　例如：一笔订单产生了3条消息，分别是：订单创建、订单付款、订单完成。消费时，要按照顺序一次消费才有意义。于此同时多笔订单之间又是可以并行消费的。</p><p><strong>全局顺序</strong></p><p>对于指定的一个Topic,所有的消息按照严格的先入先出（FIFO）的顺序进行发布和消费。</p><p><img src="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/49319/cn_zh/1534917028902/%E5%85%A8%E5%B1%80%E9%A1%BA%E5%BA%8F.png" alt=""></p><p>请参考 阿里的《<a href="https://help.aliyun.com/document_detail/49319.html?spm=a2c4g.11186623.4.6.6a0a292dCAyla4" target="_blank" rel="noopener">顺序消息</a>》说明。</p><h1 id="1-RocketMQ的顺序消息的实现"><a href="#1-RocketMQ的顺序消息的实现" class="headerlink" title="1.RocketMQ的顺序消息的实现"></a>1.RocketMQ的顺序消息的实现</h1><p>　　顺序消息主要是指局部顺序，即生产者通过将某一类消息发送至同一个队列来实现。与发生普通消息相比，在发送顺序消息时要对同一类型的消息选择同一个队列，即同一个　<strong>MessageQueue</strong>　对象。 目前RocketMQ定义了选择MessageQueue对象的接口MessageQueueSelector，里面有方法select(final List mqs, final Message msg, final Object arg)，并且RocketMQ默认实现了提供了两个实现类SelectMessageQueueByHash和SelectMessageQueueByRandoom，即根据arg参数通过Hash或者随机方式选择MessageQueue对象。 为了业务层根据业务需要能自定义选择规则，也可以在业务层自定义选择规则，然后调用DefaultMQProducer.send(Message msg, MessageQueueSelector selector, Object arg)方法完成顺序消息的方式。 </p><p>　　消息发布是有序的含义：producer发送消息应该是依次发送的，所以要求发送消息的时候保证：</p><ul><li>消息不能异步发送，同步发送的时候才能保证broker收到是有序的。</li><li>每次发送选择的是同一个MessageQueue</li></ul><h1 id="2-Producer实现"><a href="#2-Producer实现" class="headerlink" title="2.Producer实现"></a>2.Producer实现</h1><p>　　参考网上的例子，编写如下的producer发送顺序消息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws UnsupportedEncodingException, RemotingException, MQClientException, MQBrokerException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //设置 producerGroup 名称</span><br><span class="line">            DefaultMQProducer producer = new DefaultMQProducer(&quot;Order_Producer_Group&quot;);</span><br><span class="line">            //设置 nameserver地址.</span><br><span class="line">            producer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">            producer.start();</span><br><span class="line"></span><br><span class="line">            // 订单创建 订单支付 订单完成</span><br><span class="line">            String[] tags = new String[] &#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;&#125;;</span><br><span class="line"></span><br><span class="line">            List&lt;Order&gt; orders = buildOrders();</span><br><span class="line">            for(int i = 0; i &lt; orders.size(); i++)&#123;</span><br><span class="line">                String body = &quot;Hello Rocket&quot; + orders.get(i);</span><br><span class="line">                long orderId = orders.get(i).getOrderId();</span><br><span class="line"></span><br><span class="line">                Message message = new Message(&quot;Topic_Order&quot;,</span><br><span class="line">                        tags[i % tags.length],</span><br><span class="line">                        &quot;KEY&quot; + i,</span><br><span class="line">                        body.getBytes());</span><br><span class="line"></span><br><span class="line">                SendResult sendResult = producer.send(message, new SelectMessageQueueByHash(), orderId);</span><br><span class="line">                System.out.println(&quot;content=&quot; + body + &quot;. sendResult = &quot; + sendResult);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125; catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // end main.</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成模拟订单数据</span><br><span class="line">     */</span><br><span class="line">    private static List&lt;Order&gt; buildOrders() &#123;</span><br><span class="line">        List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;();</span><br><span class="line"></span><br><span class="line">        Order orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111039L);</span><br><span class="line">        orderDemo.setDesc(&quot;创建&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111065L);</span><br><span class="line">        orderDemo.setDesc(&quot;创建&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111039L);</span><br><span class="line">        orderDemo.setDesc(&quot;付款&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103117235L);</span><br><span class="line">        orderDemo.setDesc(&quot;创建&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111065L);</span><br><span class="line">        orderDemo.setDesc(&quot;付款&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103117235L);</span><br><span class="line">        orderDemo.setDesc(&quot;付款&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111065L);</span><br><span class="line">        orderDemo.setDesc(&quot;完成&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111039L);</span><br><span class="line">        orderDemo.setDesc(&quot;推送&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103117235L);</span><br><span class="line">        orderDemo.setDesc(&quot;完成&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111039L);</span><br><span class="line">        orderDemo.setDesc(&quot;完成&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        return orderList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Order&#123;</span><br><span class="line">    private long orderId;</span><br><span class="line"></span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-Consumer实现"><a href="#3-Consumer实现" class="headerlink" title="3.Consumer实现"></a>3.Consumer实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws MQClientException &#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;Order_Consumer_Group&quot;);</span><br><span class="line">        consumer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(&quot;Topic_Order&quot;, &quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(new MessageListenerOrderly() &#123;</span><br><span class="line">            Random random = new Random();</span><br><span class="line">            @Override</span><br><span class="line">            public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) &#123;</span><br><span class="line">                context.setAutoCommit(true);</span><br><span class="line">                System.out.print(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; );</span><br><span class="line">                for (MessageExt msg: msgs) &#123;</span><br><span class="line">                    System.out.println(msg + &quot;, content:&quot; + new String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //模拟业务逻辑处理中...</span><br><span class="line">                    TimeUnit.SECONDS.sleep(random.nextInt(10));</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(&quot;Consumer Started.%n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h1><p><strong>producer端发送的消息</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">content=Hello RocketOrder(orderId=15103111039, desc=创建). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A62E, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=0], queueOffset=0]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111065, desc=创建). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A6E5, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=2], queueOffset=0]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111039, desc=付款). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A79C, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=0], queueOffset=1]</span><br><span class="line">content=Hello RocketOrder(orderId=15103117235, desc=创建). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518400002A9F0000000000033BBC, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-a, queueId=0], queueOffset=0]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111065, desc=付款). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A853, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=2], queueOffset=1]</span><br><span class="line">content=Hello RocketOrder(orderId=15103117235, desc=付款). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518400002A9F0000000000033C73, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-a, queueId=0], queueOffset=1]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111065, desc=完成). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A90A, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=2], queueOffset=2]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111039, desc=推送). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A9C1, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=0], queueOffset=2]</span><br><span class="line">content=Hello RocketOrder(orderId=15103117235, desc=完成). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518400002A9F0000000000033D2A, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-a, queueId=0], queueOffset=2]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111039, desc=完成). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002AA78, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=0], queueOffset=3]</span><br></pre></td></tr></table></figure><p><strong>consumer端消费消息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConsumeMessageThread_4 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=0, sysFlag=0, bornTimestamp=1535694773214, bornHost=/192.168.81.1:61621, storeTimestamp=1535723526505, storeHost=/192.168.81.132:10911, msgId=C0A8518400002A9F0000000000033BBC, commitLogOffset=211900, bodyCRC=1826716009, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY3, WAIT=true, TAGS=TagA&#125;, body=51]], content:Hello RocketOrder(orderId=15103117235, desc=创建)</span><br><span class="line">ConsumeMessageThread_5 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=0, sysFlag=0, bornTimestamp=1535694772791, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553085, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A62E, commitLogOffset=173614, bodyCRC=1934949583, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=4, KEYS=KEY0, WAIT=true, TAGS=TagA&#125;, body=51]], content:Hello RocketOrder(orderId=15103111039, desc=创建)</span><br><span class="line">ConsumeMessageThread_6 Receive New Messages: MessageExt [queueId=2, storeSize=183, queueOffset=0, sysFlag=0, bornTimestamp=1535694773081, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553244, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A6E5, commitLogOffset=173797, bodyCRC=1291356221, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY1, WAIT=true, TAGS=TagB&#125;, body=51]], content:Hello RocketOrder(orderId=15103111065, desc=创建)</span><br><span class="line">ConsumeMessageThread_6 Receive New Messages: MessageExt [queueId=2, storeSize=183, queueOffset=1, sysFlag=0, bornTimestamp=1535694773360, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553455, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A853, commitLogOffset=174163, bodyCRC=1081168709, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY4, WAIT=true, TAGS=TagB&#125;, body=51]], content:Hello RocketOrder(orderId=15103111065, desc=付款)</span><br><span class="line">ConsumeMessageThread_4 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=1, sysFlag=0, bornTimestamp=1535694773369, bornHost=/192.168.81.1:61621, storeTimestamp=1535723526572, storeHost=/192.168.81.132:10911, msgId=C0A8518400002A9F0000000000033C73, commitLogOffset=212083, bodyCRC=1617469969, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY5, WAIT=true, TAGS=TagC&#125;, body=51]], content:Hello RocketOrder(orderId=15103117235, desc=付款)</span><br><span class="line">ConsumeMessageThread_5 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=1, sysFlag=0, bornTimestamp=1535694773157, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553299, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A79C, commitLogOffset=173980, bodyCRC=2145200055, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=4, KEYS=KEY2, WAIT=true, TAGS=TagC&#125;, body=51]], content:Hello RocketOrder(orderId=15103111039, desc=付款)</span><br><span class="line">ConsumeMessageThread_6 Receive New Messages: MessageExt [queueId=2, storeSize=183, queueOffset=2, sysFlag=0, bornTimestamp=1535694773377, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553489, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A90A, commitLogOffset=174346, bodyCRC=339615115, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY6, WAIT=true, TAGS=TagA&#125;, body=51]], content:Hello RocketOrder(orderId=15103111065, desc=完成)</span><br><span class="line">ConsumeMessageThread_5 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=2, sysFlag=0, bornTimestamp=1535694773404, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553494, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A9C1, commitLogOffset=174529, bodyCRC=742301160, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=4, KEYS=KEY7, WAIT=true, TAGS=TagB&#125;, body=51]], content:Hello RocketOrder(orderId=15103111039, desc=推送)</span><br><span class="line">ConsumeMessageThread_4 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=2, sysFlag=0, bornTimestamp=1535694773411, bornHost=/192.168.81.1:61621, storeTimestamp=1535723526623, storeHost=/192.168.81.132:10911, msgId=C0A8518400002A9F0000000000033D2A, commitLogOffset=212266, bodyCRC=875031775, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY8, WAIT=true, TAGS=TagC&#125;, body=51]], content:Hello RocketOrder(orderId=15103117235, desc=完成)</span><br><span class="line">ConsumeMessageThread_5 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=3, sysFlag=0, bornTimestamp=1535694773426, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553517, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002AA78, commitLogOffset=174712, bodyCRC=731015545, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=4, KEYS=KEY9, WAIT=true, TAGS=TagA&#125;, body=51]], content:Hello RocketOrder(orderId=15103111039, desc=完成)</span><br></pre></td></tr></table></figure><h1 id="5-Producer发送顺序消息过程"><a href="#5-Producer发送顺序消息过程" class="headerlink" title="5.Producer发送顺序消息过程"></a>5.Producer发送顺序消息过程</h1><p>　　上面我们已经说过，要保证消息是顺序消息，在发送顺序消息时要对同一类型的消息选择同一个队列，即同一个　<strong>MessageQueue</strong>　对象。<br>　　在这里，我们要保证的是同一订单的消息要投放到同一个队列中，所以我们根据订单号去hash运算，一样的订单号得到的hash值可定是相同的，只要保证其队列的个数是不变的，则同一订单号的消息会被放到同一个队列中。</p><p>之前发送普通消息时，我们调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public SendResult send(Message msg)</span><br></pre></td></tr></table></figure></p><p>但发送顺序消息时，由于我们要把同一特征的消息放到同一队列中，所以我们使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public SendResult send(Message msg, MessageQueueSelector selector, Object arg)</span><br></pre></td></tr></table></figure><p>根据传入的arg值，选择路由到同一个队列中。</p><h2 id="5-1MessageQueueSelector"><a href="#5-1MessageQueueSelector" class="headerlink" title="5.1MessageQueueSelector"></a>5.1MessageQueueSelector</h2><p>第二个参数 MessageQueueSelector 是一个接口，rocketmq默认提供了3种实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageQueueSelector &#123;</span><br><span class="line">    MessageQueue select(List&lt;MessageQueue&gt; var1, Message var2, Object var3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-b735612943499713.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  发送消息，随机选择队列</span><br><span class="line"> */</span><br><span class="line">public class SelectMessageQueueByRandom implements MessageQueueSelector &#123;</span><br><span class="line">    private Random random = new Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">        int value = random.nextInt(mqs.size());</span><br><span class="line">        return mqs.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>随机选择，也就是谁也不知道它到底会选择谁，这种效率其实很差，没有负载均衡，谁也不知道会不会堵塞起来，谁也不知道某个队列是否已经塞满</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用哈希算法来选择队列，顺序消息推荐该实现.</span><br><span class="line"> */</span><br><span class="line">public class SelectMessageQueueByHash implements MessageQueueSelector &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">        int value = arg.hashCode();</span><br><span class="line">        if (value &lt; 0) &#123;</span><br><span class="line">            value = Math.abs(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        value = value % mqs.size();</span><br><span class="line">        return mqs.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们每个传递进入的对象都会被哈希算法计算出 一个哈希值，比如我们传递的是订单号，那么无疑我们可以保证相同的订单号可以传递给相同的topic去处理，那么只要再保证是一致的tag就可以保证顺序的一致性啦</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据机房来选择发往哪个队列，支付宝逻辑机房使用</span><br><span class="line"> */</span><br><span class="line">public class SelectMessageQueueByMachineRoom implements MessageQueueSelector &#123;</span><br><span class="line">    private Set&lt;String&gt; consumeridcs;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;String&gt; getConsumeridcs() &#123;</span><br><span class="line">        return consumeridcs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setConsumeridcs(Set&lt;String&gt; consumeridcs) &#123;</span><br><span class="line">        this.consumeridcs = consumeridcs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>机房选择，算法是木有啦，应该是根据ip地址去区分。</p></blockquote><p>　　同理，我们在使用时可以根据自己的业务需要来选择合适的方案，也可以自定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SendResult sendResult = producer.send(msg, new MessageQueueSelector() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">                        Integer id = (Integer) arg;</span><br><span class="line">                        int index = id % mqs.size();</span><br><span class="line">                        return mqs.get(index);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, arg);</span><br></pre></td></tr></table></figure><h2 id="5-2-顺序消息发送"><a href="#5-2-顺序消息发送" class="headerlink" title="5.2 顺序消息发送"></a>5.2 顺序消息发送</h2><p>底层调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private SendResult sendSelectImpl(</span><br><span class="line">       Message msg,</span><br><span class="line">       MessageQueueSelector selector,</span><br><span class="line">       Object arg,</span><br><span class="line">       final CommunicationMode communicationMode,</span><br><span class="line">       final SendCallback sendCallback, final long timeout</span><br><span class="line">   )</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private SendResult sendSelectImpl(</span><br><span class="line">       Message msg,</span><br><span class="line">       MessageQueueSelector selector,</span><br><span class="line">       Object arg,</span><br><span class="line">       final CommunicationMode communicationMode,</span><br><span class="line">       final SendCallback sendCallback, final long timeout</span><br><span class="line">   ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">       // 确定producer的状态时Running.</span><br><span class="line">       long beginStartTime = System.currentTimeMillis();</span><br><span class="line">       this.makeSureStateOK();</span><br><span class="line">       // 校验message的格式.</span><br><span class="line">       Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">       // 找到topic的路由信息,否则抛出异常.</span><br><span class="line">       TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">       if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">           </span><br><span class="line">           MessageQueue mq = null;</span><br><span class="line">           try &#123;</span><br><span class="line">               // 路由到消息要发送的消息队列.</span><br><span class="line">               mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);</span><br><span class="line">           &#125; catch (Throwable e) &#123;</span><br><span class="line">               throw new MQClientException(&quot;select message queue throwed exception.&quot;, e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 判断是否超时.</span><br><span class="line">           long costTime = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">           if (timeout &lt; costTime) &#123;</span><br><span class="line">               throw new RemotingTooMuchRequestException(&quot;sendSelectImpl call timeout&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           // 如果找到了要发送的消息队列,则发送该消息,否则跑相互异常信息.</span><br><span class="line">           if (mq != null) &#123;</span><br><span class="line">               return this.sendKernelImpl(msg, mq, communicationMode, sendCallback, null, timeout - costTime);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               throw new MQClientException(&quot;select message queue return null.&quot;, null);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       throw new MQClientException(&quot;No route info for this topic, &quot; + msg.getTopic(), null);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) &#123;</span><br><span class="line">        //  private final ConcurrentMap&lt;String, TopicPublishInfo&gt; topicPublishInfoTable = new ConcurrentHashMap&lt;String, TopicPublishInfo&gt;();</span><br><span class="line">        TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic);</span><br><span class="line">        </span><br><span class="line">        // 如果 topic的路由信息查询不到,或者该topic的消息队列还未初始化好,则创建该topic路由</span><br><span class="line">        // 并更新到namesrv上.</span><br><span class="line">        if (null == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">            this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo());</span><br><span class="line">            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">            topicPublishInfo = this.topicPublishInfoTable.get(topic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">            return topicPublishInfo;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer);</span><br><span class="line">            topicPublishInfo = this.topicPublishInfoTable.get(topic);</span><br><span class="line">            return topicPublishInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-consumer端接收"><a href="#5-3-consumer端接收" class="headerlink" title="5.3 consumer端接收"></a>5.3 consumer端接收</h2><p>　　普通消息consumer注册的监听器是： MessageListenerConcurrently：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void registerMessageListener(MessageListenerConcurrently messageListener) &#123;</span><br><span class="line">        this.messageListener = messageListener;</span><br><span class="line">        this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　而顺序消息consumer注册的监听器时是 MessageListenerOrderly：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void registerMessageListener(MessageListenerOrderly messageListener) &#123;</span><br><span class="line">        this.messageListener = messageListener;</span><br><span class="line">        this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public enum ConsumeOrderlyStatus &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Success consumption</span><br><span class="line">     */</span><br><span class="line">    SUCCESS,</span><br><span class="line">    /**</span><br><span class="line">     * Rollback consumption(only for binlog consumption)</span><br><span class="line">     */</span><br><span class="line">    @Deprecated</span><br><span class="line">    ROLLBACK,</span><br><span class="line">    /**</span><br><span class="line">     * Commit offset(only for binlog consumption)</span><br><span class="line">     */</span><br><span class="line">    @Deprecated</span><br><span class="line">    COMMIT,</span><br><span class="line">    /**</span><br><span class="line">     * Suspend current queue a moment</span><br><span class="line">     */</span><br><span class="line">    SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　本地消费的事务控制，</p><ul><li>ConsumeOrderlyStatus.SUCCESS（提交）</li><li>ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT（挂起一会再消费）</li></ul><p>　<br>　　在此之前还有一个变量ConsumeOrderlyContext context的setAutoCommit()是否自动提交。</p><p>　　当SUSPEND_CURRENT_QUEUE_A_MOMENT时，autoCommit设置为true或者false没有区别，本质跟消费相反，把消息从msgTreeMapTemp转移回msgTreeMap，等待下次消费。</p><p>当SUCCESS时，autoCommit设置为true时比设置为false多做了2个动作，</p><pre><code># 本质是删除msgTreeMapTemp里的消息，msgTreeMapTemp里的消息在上面消费时从msgTreeMap转移过来的consumeRequest.getProcessQueue().commit()# 本质是把拉消息的偏移量更新到本地，然后定时更新到brokerthis.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, false);</code></pre><p>　　那么少了这2个动作会怎么样呢，随着消息的消费进行，msgTreeMapTemp里的消息堆积越来越多，消费消息的偏移量一直没有更新到broker导致consumer每次重新启动后都要从头开始重复消费。所以 autoCommit建议设置为true.</p><p>　　好的，本篇顺序消息主要介绍了 顺序消息的发送、消费、以及与普通消息的不同。下篇将介绍 事务消息的发送。</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> Producer </tag>
            
            <tag> 顺序消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列06--整体架构概述</title>
      <link href="/2018/08/30/RocketMQ%E7%B3%BB%E5%88%9706--%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/08/30/RocketMQ%E7%B3%BB%E5%88%9706--%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>　　本篇,我主要根据 rocketmq的源码目录,简单介绍下 rocketmq各模块的功能,及其各自间的相互调用。接着大体上说一下 其中的nameserver，底层通信和数据存储。但里面的东西还需要大家去阅读源码，仔细体会。这里只是做个引子。我在文章的最后推荐了 【Rocketmq源码阅读】的系列博客，对大家阅读源码可能会有帮助。<br>废话不多说，直入主题。</p><h1 id="1-源码目录"><a href="#1-源码目录" class="headerlink" title="1. 源码目录"></a>1. 源码目录</h1><p>　　我这里是下载的 最新的 RocekyMQ 4.4.0-SNAPSHOT版本的<a href="https://github.com/apache/rocketmq/" target="_blank" rel="noopener">源码</a><br>导入到 IDEA中，目录结构如图：</p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-53e6a18b34657498.png" alt=""></p><ul><li><p>distribution</p><blockquote><p>　　存放系统中的脚本，以及一些broker集群的配置文件，用户可以根据自己的项目信息更改配置文件或脚本中的内容，来启动 nameserver 和 broker,集合 example中的Producer/Consumer来做一些小测试。</p></blockquote></li><li><p>broker</p><blockquote><p>　　消息代理，起到 串联 Producer/Consumer 和 Store的作用。我们所谓的消息的存储、接收、拉去、推送等操作都是在broker上进行的。</p></blockquote></li><li><p>client</p><blockquote><p>　　包含 Producer 和 Consumer，负责消息的发和收。</p></blockquote></li><li><p>common</p><blockquote><p>　　通用的常量枚举、基类方法或数据结构，按描述的目标来分包，</p></blockquote></li><li><p>example</p><blockquote><p>　　使用样例，包含各种使用方法，Pull/Push模式，广播模式、有序消息，事务消息。</p></blockquote></li><li><p>filter</p><blockquote><p>　　过滤器，用于服务端的过滤方式，实现了真正意义的高内聚低耦合的设计思想。<br>　　在使用filter模块的时候需要启动filter的服务。</p></blockquote></li><li><p>logappender logging</p><blockquote><p>　　日志相关。</p></blockquote></li><li><p>namesrv</p><blockquote><p>　　注册中心，每个broker都会在这里注册，client也会从这里获取broker 的相关信息。</p></blockquote></li><li><p>openmessaging</p><blockquote></blockquote></li><li><p>remoting</p><blockquote><p>　　基于Netty实现的额昂罗通信模块，包括server和client,client broker filter 等模块都对他有依赖。</p></blockquote></li><li><p>srvutil</p><blockquote><p>　　用来处理命令行的，一个用来配置shutdownHook.目的为了拆分客户端依赖，尽可能减少客户端的依赖。</p></blockquote></li><li><p>store</p><blockquote><p>　　负责消息的存储和读取。</p></blockquote></li><li><p>test</p><blockquote><p>　　测试用例代码</p></blockquote></li><li><p>tools</p><blockquote><p>　　一些工具类，基于他们可以写一些工具来管理、查看MQ系统的一些信息。</p></blockquote></li></ul><h1 id="2-模块调用图及层次说明"><a href="#2-模块调用图及层次说明" class="headerlink" title="2. 模块调用图及层次说明"></a>2. 模块调用图及层次说明</h1><p><img src="https://upload-images.jianshu.io/upload_images/11560519-f4bf6ba3b4f5bc93.png" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-aa7a629b10e20a53.png" alt=""></p><h1 id="3-nameserver介绍"><a href="#3-nameserver介绍" class="headerlink" title="3. nameserver介绍"></a>3. nameserver介绍</h1><p>　　在rocketmq早期版本中，是没有namersrv的，而是用 zookeeper做分布式协调和服务发现的。但是后期阿里根据业务需要自主研发了轻量级的 namesrv，用于注册client服务与broker的请求路由工作，namesrv上不做任何消息的位置存储（之前的zookeeper的位置存储数据会影响整体集群性能）</p><ul><li>　　rocketmq-namesrv扮演着nameNode角色，记录着运行时消息相关的meta信息以及broker和filtersrv的运行时信息，可以部署集群；</li><li>　　可以看作是轻量级的zookeeper，但比zookeeper性能更好，可靠性更强；</li><li>　　rocketmq-namesrv主要是节点之间相互进行心跳检测、数据通信、集群高可靠性，一致性、容错性等方面的核心模块；</li><li>　　roketmq-namesrv的底层通信机制与Netty进行联系，上层通信与各个模块产生强一致性的对应关系。当broker producer consumer 都运行后，maerserv一共有8类线程：<ul><li>守护线程</li><li>定时任务线程</li><li>Netty的boss线程</li><li>NettyEventExecute线程</li><li>DestroyJavaVM线程</li><li>Work线程</li><li>Handler线程</li><li>RemotingExxecutorThread线程</li></ul></li></ul><h1 id="4-底层通信介绍"><a href="#4-底层通信介绍" class="headerlink" title="4. 底层通信介绍"></a>4. 底层通信介绍</h1><ul><li><p>ServerHouseKeepingService</p><blockquote><p>守护线程，本质是 ChannelEventListner,监听broker的channel变化来更新本地的RouteInfo.</p></blockquote></li><li><p>NSScheduledThread：定时任务线程，定时跑2个线程，第一个：每个10分钟&gt; &gt; 扫描出不活动的broker,然后 从routeInfo中剔除；第二个：每10分钟定时打印configTable的信息。</p></li><li><p>NettyBossSelector</p><blockquote><p>Metty的boss线程，</p></blockquote></li><li><p>NettyEventExecuter</p><blockquote><p>一个单独的线程，监听NettyChannel状态变化来通知ChannelEventListener做响应动作。</p></blockquote></li><li><p>DestroyJavaVM</p><blockquote><p>Java虚拟机解析钩子，已办是当虚拟机关闭时用来清理或者释放资源；</p></blockquote></li><li><p>NettyServerSelector</p><blockquote><p>Netty的work线程，可能有多个。</p></blockquote></li><li><p>NettyServerWorkerThread_x</p><blockquote><p>执行ChannelHandler方法的线程。</p></blockquote></li><li><p>RemotingExecutorThread_x</p><blockquote><p>服务端逻辑线程</p></blockquote></li></ul><h1 id="6-推荐"><a href="#6-推荐" class="headerlink" title="6. 推荐"></a>6. 推荐</h1><p><a href="https://mp.weixin.qq.com/s/UIPgD7EaaiOArwctdVmJAA" target="_blank" rel="noopener">【Rocketmq源码阅读】</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 源码目录 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列05--Hello world入门篇</title>
      <link href="/2018/08/29/RocketMQ%E7%B3%BB%E5%88%9705--HelloWorld%E5%85%A5%E9%97%A8/"/>
      <url>/2018/08/29/RocketMQ%E7%B3%BB%E5%88%9705--HelloWorld%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>前面几篇介绍了rocketmq的基本概念,结构,集群搭建方案,上一篇搭建了2m-noslave双主集群模式的broker。接下来，我们下载 rocketmq的源码包，根据里面的示例来进一步了解 rocketmq的各种特性。</p><p>源码地址： <a href="https://github.com/apache/rocketmq/" target="_blank" rel="noopener">https://github.com/apache/rocketmq/</a><br>我们会参考 example的示例代码来入门。（我这里依然采用的时3.2.6版本）</p><h1 id="1-pom依赖"><a href="#1-pom依赖" class="headerlink" title="1.pom依赖"></a>1.pom依赖</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--rocketmq--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.2.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="2-producer示例代码"><a href="#2-producer示例代码" class="headerlink" title="2.producer示例代码"></a>2.producer示例代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class Producer &#123;</span><br><span class="line">    public static void main(String[] args) throws MQClientException, InterruptedException &#123;</span><br><span class="line">        //设置 producerGroup 名称,保证不同的业务唯一性.</span><br><span class="line">        DefaultMQProducer producer = new DefaultMQProducer(&quot;DingDing&quot;);</span><br><span class="line">        //设置 nameserver地址.</span><br><span class="line">        producer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">        //启动 producer.</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        // 发送消息.</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line"></span><br><span class="line">                Message msg = new Message(&quot;DingDing_Topic&quot;, // topic</span><br><span class="line">                        &quot;sign_up&quot;,                           // tags</span><br><span class="line">                        (&quot;员工&quot; + i + &quot;签到&quot;).getBytes());        // body</span><br><span class="line"></span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                log.info(&quot;发送结果:&quot; + sendResult);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 关闭 producer.</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤</strong></p><blockquote><p>1.设置 producer group name，用来区分不同业务的producer，因此需要保证不同业务改名称不同；</p><p>2.指定链接的nameserver的地址，集群的话地址间以 ； 分割；</p><p>3.启动消息生产者；</p><p>4.构造消息对象，发送消息，处理发送结果；</p><p>5.当发送消息结束后，应该关闭producer.</p></blockquote><h1 id="3-consumer示例代码"><a href="#3-consumer示例代码" class="headerlink" title="3.consumer示例代码"></a>3.consumer示例代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, MQClientException &#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;DingDing&quot;);</span><br><span class="line">        //设置 nameserver地址.</span><br><span class="line">        consumer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">        /**</span><br><span class="line">         * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span><br><span class="line">         * 如果非第一次启动，那么按照上次消费的位置继续消费</span><br><span class="line">         */</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(&quot;DingDing_Topic&quot;, &quot;*&quot;);</span><br><span class="line"></span><br><span class="line">//        consumer.setConsumeMessageBatchMaxSize(10);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            // 接收消息.</span><br><span class="line">            @Override</span><br><span class="line">            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,</span><br><span class="line">                                                            ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">//                System.out.println(Thread.currentThread().getName() + &quot; 收到消息 &quot; + msgs);</span><br><span class="line">                System.out.println(&quot;本批次收到消息的数量 &quot; + msgs.size());</span><br><span class="line">                for(MessageExt msg : msgs)&#123;</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        String topic = msg.getTopic();</span><br><span class="line">                        String tags = msg.getTags();</span><br><span class="line">                        String msgBody =  new String(msg.getBody(),&quot;utf-8&quot;);</span><br><span class="line">                        System.out.println(&quot;收到消息--&quot; + &quot; topic:&quot; + topic + &quot; ,tags:&quot; + tags + &quot; ,msg:&quot; +msgBody);</span><br><span class="line">//                        System.out.println();</span><br><span class="line">                    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">//有异常抛出来，不要全捕获了，这样保证不能消费的消息下次重推，每次重新消费间隔：10s,30s,1m,2m,3m</span><br><span class="line">                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Consumer Started.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤</strong></p><blockquote><p>1.同producer 需要设置 producer group一样，消费者同样需要设置 consumer group name;<br>2.指定nameserver的地址，需要同要处理的producer的nameserver的地址相同；<br>3.指定消费者要消费的位置（通常设置为：从头开始 CONSUME_FROM_FIRST_OFFSET）；<br>4.订阅要处理的主题 topic 及 细分 tags；<br>5.注册监听器开始监听broker中是否有消息队列，编写消费逻辑；如果没有return success ，consumer会重新消费该消息，直到return success。<br>6.启动消费者实例。</p></blockquote><h1 id="4-运行结果"><a href="#4-运行结果" class="headerlink" title="4.运行结果"></a>4.运行结果</h1><p><strong>启动顺序</strong></p><blockquote><p>先启动 consumer实例，再启动 producer 实例；默认 是单线程的一条一条的去处理消息，原子性，保证了消息处理的实时性。</p></blockquote><p><strong>持久化</strong><br>RocketMQ是一定会把消息持久化的。</p><p><strong>单批次消息消费的数量</strong></p><p>如果是先启动 consumer，后启动 producer，理论上rocketmq发送的消息的数量都是1。<br>当然，如果有消息挤压的情况下，设置 consumer.setConsumeMessageBatchMaxSize(10)，可能会出现一次消息的消费数量可能是多条，这里设置的数量是 10，是最大条数是10，而不是每次批量消费的数量都是10.</p><p>结果：<br>1.先启动 Consumer，后启动 Producer，会发现每次的过来的消息数量仍然是1，说明没有消息挤压，实时消费；</p><p>2.先启动 Producer,发送一定数量的消息，然后再启动 Consumer,会发现，消费者这边接收到的消息的数量是不固定的。</p><hr><p>本次的rocketmq，简单入门就到这里，大家再运行代码的时候，可以看看重要类的属性、方法等，加深了解。</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> hello world </tag>
            
            <tag> 入门 </tag>
            
            <tag> 上手 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列04--Broker 配置文件</title>
      <link href="/2018/08/28/RocketMQ%E7%B3%BB%E5%88%9704--Broker%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/28/RocketMQ%E7%B3%BB%E5%88%9704--Broker%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="Broker配置"><a href="#Broker配置" class="headerlink" title="Broker配置"></a>Broker配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#所属集群名字</span><br><span class="line">#注意:一个集群中如果有多个master，那么每个master配置的 brokerClusterName 名字应该一样，要不然识别不了对方，不知道是一个集群内部的</span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line">#broker名字，注意此处不同的配置文件填写的不一样</span><br><span class="line">#建议:按配置文件文件名来匹配</span><br><span class="line">brokerName=broker-a|broker-b</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId=0</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">#此处nameserver跟host配置相匹配，9876为默认rk服务默认端口</span><br><span class="line">#broker启动时会跟nameserver建一个长连接，broker通过长连接才会向nameserver发新建的topic主题，然后java的客户端才能跟nameserver端发起长连接，向nameserver索取topic，找到topic主题之后，判断其所属的broker，建立长连接进行通讯，这是一个至关重要的路由的概念，重点，也是区别于其它版本的一个重要特性</span><br><span class="line">namesrvAddr=rocketmq-nameserv1:9876;rocketmq-nameserv2:9876</span><br><span class="line"></span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort=10911</span><br><span class="line"></span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen=04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">fileReservedTime=120</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line">#destroyMapedFileIntervalForcibly=120000</span><br><span class="line">#redeleteHangedFileInterval=120000</span><br><span class="line">#检测物理文件磁盘空间</span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"></span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/usr/local/rocketmq/store</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">#消息实际存储位置，和ConsumeQueue是mq的核心存储概念，之前搭建2m环境的时候创建在store下面，用于数据存储，consumequeue是一个逻辑的概念，消息过来之后，consumequeue并不是把消息所有保存起来，而是记录一个数据的位置，记录好之后再把消息存到commitlog文件里</span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/usr/local/rocketmq/store/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span><br><span class="line">#abort 文件存储路径</span><br><span class="line">abortFile=/usr/local/rocketmq/store/abort</span><br><span class="line"></span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize=65536</span><br><span class="line">#flushCommitLogLeastPages=4</span><br><span class="line">#flushConsumeQueueLeastPages=2</span><br><span class="line">#flushCommitLogThoroughInterval=10000</span><br><span class="line">#flushConsumeQueueThoroughInterval=60000</span><br><span class="line"></span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"></span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">#checkTransactionMessageEnable=false</span><br><span class="line"></span><br><span class="line">#发消息线程池数量</span><br><span class="line">#sendMessageThreadPoolNums=128</span><br><span class="line">#拉消息线程池数量</span><br><span class="line">#pullMessageThreadPoolNums=128</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> Broker </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列03--双主模式集群搭建(2m-noslave)</title>
      <link href="/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9703--%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9703--%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>　　在上一篇中,我们介绍了 rocketmq 的支持的集群方式,并且介绍了各自的优缺点。本次以多Master集群模式为例搭建一个双机Master的RocketMQ集群环境（<strong>2m-noslave</strong>集群模式）。</p><h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h1><p>　　因为rocketmq底层是 Java 语言编写，所以搭建此环境的服务器，必须已经安装和配置了 JDK。</p><h2 id="1-1-工具下载"><a href="#1-1-工具下载" class="headerlink" title="　  1.1 工具下载"></a>　  1.1 工具下载</h2><p>　　这里，我提供了本次安装rocketmq所用到的工具包。分别是：<br><img src="http://upload-images.jianshu.io/upload_images/11560519-fc516f3822f919d7" alt=""></p><p>提供了<a href="https://pan.baidu.com/s/1N4QrAgNrdwi3PacqqwxYUg#list/path=%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8C%85%2Frocketmq-software&amp;parentPath=%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8C%85" title="rocketmq安装包" target="_blank" rel="noopener">百度云盘</a>（密码：wdvm）。大家可自行下载。</p><h2 id="1-2-服务器规划"><a href="#1-2-服务器规划" class="headerlink" title="　  1.2 服务器规划"></a>　  1.2 服务器规划</h2><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">IP</th><th style="text-align:center">角色</th><th style="text-align:center">模式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">192.168.81.132</td><td style="text-align:center">nameServer1,brokerServer1</td><td style="text-align:center">Master1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">192.168.81.134</td><td style="text-align:center">nameServer2,brokerServer2</td><td style="text-align:center">Master2</td></tr></tbody></table><h2 id="1-3-基础环境搭建"><a href="#1-3-基础环境搭建" class="headerlink" title="　  1.3 基础环境搭建"></a>　  1.3 基础环境搭建</h2><ol><li>将压缩包上传到2台机器</li></ol><blockquote><p>我这里使用root用户登录,把软件包放在根目录下。</p></blockquote><ol start="2"><li>检查是否安装了JDK,如果没有安装过,则先进行安装和配置JDK(参考 <a href="https://blog.csdn.net/o135248/article/details/79931693" target="_blank" rel="noopener">linux下JDK的安装</a>)<br>3.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#检查JDK是否已安装</span><br><span class="line">[root@localhost ~]# java -version</span><br><span class="line">java version &quot;1.8.0_11&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_11-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.11-b03, mixed mode)</span><br></pre></td></tr></table></figure><h1 id="2-集群搭建"><a href="#2-集群搭建" class="headerlink" title="2.集群搭建　"></a>2.集群搭建　</h1><blockquote><p>说明：安装时，请按照自己的实际服务器环境替换相应的IP即可。</p></blockquote><h2 id="2-1-Hosts-添加信息"><a href="#2-1-Hosts-添加信息" class="headerlink" title="　  2.1 Hosts 添加信息"></a>　  2.1 Hosts 添加信息</h2><p>这里为了方便我们将 nameserver 和 broker 配置到了一台机器上,可以分开进行配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#编辑2台机器的hosts文件</span><br><span class="line">vim  /etc/hosts</span><br><span class="line"></span><br><span class="line">#配置如下的信息:</span><br><span class="line">192.168.81.132 rocketmq-nameserv1</span><br><span class="line">192.168.81.132 rocketmq-master1</span><br><span class="line"></span><br><span class="line">192.168.81.134 rocketmq-nameserv2</span><br><span class="line">192.168.81.134 rocketmq-master2</span><br><span class="line"></span><br><span class="line">#重启网卡</span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure><h2 id="2-2-解压压缩包-2台机器"><a href="#2-2-解压压缩包-2台机器" class="headerlink" title="　  2.2 解压压缩包(2台机器)"></a>　  2.2 解压压缩包(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#解压 alibaba-rocketmq-3.2.6.tar.gz 至 /usr/local</span><br><span class="line">tar -zxvf alibaba-rocketmq-3.2.6.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">#重命名(带上版本号)</span><br><span class="line">mv alibaba-rocketmq alibaba-rocketmq-3.2.6</span><br><span class="line"></span><br><span class="line">#创建软连接</span><br><span class="line">ln -s alibaba-rocketmq-3.2.6 rocketmq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ls看下</span><br><span class="line">rocketmq -&gt; alibaba-rocketmq-3.2.6</span><br></pre></td></tr></table></figure><h2 id="2-3-创建存储路径-2台机器"><a href="#2-3-创建存储路径-2台机器" class="headerlink" title="　  2.3 创建存储路径(2台机器)"></a>　  2.3 创建存储路径(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/rocketmq/store</span><br><span class="line">mkdir /usr/local/rocketmq/store/commitlog</span><br><span class="line">mkdir /usr/local/rocketmq/store/consumequeue</span><br><span class="line">mkdir /usr/local/rocketmq/store/index</span><br><span class="line"></span><br><span class="line">#或者执行下面的一条命令：</span><br><span class="line">mkdir -p /usr/local/rocketmq/store/&#123;commitlog,consumequeue,index&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-RocketMQ配置文件-2台机器"><a href="#2-4-RocketMQ配置文件-2台机器" class="headerlink" title="　  2.4 RocketMQ配置文件(2台机器)"></a>　  2.4 RocketMQ配置文件(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/rocketmq/conf/2m-noslave/broker-a.properties</span><br><span class="line">vim /usr/local/rocketmq/conf/2m-noslave/broker-b.properties</span><br></pre></td></tr></table></figure><p>删除里面的配置，粘贴下面的配置信息。(注意更改brokerName 和 namesrvAddr 的配置)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#所属集群名字</span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line">#broker名字，注意此处不同的配置文件填写的不一样</span><br><span class="line">brokerName=broker-a|broker-b</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId=0</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr=rocketmq-nameserv1:9876;rocketmq-nameserv2:9876</span><br><span class="line"></span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort=10911</span><br><span class="line"></span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen=04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">fileReservedTime=120</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line">#destroyMapedFileIntervalForcibly=120000</span><br><span class="line">#redeleteHangedFileInterval=120000</span><br><span class="line">#检测物理文件磁盘空间</span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"></span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/usr/local/rocketmq/store</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/usr/local/rocketmq/store/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span><br><span class="line">#abort 文件存储路径</span><br><span class="line">abortFile=/usr/local/rocketmq/store/abort</span><br><span class="line"></span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize=65536</span><br><span class="line">#flushCommitLogLeastPages=4</span><br><span class="line">#flushConsumeQueueLeastPages=2</span><br><span class="line">#flushCommitLogThoroughInterval=10000</span><br><span class="line">#flushConsumeQueueThoroughInterval=60000</span><br><span class="line"></span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"></span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">#checkTransactionMessageEnable=false</span><br><span class="line"></span><br><span class="line">#发消息线程池数量</span><br><span class="line">#sendMessageThreadPoolNums=128</span><br><span class="line">#拉消息线程池数量</span><br><span class="line">#pullMessageThreadPoolNums=128</span><br></pre></td></tr></table></figure><h2 id="2-5-修改日志配置文件-2台机器"><a href="#2-5-修改日志配置文件-2台机器" class="headerlink" title="　  2.5 修改日志配置文件(2台机器)"></a>　  2.5 修改日志配置文件(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#创建日志目录logs</span><br><span class="line">mkdir -p /usr/local/rocketmq/logs</span><br><span class="line">#修改日志配置文件</span><br><span class="line">cd /usr/local/rocketmq/conf &amp;&amp; sed -i &apos;s#$&#123;user.home&#125;#/usr/local/rocketmq#g&apos; *.xml</span><br></pre></td></tr></table></figure><h2 id="2-6-修改启动脚本参数-2台机器"><a href="#2-6-修改启动脚本参数-2台机器" class="headerlink" title="　  2.6 修改启动脚本参数(2台机器)"></a>　  2.6 修改启动脚本参数(2台机器)</h2><p>切换到 /usr/local/devTool/rocketmq/bin 目录下，我们发现这里存在 rocketmq的各种命令（win linux）。启动rocketmq，应该先启动nameserver,再启动broker。而broker的启动需要合适的JVM内存配置，阿里官方推荐的是4G。可以根据实际生产环境进行合理配置。</p><p><strong>编辑文件 runbroker.sh</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/rocketmq/bin/runbroker.sh</span><br><span class="line"></span><br><span class="line">#修改 runbroker 的配置 </span><br><span class="line">#===========================================================================================</span><br><span class="line"># JVM Configuration</span><br><span class="line">#===========================================================================================</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:PermSize=128m -XX:MaxPermSize=320m&quot;</span><br></pre></td></tr></table></figure></p><p><strong>编辑文件 runserver.sh</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/rocketmq/bin/runserver.sh</span><br><span class="line"></span><br><span class="line">#修改配置</span><br><span class="line">#===========================================================================================</span><br><span class="line"># JVM Configuration</span><br><span class="line">#===========================================================================================</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:PermSize=128m -XX:MaxPermSize=320m&quot;</span><br></pre></td></tr></table></figure><h2 id="2-7-启动NameServer-2台机器"><a href="#2-7-启动NameServer-2台机器" class="headerlink" title="　  2.7 启动NameServer(2台机器)"></a>　  2.7 启动NameServer(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/rocketmq/bin</span><br><span class="line">#后台启动nameserver</span><br><span class="line">nohup sh mqnamesrv &amp;</span><br><span class="line"></span><br><span class="line">#查看namesrv日志</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><h2 id="2-8-启动BrokerServer-A"><a href="#2-8-启动BrokerServer-A" class="headerlink" title="　  2.8 启动BrokerServer A"></a>　  2.8 启动BrokerServer A</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -c /usr/local/rocketmq/conf/2m-noslave/broker-a.properties &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">#查看进程及日志</span><br><span class="line">jps</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/broker.log</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><h2 id="2-9-启动BrokerServer-B"><a href="#2-9-启动BrokerServer-B" class="headerlink" title="　  2.9 启动BrokerServer B"></a>　  2.9 启动BrokerServer B</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -c /usr/local/rocketmq/conf/2m-noslave/broker-b.properties &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure><h2 id="2-10-安装-RocketMq-Console"><a href="#2-10-安装-RocketMq-Console" class="headerlink" title="　  2.10 安装 RocketMq Console"></a>　  2.10 安装 RocketMq Console</h2><ol><li><p><strong>解压缩 tomcat 到 /usr/local目录下，并且重命名为 rocketmq-console-tomcat.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#解压缩 tomcat 到 /usr/local目录下</span><br><span class="line">tar -zxvf apache-tomcat-8.5.30.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">#重命名为 rocketmq-console-tomcat</span><br><span class="line">cd /usr/local</span><br><span class="line">mv apache-tomcat-8.5.30/ rocketmq-console-tomcat</span><br></pre></td></tr></table></figure></li><li><p><strong>安装 rocketmq-console.war，修改配置并启动</strong></p></li></ol><p>我这里将 rocketmq-console安装在【134】的机器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#将war包放到 刚解压缩的tomcat 的webapps目录下</span><br><span class="line">cp rocketmq-console.war /usr/local/rocketmq-console-tomcat/webapps/</span><br><span class="line"></span><br><span class="line">#解压缩war包</span><br><span class="line">unzip rocketmq-console.war -d rocketmq-console</span><br><span class="line"></span><br><span class="line">#修改配置</span><br><span class="line">vim /usr/local/rocketmq-console-tomcat/webapps/rocketmq-console/WEB-INF/classes/config.properties </span><br><span class="line">修改 rocketmq.namesrv.addr 项的内容为：</span><br><span class="line">rocketmq.namesrv.addr = rocketmq-nameserv1:9876;rocketmq-nameserv2:9876</span><br><span class="line"></span><br><span class="line">#切换到tomcat的bin路径下，启动tomcat,浏览器访问</span><br><span class="line">cd /usr/local/rocketmq-console-tomcat/bin/</span><br><span class="line">./startup.sh</span><br><span class="line"></span><br><span class="line">#启动日志</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq-console-tomcat/logs/catalina.out </span><br><span class="line"></span><br><span class="line">#浏览器访问：（确认防火墙已关闭）</span><br><span class="line">http://192.168.81.134:8080/rocketmq-console</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-f6910b13c30e3f90.png" alt=""></p><h2 id="2-11-数据清理"><a href="#2-11-数据清理" class="headerlink" title="　  2.11 数据清理"></a>　  2.11 数据清理</h2><p>启动时，先启动 nameserver,再启动 broker;</p><p>关闭时，则相反，先关闭 broker,再 关闭 nameserver(早起晚归)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/rocketmq/bin</span><br><span class="line">sh mqshutdown broker</span><br><span class="line">sh mqshutdown namesrv</span><br><span class="line"></span><br><span class="line">##等待停止</span><br><span class="line">rm -rf /usr/local/devTool/rocketmq/store</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store/commitlog</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store/consumequeue</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store/index</span><br></pre></td></tr></table></figure></p><p>到此,2m-noslave集群模式已搭建完毕,下一篇,我们会对 broker的配置文件中的配置项做介绍,这样有利于后期的更自如得学习.</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 集群 </tag>
            
            <tag> 2m-noslave </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列02--集群构建模型</title>
      <link href="/2018/08/26/RocketMQ%E7%B3%BB%E5%88%9702--%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/26/RocketMQ%E7%B3%BB%E5%88%9702--%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>　　本篇主要是对 RocketMQ的集群搭建的几种方式做简单介绍及其优缺点，便于自己在项目中，根据自己的业务需要做技术选型。在上一篇中，我们介绍了RocketMQ的物理部署结构，知道了它是由NameServer、Producer、Consumer和Broker来组成，各自的作用也做了说明。而这篇介绍的集群的搭建，这里的“集群”指的就是 Broker集群的搭建。</p><p>　　Broker 分为 Master 和 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master，Master 和 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerId 来定义，BrokerId为 0 表示 Master，非 0 表示 Slave。Master 也可以部署多个。</p><p>​　　推荐的几种 Broker 集群部署方式，这里的 Slave 不可写，但可读，类似于 Mysql 主备方式。</p><h1 id="1-单-Master"><a href="#1-单-Master" class="headerlink" title="1.单 Master"></a>1.单 Master</h1><blockquote><p>　　即系统所有的消息都存储在一个 Broker上，这种方式风险较大，一旦 Broker 重启或者宕机时，会导致整个服务不可用。这种只适合入门helloworld实例，强烈不建议线上环境使用。</p></blockquote><h1 id="2-多-Master-模式"><a href="#2-多-Master-模式" class="headerlink" title="2.多 Master 模式"></a>2.多 Master 模式</h1><blockquote><p>​    一个集群无Slave，全是Master，例如2个Master或者3个Master。</p></blockquote><p><strong>优点</strong></p><blockquote><p>​　　配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。</p></blockquote><p><strong>缺点</strong></p><blockquote><p>​    单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响。</p></blockquote><p>　　这里介绍下【异步刷盘】、【同步刷盘】、【Broker间数据同步/复制】。</p><p>【异步刷盘】：ASYNC_FLUSH,生产者发送的每一条消息并不是立即保存到磁盘,而是暂时缓存起来,然后就返回生产者成功。然后再异步的将缓存数据保存到磁盘，这里有2种情况：</p><pre><code>1.定期将缓存种更新的数据进行刷盘；2.当缓存中更新的数据条数达到某一设定值进行刷盘。</code></pre><p>这种方式会存在消息丢失（场景：在还未来得及同步到磁盘的时候宕机），但是性能很好，rokectmq默认是这种模式。</p><p>【同步刷盘】：生产者发送的每一条消息都在保存到磁盘成功后才返回告诉生产者成功。这种方式不会存在消息丢失的问题，但是有很大的磁盘IO开销，性能有一定影响。</p><p>【Broker Replication】:Broker间数据同步/复制。集群环境下需要部署多个Broker，Broker分2种角色：Master和Slave。</p><pre><code>1.一种是master,Master即可以读，也可以写，设置brokerId=0,只能设置一个。2.另外一种是slave,只允许读，其brokerId为非0。</code></pre><p>　　一个master与多个slave通过指定相同的brokerName被归为一个 broker set（broker集群）。通常生产环境中，我们至少需要2个broker Set。Broker Replication指的就是slave 获取或者复制master的数据。</p><pre><code>1.sync Broker: 生产者发送的每一条消息都至少同步复制到一个slave后才返回告诉生产者成功，即&quot;同步双写&quot;；2.Async Broker: 生产者发送的每一条消息只要写入master就返回告诉生产者成功，然后再&quot;异步复制&quot;到slave.</code></pre><h1 id="3-多-Master-多-Slave-模式，异步复制"><a href="#3-多-Master-多-Slave-模式，异步复制" class="headerlink" title="3.多 Master 多 Slave 模式，异步复制"></a>3.多 Master 多 Slave 模式，异步复制</h1><blockquote><p>每个Master配置一个或多个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟，毫秒级。</p></blockquote><p><strong>优点</strong></p><blockquote><p>　　即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为Master宕机后，消费者仍然可以从Slave消费，此过程对应用透明。不需要人工干预。性能同多Master模式几乎一样。</p></blockquote><p><strong>缺点</strong></p><blockquote><p>　　Master宕机，磁盘损坏情况，会丢失少量消息。当producer向master发送完数据时，这时候还没等到master向slave做同步，master宕机了，则在master上的数据会丢失，消费者在salve上消费不到刚刚的消息。</p></blockquote><h1 id="4-多-Master-多-Slave-模式，同步双写"><a href="#4-多-Master-多-Slave-模式，同步双写" class="headerlink" title="4.多 Master 多 Slave 模式，同步双写"></a>4.多 Master 多 Slave 模式，同步双写</h1><blockquote><p>每个Master配置一个或多个Slave，有多对Master-Slave，HA采用同步双写方式，主备都写成功，向应用返回成功。</p></blockquote><p><strong>优点</strong></p><blockquote><p>数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高。</p></blockquote><p><strong>缺点</strong></p><blockquote><p> 　　性能比异步复制模式略低，大约低10%左右，发送单个消息的RT会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。</p></blockquote><p>在下篇中，我们会进行 2-master集群环境的搭建和配置。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.《RocketMQ用户指南》</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列01--简介及概念</title>
      <link href="/2018/08/25/RocketMQ%E7%B3%BB%E5%88%9701--%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/08/25/RocketMQ%E7%B3%BB%E5%88%9701--%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h1 id="1-RocketMQ是什么？"><a href="#1-RocketMQ是什么？" class="headerlink" title="1.RocketMQ是什么？"></a>1.RocketMQ是什么？</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB1rdyvPXXXXXcBapXXXXXXXXXX" alt=""></p><p>RocketMQ：</p><ul><li><p>是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式的特点；</p></li><li><p>Producer、Consumer、队列都可以分布式部署；</p></li><li><p>Producer向一些队列轮流发送消息，这些队列集合称为”Topic”。Consumer如果做广播消费，则一个Consumer实例消费这个Topic对应的所有的队列，如果是集群消费，则多个Consumer实例平均消费这个topic队列集合；</p></li><li><p>保证严格的消息顺序；</p></li><li><p>提供丰富的消息拉去模式；</p></li><li><p>高效的订阅者水平扩展能力；</p></li><li><p>实时的消息订阅机制；</p></li><li><p>亿级消息堆积能力。</p><p>RocketMQ是Java语言编写，基于通信框架Netty。</p></li></ul><h1 id="2-RocketMQ物理部署结构"><a href="#2-RocketMQ物理部署结构" class="headerlink" title="2.RocketMQ物理部署结构"></a>2.RocketMQ物理部署结构</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB18GKUPXXXXXXRXFXXXXXXXXXX" alt=""></p><p>从上图中，我们可以看到消息队列的主要角色有：</p><ul><li>NameServer:无状态节点，供 Producer 和 Consumer 获取Broker地址。</li><li>Broker:MQ的服务器，消息的中转角色，负责存储和转发消息。</li><li>Producer:发送消息到消息队列(消息生产者)。</li><li>Consumer:从消息队列接收消息（消息消费者）。</li></ul><p>RocketMQ网络部署特点：</p><ul><li><p>　　NameServer是一个无状态的节点，可集群部署，节点之间无任何信息同步。</p></li><li><p>　　Broker:分为Master和Slave.一个Master可以有多个Slave,但是一个Slave只能对应一个Master.Master和Slave的对应关系是通过指定 “相同的BrokerName,不同的BrokerId”来定义。BrokerId=0表示Master,非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有的NameServer。</p></li><li><p>　　Producer与NamerServer中的任意一个节点建立长连接，定期从NameServer中取Topic的路由信息，并与提供Topic服务的Master建立长连接，定时向Master发送心跳。可集群部署。</p></li><li><p>　　Consumer与NamerServer中的任意一个节点建立长连接，定期从NameServer中取Topic的路由信息，并与提供Topic服务的Master和Slave建立长连接，且定时向Master和Slave发送心跳。Consumer既可以从 Master 订阅消息，也可以从 Slave 订阅消息，订阅规则由 Broker 配置决定。</p></li></ul><h1 id="3-RocketMQ逻辑部署结构"><a href="#3-RocketMQ逻辑部署结构" class="headerlink" title="3.RocketMQ逻辑部署结构"></a>3.RocketMQ逻辑部署结构</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB1lEPePXXXXXX8XXXXXXXXXXXX" alt=""></p><p><strong>Producer Group</strong></p><blockquote><p>​　　用来表示一个収送消息应用，一个 Producer Group 下包含多个 Producer 实例，可以是多台机器，也可以是一台机器的多个迕程，戒者一个迕程的多个 Producer 对象。一个 Producer Group 可以収送多个 Topic消息。作用有：</p><p>​    1.标识一类producer;</p><p>​    2.查询返个収送消息应用下有多个 Producer 实例;</p><p>​    3.収送分布式事务消息时，如果 Producer 中途意外宕机，Broker 会主劢回调 Producer Group 内的任意一台机器来确讣事务状态。</p></blockquote><p><strong>Consumer Group</strong></p><blockquote><p>​　　用来表示一个消费消息应用，一个 Consumer Group 下包含多个 Consumer 实例，可以是多台机器，也可以是多个迕程，戒者是一个迕程的多个 Consumer 对象。一个 Consumer Group 下的多个 Consumer 以均摊方式消费消息，如果设置为广播方式，那举返个 Consumer Group 下的每个实例都消费全量数据。</p></blockquote><ul><li><p>Topic：消息的逻辑管理单位；</p></li><li><p>Message Queue:消息物理管理单位，一个Topic可以有若干个Queue;</p></li><li><p>Message:消息</p><ul><li>body：消息体，用于携带消息的内容。</li><li>key:消息key,用于区分不同的消息，一般是业务id信息，根据key可查询到消息；</li><li>tag:消息tag,用于不同的订阅者来过滤消息。</li></ul><p>​</p></li></ul><h1 id="4-概念术语"><a href="#4-概念术语" class="headerlink" title="4.概念术语"></a><strong>4</strong>.概念术语</h1><ul><li>广播消费</li></ul><blockquote><p>　　 一条消息被多个 Consumer 消费，即使返些 Consumer 属亍同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次，广播消费中的 Consumer Group 概念可以讣为在消息划分方面无意义。</p></blockquote><ul><li>集群消费</li></ul><blockquote><p>​　　一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个Consumer Group 有 3 个实例（可能是 3 个迕程，戒者 3 台机器），那举每个实例只消费其中的 3 条消息。在 CORBA Notification 规范中，无此消费方式。<br>​    在 JMS 规范中，JMS point-to-point model 类似，但是 RocketMQ 的集群消费功能大等于 PTP 模型。<br>​    因为 RocketMQ 单个 Consumer Group 内的消费者类似于 PTP，但是一个 Topic/Queue 可以被多个 Consumer Group 消费。</p></blockquote><ul><li>顺序消息</li></ul><blockquote><p>　　消费消息的顺序要同发送消息的顺序一致，在 RocketMQ 中，主要指的是局部顺序，即一类消息为满足顺序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 发送的顺序去消费消息。</p></blockquote><ul><li>普通顺序消息</li></ul><blockquote><p>​    顺序消息的一种，正常情况下可以保证完全的顺序消息，但是一旦发生通信异常，Broker 重启，由于队列总数发生发化，哈希取模后定位的队列会发化，产生短暂的消息顺序不一致。<br>如果业务能容忍在集群异常情况（如某个 Broker 宕机或者重启）下，消息短暂的乱序，使用普通顺序方式比较合适。</p></blockquote><ul><li>严格的顺序消息</li></ul><blockquote><p>​　　顺序消息的一种，无论正常异常情况都能保证顺序，但是牺牲了分布式 Failover 特性，即 Broker 集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。</p></blockquote><blockquote><p>　　如果服务器部署为同步双写模式，此缺陷可通过备机自动切换为主避免，不过仍然会存在几分钟的服务不可用。（依赖同步双写，主备自动切换，自动切换功能目前还未实现）<br>目前已知的应用只有数据库 binlog 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息。</p></blockquote><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h1><p>1.RocketMQ 开发指南（V3.2.4）</p><p>2.<a href="https://blog.csdn.net/gwd1154978352/article/details/80654314" target="_blank" rel="noopener">RocketMQ——初识RocketMQ</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>大家好，我是”李乔子的酒”。欢迎来到我的个人技术博客。</p><p>我是一个Java入门2年的”小猿”,今后会在本博客写下自己的工作和生活日常.</p><p>让我们一起,变得更加优秀!</p><h4 id="历史纪录"><a href="#历史纪录" class="headerlink" title="历史纪录"></a>历史纪录</h4><table><thead><tr><th>日期</th><th>优化记录</th><th>完成日期</th><th>责任人</th></tr></thead><tbody><tr><td>2018-08-19</td><td>整理读书资源,对读书页面中的书籍增加 “百度云盘”下载</td><td></td><td>lemon</td></tr><tr><td>2018-08-19</td><td>新增 “Tools”工具页面,提供日常及开发常用工具一站式下载</td><td></td><td>lemon</td></tr><tr><td>2018-08-19</td><td>申请 “七牛云”存储,提供文件存储功能</td><td></td><td>lemon</td></tr></tbody></table>]]></content>
    </entry>
    
    <entry>
      <title>读书</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>resources</title>
      <link href="/resources/index.html"/>
      <url>/resources/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
