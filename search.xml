<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>RocketMQ系列06--整体架构概述</title>
      <link href="/2018/08/30/RocketMQ%E7%B3%BB%E5%88%9706--%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/08/30/RocketMQ%E7%B3%BB%E5%88%9706--%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>　　本篇,我主要根据 rocketmq的源码目录,简单介绍下 rocketmq各模块的功能,及其各自间的相互调用。接着大体上说一下 其中的nameserver，底层通信和数据存储。但里面的东西还需要大家去阅读源码，仔细体会。这里只是做个引子。我在文章的最后推荐了 【Rocketmq源码阅读】的系列博客，对大家阅读源码可能会有帮助。<br>废话不多说，直入主题。</p><h1 id="1-源码目录"><a href="#1-源码目录" class="headerlink" title="1. 源码目录"></a>1. 源码目录</h1><p>　　我这里是下载的 最新的 RocekyMQ 4.4.0-SNAPSHOT版本的<a href="https://github.com/apache/rocketmq/" target="_blank" rel="noopener">源码</a><br>导入到 IDEA中，目录结构如图：</p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-53e6a18b34657498.png" alt=""></p><ul><li><p>distribution</p><blockquote><p>　　存放系统中的脚本，以及一些broker集群的配置文件，用户可以根据自己的项目信息更改配置文件或脚本中的内容，来启动 nameserver 和 broker,集合 example中的Producer/Consumer来做一些小测试。</p></blockquote></li><li><p>broker</p><blockquote><p>　　消息代理，起到 串联 Producer/Consumer 和 Store的作用。我们所谓的消息的存储、接收、拉去、推送等操作都是在broker上进行的。</p></blockquote></li><li><p>client</p><blockquote><p>　　包含 Producer 和 Consumer，负责消息的发和收。</p></blockquote></li><li><p>common</p><blockquote><p>　　通用的常量枚举、基类方法或数据结构，按描述的目标来分包，</p></blockquote></li><li><p>example</p><blockquote><p>　　使用样例，包含各种使用方法，Pull/Push模式，广播模式、有序消息，事务消息。</p></blockquote></li><li><p>filter</p><blockquote><p>　　过滤器，用于服务端的过滤方式，实现了真正意义的高内聚低耦合的设计思想。<br>　　在使用filter模块的时候需要启动filter的服务。</p></blockquote></li><li><p>logappender logging</p><blockquote><p>　　日志相关。</p></blockquote></li><li><p>namesrv</p><blockquote><p>　　注册中心，每个broker都会在这里注册，client也会从这里获取broker 的相关信息。</p></blockquote></li><li><p>openmessaging</p><blockquote></blockquote></li><li><p>remoting</p><blockquote><p>　　基于Netty实现的额昂罗通信模块，包括server和client,client broker filter 等模块都对他有依赖。</p></blockquote></li><li><p>srvutil</p><blockquote><p>　　用来处理命令行的，一个用来配置shutdownHook.目的为了拆分客户端依赖，尽可能减少客户端的依赖。</p></blockquote></li><li><p>store</p><blockquote><p>　　负责消息的存储和读取。</p></blockquote></li><li><p>test</p><blockquote><p>　　测试用例代码</p></blockquote></li><li><p>tools</p><blockquote><p>　　一些工具类，基于他们可以写一些工具来管理、查看MQ系统的一些信息。</p></blockquote></li></ul><h1 id="2-模块调用图及层次说明"><a href="#2-模块调用图及层次说明" class="headerlink" title="2. 模块调用图及层次说明"></a>2. 模块调用图及层次说明</h1><p><img src="https://upload-images.jianshu.io/upload_images/11560519-f4bf6ba3b4f5bc93.png" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-aa7a629b10e20a53.png" alt=""></p><h1 id="3-nameserver介绍"><a href="#3-nameserver介绍" class="headerlink" title="3. nameserver介绍"></a>3. nameserver介绍</h1><p>　　在rocketmq早期版本中，是没有namersrv的，而是用 zookeeper做分布式协调和服务发现的。但是后期阿里根据业务需要自主研发了轻量级的 namesrv，用于注册client服务与broker的请求路由工作，namesrv上不做任何消息的位置存储（之前的zookeeper的位置存储数据会影响整体集群性能）</p><ul><li>　　rocketmq-namesrv扮演着nameNode角色，记录着运行时消息相关的meta信息以及broker和filtersrv的运行时信息，可以部署集群；</li><li>　　可以看作是轻量级的zookeeper，但比zookeeper性能更好，可靠性更强；</li><li>　　rocketmq-namesrv主要是节点之间相互进行心跳检测、数据通信、集群高可靠性，一致性、容错性等方面的核心模块；</li><li>　　roketmq-namesrv的底层通信机制与Netty进行联系，上层通信与各个模块产生强一致性的对应关系。当broker producer consumer 都运行后，maerserv一共有8类线程：<ul><li>守护线程</li><li>定时任务线程</li><li>Netty的boss线程</li><li>NettyEventExecute线程</li><li>DestroyJavaVM线程</li><li>Work线程</li><li>Handler线程</li><li>RemotingExxecutorThread线程</li></ul></li></ul><h1 id="4-底层通信介绍"><a href="#4-底层通信介绍" class="headerlink" title="4. 底层通信介绍"></a>4. 底层通信介绍</h1><ul><li><p>ServerHouseKeepingService</p><blockquote><p>守护线程，本质是 ChannelEventListner,监听broker的channel变化来更新本地的RouteInfo.</p></blockquote></li><li><p>NSScheduledThread：定时任务线程，定时跑2个线程，第一个：每个10分钟&gt; &gt; 扫描出不活动的broker,然后 从routeInfo中剔除；第二个：每10分钟定时打印configTable的信息。</p></li><li><p>NettyBossSelector</p><blockquote><p>Metty的boss线程，</p></blockquote></li><li><p>NettyEventExecuter</p><blockquote><p>一个单独的线程，监听NettyChannel状态变化来通知ChannelEventListener做响应动作。</p></blockquote></li><li><p>DestroyJavaVM</p><blockquote><p>Java虚拟机解析钩子，已办是当虚拟机关闭时用来清理或者释放资源；</p></blockquote></li><li><p>NettyServerSelector</p><blockquote><p>Netty的work线程，可能有多个。</p></blockquote></li><li><p>NettyServerWorkerThread_x</p><blockquote><p>执行ChannelHandler方法的线程。</p></blockquote></li><li><p>RemotingExecutorThread_x</p><blockquote><p>服务端逻辑线程</p></blockquote></li></ul><h1 id="6-推荐"><a href="#6-推荐" class="headerlink" title="6. 推荐"></a>6. 推荐</h1><p><a href="https://mp.weixin.qq.com/s/UIPgD7EaaiOArwctdVmJAA" target="_blank" rel="noopener">【Rocketmq源码阅读】</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 源码目录 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列05--Hello world入门篇</title>
      <link href="/2018/08/29/RocketMQ%E7%B3%BB%E5%88%9705--HelloWorld%E5%85%A5%E9%97%A8/"/>
      <url>/2018/08/29/RocketMQ%E7%B3%BB%E5%88%9705--HelloWorld%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>前面几篇介绍了rocketmq的基本概念,结构,集群搭建方案,上一篇搭建了2m-noslave双主集群模式的broker。接下来，我们下载 rocketmq的源码包，根据里面的示例来进一步了解 rocketmq的各种特性。</p><p>源码地址： <a href="https://github.com/apache/rocketmq/" target="_blank" rel="noopener">https://github.com/apache/rocketmq/</a><br>我们会参考 example的示例代码来入门。（我这里依然采用的时3.2.6版本）</p><h1 id="1-pom依赖"><a href="#1-pom依赖" class="headerlink" title="1.pom依赖"></a>1.pom依赖</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--rocketmq--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.2.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="2-producer示例代码"><a href="#2-producer示例代码" class="headerlink" title="2.producer示例代码"></a>2.producer示例代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class Producer &#123;</span><br><span class="line">    public static void main(String[] args) throws MQClientException, InterruptedException &#123;</span><br><span class="line">        //设置 producerGroup 名称,保证不同的业务唯一性.</span><br><span class="line">        DefaultMQProducer producer = new DefaultMQProducer(&quot;DingDing&quot;);</span><br><span class="line">        //设置 nameserver地址.</span><br><span class="line">        producer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">        //启动 producer.</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        // 发送消息.</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line"></span><br><span class="line">                Message msg = new Message(&quot;DingDing_Topic&quot;, // topic</span><br><span class="line">                        &quot;sign_up&quot;,                           // tags</span><br><span class="line">                        (&quot;员工&quot; + i + &quot;签到&quot;).getBytes());        // body</span><br><span class="line"></span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                log.info(&quot;发送结果:&quot; + sendResult);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 关闭 producer.</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤</strong></p><blockquote><p>1.设置 producer group name，用来区分不同业务的producer，因此需要保证不同业务改名称不同；</p><p>2.指定链接的nameserver的地址，集群的话地址间以 ； 分割；</p><p>3.启动消息生产者；</p><p>4.构造消息对象，发送消息，处理发送结果；</p><p>5.当发送消息结束后，应该关闭producer.</p></blockquote><h1 id="3-consumer示例代码"><a href="#3-consumer示例代码" class="headerlink" title="3.consumer示例代码"></a>3.consumer示例代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, MQClientException &#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;DingDing&quot;);</span><br><span class="line">        //设置 nameserver地址.</span><br><span class="line">        consumer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">        /**</span><br><span class="line">         * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span><br><span class="line">         * 如果非第一次启动，那么按照上次消费的位置继续消费</span><br><span class="line">         */</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(&quot;DingDing_Topic&quot;, &quot;*&quot;);</span><br><span class="line"></span><br><span class="line">//        consumer.setConsumeMessageBatchMaxSize(10);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            // 接收消息.</span><br><span class="line">            @Override</span><br><span class="line">            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,</span><br><span class="line">                                                            ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">//                System.out.println(Thread.currentThread().getName() + &quot; 收到消息 &quot; + msgs);</span><br><span class="line">                System.out.println(&quot;本批次收到消息的数量 &quot; + msgs.size());</span><br><span class="line">                for(MessageExt msg : msgs)&#123;</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        String topic = msg.getTopic();</span><br><span class="line">                        String tags = msg.getTags();</span><br><span class="line">                        String msgBody =  new String(msg.getBody(),&quot;utf-8&quot;);</span><br><span class="line">                        System.out.println(&quot;收到消息--&quot; + &quot; topic:&quot; + topic + &quot; ,tags:&quot; + tags + &quot; ,msg:&quot; +msgBody);</span><br><span class="line">//                        System.out.println();</span><br><span class="line">                    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">//有异常抛出来，不要全捕获了，这样保证不能消费的消息下次重推，每次重新消费间隔：10s,30s,1m,2m,3m</span><br><span class="line">                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Consumer Started.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤</strong></p><blockquote><p>1.同producer 需要设置 producer group一样，消费者同样需要设置 consumer group name;<br>2.指定nameserver的地址，需要同要处理的producer的nameserver的地址相同；<br>3.指定消费者要消费的位置（通常设置为：从头开始 CONSUME_FROM_FIRST_OFFSET）；<br>4.订阅要处理的主题 topic 及 细分 tags；<br>5.注册监听器开始监听broker中是否有消息队列，编写消费逻辑；如果没有return success ，consumer会重新消费该消息，直到return success。<br>6.启动消费者实例。</p></blockquote><h1 id="4-运行结果"><a href="#4-运行结果" class="headerlink" title="4.运行结果"></a>4.运行结果</h1><p><strong>启动顺序</strong></p><blockquote><p>先启动 consumer实例，再启动 producer 实例；默认 是单线程的一条一条的去处理消息，原子性，保证了消息处理的实时性。</p></blockquote><p><strong>持久化</strong><br>RocketMQ是一定会把消息持久化的。</p><p><strong>单批次消息消费的数量</strong></p><p>如果是先启动 consumer，后启动 producer，理论上rocketmq发送的消息的数量都是1。<br>当然，如果有消息挤压的情况下，设置 consumer.setConsumeMessageBatchMaxSize(10)，可能会出现一次消息的消费数量可能是多条，这里设置的数量是 10，是最大条数是10，而不是每次批量消费的数量都是10.</p><p>结果：<br>1.先启动 Consumer，后启动 Producer，会发现每次的过来的消息数量仍然是1，说明没有消息挤压，实时消费；</p><p>2.先启动 Producer,发送一定数量的消息，然后再启动 Consumer,会发现，消费者这边接收到的消息的数量是不固定的。</p><hr><p>本次的rocketmq，简单入门就到这里，大家再运行代码的时候，可以看看重要类的属性、方法等，加深了解。</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> hello world </tag>
            
            <tag> 入门 </tag>
            
            <tag> 上手 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列04--Broker 配置文件</title>
      <link href="/2018/08/28/RocketMQ%E7%B3%BB%E5%88%9704--Broker%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/28/RocketMQ%E7%B3%BB%E5%88%9704--Broker%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="Broker配置"><a href="#Broker配置" class="headerlink" title="Broker配置"></a>Broker配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#所属集群名字</span><br><span class="line">#注意:一个集群中如果有多个master，那么每个master配置的 brokerClusterName 名字应该一样，要不然识别不了对方，不知道是一个集群内部的</span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line">#broker名字，注意此处不同的配置文件填写的不一样</span><br><span class="line">#建议:按配置文件文件名来匹配</span><br><span class="line">brokerName=broker-a|broker-b</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId=0</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">#此处nameserver跟host配置相匹配，9876为默认rk服务默认端口</span><br><span class="line">#broker启动时会跟nameserver建一个长连接，broker通过长连接才会向nameserver发新建的topic主题，然后java的客户端才能跟nameserver端发起长连接，向nameserver索取topic，找到topic主题之后，判断其所属的broker，建立长连接进行通讯，这是一个至关重要的路由的概念，重点，也是区别于其它版本的一个重要特性</span><br><span class="line">namesrvAddr=rocketmq-nameserv1:9876;rocketmq-nameserv2:9876</span><br><span class="line"></span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort=10911</span><br><span class="line"></span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen=04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">fileReservedTime=120</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line">#destroyMapedFileIntervalForcibly=120000</span><br><span class="line">#redeleteHangedFileInterval=120000</span><br><span class="line">#检测物理文件磁盘空间</span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"></span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/usr/local/rocketmq/store</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">#消息实际存储位置，和ConsumeQueue是mq的核心存储概念，之前搭建2m环境的时候创建在store下面，用于数据存储，consumequeue是一个逻辑的概念，消息过来之后，consumequeue并不是把消息所有保存起来，而是记录一个数据的位置，记录好之后再把消息存到commitlog文件里</span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/usr/local/rocketmq/store/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span><br><span class="line">#abort 文件存储路径</span><br><span class="line">abortFile=/usr/local/rocketmq/store/abort</span><br><span class="line"></span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize=65536</span><br><span class="line">#flushCommitLogLeastPages=4</span><br><span class="line">#flushConsumeQueueLeastPages=2</span><br><span class="line">#flushCommitLogThoroughInterval=10000</span><br><span class="line">#flushConsumeQueueThoroughInterval=60000</span><br><span class="line"></span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"></span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">#checkTransactionMessageEnable=false</span><br><span class="line"></span><br><span class="line">#发消息线程池数量</span><br><span class="line">#sendMessageThreadPoolNums=128</span><br><span class="line">#拉消息线程池数量</span><br><span class="line">#pullMessageThreadPoolNums=128</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> Broker </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列03--双主模式集群搭建(2m-noslave)</title>
      <link href="/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9703--%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9703--%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>　　在上一篇中,我们介绍了 rocketmq 的支持的集群方式,并且介绍了各自的优缺点。本次以多Master集群模式为例搭建一个双机Master的RocketMQ集群环境（<strong>2m-noslave</strong>集群模式）。</p><h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h1><p>　　因为rocketmq底层是 Java 语言编写，所以搭建此环境的服务器，必须已经安装和配置了 JDK。</p><h2 id="1-1-工具下载"><a href="#1-1-工具下载" class="headerlink" title="　  1.1 工具下载"></a>　  1.1 工具下载</h2><p>　　这里，我提供了本次安装rocketmq所用到的工具包。分别是：<br><img src="http://upload-images.jianshu.io/upload_images/11560519-fc516f3822f919d7" alt=""></p><p>提供了<a href="https://pan.baidu.com/s/1N4QrAgNrdwi3PacqqwxYUg#list/path=%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8C%85%2Frocketmq-software&amp;parentPath=%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8C%85" title="rocketmq安装包" target="_blank" rel="noopener">百度云盘</a>（密码：wdvm）。大家可自行下载。</p><h2 id="1-2-服务器规划"><a href="#1-2-服务器规划" class="headerlink" title="　  1.2 服务器规划"></a>　  1.2 服务器规划</h2><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">IP</th><th style="text-align:center">角色</th><th style="text-align:center">模式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">192.168.81.132</td><td style="text-align:center">nameServer1,brokerServer1</td><td style="text-align:center">Master1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">192.168.81.134</td><td style="text-align:center">nameServer2,brokerServer2</td><td style="text-align:center">Master2</td></tr></tbody></table><h2 id="1-3-基础环境搭建"><a href="#1-3-基础环境搭建" class="headerlink" title="　  1.3 基础环境搭建"></a>　  1.3 基础环境搭建</h2><ol><li>将压缩包上传到2台机器</li></ol><blockquote><p>我这里使用root用户登录,把软件包放在根目录下。</p></blockquote><ol start="2"><li>检查是否安装了JDK,如果没有安装过,则先进行安装和配置JDK(参考 <a href="https://blog.csdn.net/o135248/article/details/79931693" target="_blank" rel="noopener">linux下JDK的安装</a>)<br>3.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#检查JDK是否已安装</span><br><span class="line">[root@localhost ~]# java -version</span><br><span class="line">java version &quot;1.8.0_11&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_11-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.11-b03, mixed mode)</span><br></pre></td></tr></table></figure><h1 id="2-集群搭建"><a href="#2-集群搭建" class="headerlink" title="2.集群搭建　"></a>2.集群搭建　</h1><blockquote><p>说明：安装时，请按照自己的实际服务器环境替换相应的IP即可。</p></blockquote><h2 id="2-1-Hosts-添加信息"><a href="#2-1-Hosts-添加信息" class="headerlink" title="　  2.1 Hosts 添加信息"></a>　  2.1 Hosts 添加信息</h2><p>这里为了方便我们将 nameserver 和 broker 配置到了一台机器上,可以分开进行配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#编辑2台机器的hosts文件</span><br><span class="line">vim  /etc/hosts</span><br><span class="line"></span><br><span class="line">#配置如下的信息:</span><br><span class="line">192.168.81.132 rocketmq-nameserv1</span><br><span class="line">192.168.81.132 rocketmq-master1</span><br><span class="line"></span><br><span class="line">192.168.81.134 rocketmq-nameserv2</span><br><span class="line">192.168.81.134 rocketmq-master2</span><br><span class="line"></span><br><span class="line">#重启网卡</span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure><h2 id="2-2-解压压缩包-2台机器"><a href="#2-2-解压压缩包-2台机器" class="headerlink" title="　  2.2 解压压缩包(2台机器)"></a>　  2.2 解压压缩包(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#解压 alibaba-rocketmq-3.2.6.tar.gz 至 /usr/local</span><br><span class="line">tar -zxvf alibaba-rocketmq-3.2.6.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">#重命名(带上版本号)</span><br><span class="line">mv alibaba-rocketmq alibaba-rocketmq-3.2.6</span><br><span class="line"></span><br><span class="line">#创建软连接</span><br><span class="line">ln -s alibaba-rocketmq-3.2.6 rocketmq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ls看下</span><br><span class="line">rocketmq -&gt; alibaba-rocketmq-3.2.6</span><br></pre></td></tr></table></figure><h2 id="2-3-创建存储路径-2台机器"><a href="#2-3-创建存储路径-2台机器" class="headerlink" title="　  2.3 创建存储路径(2台机器)"></a>　  2.3 创建存储路径(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/rocketmq/store</span><br><span class="line">mkdir /usr/local/rocketmq/store/commitlog</span><br><span class="line">mkdir /usr/local/rocketmq/store/consumequeue</span><br><span class="line">mkdir /usr/local/rocketmq/store/index</span><br><span class="line"></span><br><span class="line">#或者执行下面的一条命令：</span><br><span class="line">mkdir -p /usr/local/rocketmq/store/&#123;commitlog,consumequeue,index&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-RocketMQ配置文件-2台机器"><a href="#2-4-RocketMQ配置文件-2台机器" class="headerlink" title="　  2.4 RocketMQ配置文件(2台机器)"></a>　  2.4 RocketMQ配置文件(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/rocketmq/conf/2m-noslave/broker-a.properties</span><br><span class="line">vim /usr/local/rocketmq/conf/2m-noslave/broker-b.properties</span><br></pre></td></tr></table></figure><p>删除里面的配置，粘贴下面的配置信息。(注意更改brokerName 和 namesrvAddr 的配置)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#所属集群名字</span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line">#broker名字，注意此处不同的配置文件填写的不一样</span><br><span class="line">brokerName=broker-a|broker-b</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId=0</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr=rocketmq-nameserv1:9876;rocketmq-nameserv2:9876</span><br><span class="line"></span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort=10911</span><br><span class="line"></span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen=04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">fileReservedTime=120</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line">#destroyMapedFileIntervalForcibly=120000</span><br><span class="line">#redeleteHangedFileInterval=120000</span><br><span class="line">#检测物理文件磁盘空间</span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"></span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/usr/local/rocketmq/store</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/usr/local/rocketmq/store/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span><br><span class="line">#abort 文件存储路径</span><br><span class="line">abortFile=/usr/local/rocketmq/store/abort</span><br><span class="line"></span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize=65536</span><br><span class="line">#flushCommitLogLeastPages=4</span><br><span class="line">#flushConsumeQueueLeastPages=2</span><br><span class="line">#flushCommitLogThoroughInterval=10000</span><br><span class="line">#flushConsumeQueueThoroughInterval=60000</span><br><span class="line"></span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"></span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">#checkTransactionMessageEnable=false</span><br><span class="line"></span><br><span class="line">#发消息线程池数量</span><br><span class="line">#sendMessageThreadPoolNums=128</span><br><span class="line">#拉消息线程池数量</span><br><span class="line">#pullMessageThreadPoolNums=128</span><br></pre></td></tr></table></figure><h2 id="2-5-修改日志配置文件-2台机器"><a href="#2-5-修改日志配置文件-2台机器" class="headerlink" title="　  2.5 修改日志配置文件(2台机器)"></a>　  2.5 修改日志配置文件(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#创建日志目录logs</span><br><span class="line">mkdir -p /usr/local/rocketmq/logs</span><br><span class="line">#修改日志配置文件</span><br><span class="line">cd /usr/local/rocketmq/conf &amp;&amp; sed -i &apos;s#$&#123;user.home&#125;#/usr/local/rocketmq#g&apos; *.xml</span><br></pre></td></tr></table></figure><h2 id="2-6-修改启动脚本参数-2台机器"><a href="#2-6-修改启动脚本参数-2台机器" class="headerlink" title="　  2.6 修改启动脚本参数(2台机器)"></a>　  2.6 修改启动脚本参数(2台机器)</h2><p>切换到 /usr/local/devTool/rocketmq/bin 目录下，我们发现这里存在 rocketmq的各种命令（win linux）。启动rocketmq，应该先启动nameserver,再启动broker。而broker的启动需要合适的JVM内存配置，阿里官方推荐的是4G。可以根据实际生产环境进行合理配置。</p><p><strong>编辑文件 runbroker.sh</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/rocketmq/bin/runbroker.sh</span><br><span class="line"></span><br><span class="line">#修改 runbroker 的配置 </span><br><span class="line">#===========================================================================================</span><br><span class="line"># JVM Configuration</span><br><span class="line">#===========================================================================================</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:PermSize=128m -XX:MaxPermSize=320m&quot;</span><br></pre></td></tr></table></figure></p><p><strong>编辑文件 runserver.sh</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/rocketmq/bin/runserver.sh</span><br><span class="line"></span><br><span class="line">#修改配置</span><br><span class="line">#===========================================================================================</span><br><span class="line"># JVM Configuration</span><br><span class="line">#===========================================================================================</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:PermSize=128m -XX:MaxPermSize=320m&quot;</span><br></pre></td></tr></table></figure><h2 id="2-7-启动NameServer-2台机器"><a href="#2-7-启动NameServer-2台机器" class="headerlink" title="　  2.7 启动NameServer(2台机器)"></a>　  2.7 启动NameServer(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/rocketmq/bin</span><br><span class="line">#后台启动nameserver</span><br><span class="line">nohup sh mqnamesrv &amp;</span><br><span class="line"></span><br><span class="line">#查看namesrv日志</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><h2 id="2-8-启动BrokerServer-A"><a href="#2-8-启动BrokerServer-A" class="headerlink" title="　  2.8 启动BrokerServer A"></a>　  2.8 启动BrokerServer A</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -c /usr/local/rocketmq/conf/2m-noslave/broker-a.properties &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">#查看进程及日志</span><br><span class="line">jps</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/broker.log</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><h2 id="2-9-启动BrokerServer-B"><a href="#2-9-启动BrokerServer-B" class="headerlink" title="　  2.9 启动BrokerServer B"></a>　  2.9 启动BrokerServer B</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -c /usr/local/rocketmq/conf/2m-noslave/broker-b.properties &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure><h2 id="2-10-安装-RocketMq-Console"><a href="#2-10-安装-RocketMq-Console" class="headerlink" title="　  2.10 安装 RocketMq Console"></a>　  2.10 安装 RocketMq Console</h2><ol><li><p><strong>解压缩 tomcat 到 /usr/local目录下，并且重命名为 rocketmq-console-tomcat.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#解压缩 tomcat 到 /usr/local目录下</span><br><span class="line">tar -zxvf apache-tomcat-8.5.30.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">#重命名为 rocketmq-console-tomcat</span><br><span class="line">cd /usr/local</span><br><span class="line">mv apache-tomcat-8.5.30/ rocketmq-console-tomcat</span><br></pre></td></tr></table></figure></li><li><p><strong>安装 rocketmq-console.war，修改配置并启动</strong></p></li></ol><p>我这里将 rocketmq-console安装在【134】的机器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#将war包放到 刚解压缩的tomcat 的webapps目录下</span><br><span class="line">cp rocketmq-console.war /usr/local/rocketmq-console-tomcat/webapps/</span><br><span class="line"></span><br><span class="line">#解压缩war包</span><br><span class="line">unzip rocketmq-console.war -d rocketmq-console</span><br><span class="line"></span><br><span class="line">#修改配置</span><br><span class="line">vim /usr/local/rocketmq-console-tomcat/webapps/rocketmq-console/WEB-INF/classes/config.properties </span><br><span class="line">修改 rocketmq.namesrv.addr 项的内容为：</span><br><span class="line">rocketmq.namesrv.addr = rocketmq-nameserv1:9876;rocketmq-nameserv2:9876</span><br><span class="line"></span><br><span class="line">#切换到tomcat的bin路径下，启动tomcat,浏览器访问</span><br><span class="line">cd /usr/local/rocketmq-console-tomcat/bin/</span><br><span class="line">./startup.sh</span><br><span class="line"></span><br><span class="line">#启动日志</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq-console-tomcat/logs/catalina.out </span><br><span class="line"></span><br><span class="line">#浏览器访问：（确认防火墙已关闭）</span><br><span class="line">http://192.168.81.134:8080/rocketmq-console</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-f6910b13c30e3f90.png" alt=""></p><h2 id="2-11-数据清理"><a href="#2-11-数据清理" class="headerlink" title="　  2.11 数据清理"></a>　  2.11 数据清理</h2><p>启动时，先启动 nameserver,再启动 broker;</p><p>关闭时，则相反，先关闭 broker,再 关闭 nameserver(早起晚归)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/rocketmq/bin</span><br><span class="line">sh mqshutdown broker</span><br><span class="line">sh mqshutdown namesrv</span><br><span class="line"></span><br><span class="line">##等待停止</span><br><span class="line">rm -rf /usr/local/devTool/rocketmq/store</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store/commitlog</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store/consumequeue</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store/index</span><br></pre></td></tr></table></figure></p><p>到此,2m-noslave集群模式已搭建完毕,下一篇,我们会对 broker的配置文件中的配置项做介绍,这样有利于后期的更自如得学习.</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 集群 </tag>
            
            <tag> 2m-noslave </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列02--集群构建模型</title>
      <link href="/2018/08/26/RocketMQ%E7%B3%BB%E5%88%9702--%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/26/RocketMQ%E7%B3%BB%E5%88%9702--%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>　　本篇主要是对 RocketMQ的集群搭建的几种方式做简单介绍及其优缺点，便于自己在项目中，根据自己的业务需要做技术选型。在上一篇中，我们介绍了RocketMQ的物理部署结构，知道了它是由NameServer、Producer、Consumer和Broker来组成，各自的作用也做了说明。而这篇介绍的集群的搭建，这里的“集群”指的就是 Broker集群的搭建。</p><p>　　Broker 分为 Master 和 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master，Master 和 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerId 来定义，BrokerId为 0 表示 Master，非 0 表示 Slave。Master 也可以部署多个。</p><p>​　　推荐的几种 Broker 集群部署方式，这里的 Slave 不可写，但可读，类似于 Mysql 主备方式。</p><h1 id="1-单-Master"><a href="#1-单-Master" class="headerlink" title="1.单 Master"></a>1.单 Master</h1><blockquote><p>　　即系统所有的消息都存储在一个 Broker上，这种方式风险较大，一旦 Broker 重启或者宕机时，会导致整个服务不可用。这种只适合入门helloworld实例，强烈不建议线上环境使用。</p></blockquote><h1 id="2-多-Master-模式"><a href="#2-多-Master-模式" class="headerlink" title="2.多 Master 模式"></a>2.多 Master 模式</h1><blockquote><p>​    一个集群无Slave，全是Master，例如2个Master或者3个Master。</p></blockquote><p><strong>优点</strong></p><blockquote><p>​　　配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。</p></blockquote><p><strong>缺点</strong></p><blockquote><p>​    单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响。</p></blockquote><p>　　这里介绍下【异步刷盘】、【同步刷盘】、【Broker间数据同步/复制】。</p><p>【异步刷盘】：ASYNC_FLUSH,生产者发送的每一条消息并不是立即保存到磁盘,而是暂时缓存起来,然后就返回生产者成功。然后再异步的将缓存数据保存到磁盘，这里有2种情况：</p><pre><code>1.定期将缓存种更新的数据进行刷盘；2.当缓存中更新的数据条数达到某一设定值进行刷盘。</code></pre><p>这种方式会存在消息丢失（场景：在还未来得及同步到磁盘的时候宕机），但是性能很好，rokectmq默认是这种模式。</p><p>【同步刷盘】：生产者发送的每一条消息都在保存到磁盘成功后才返回告诉生产者成功。这种方式不会存在消息丢失的问题，但是有很大的磁盘IO开销，性能有一定影响。</p><p>【Broker Replication】:Broker间数据同步/复制。集群环境下需要部署多个Broker，Broker分2种角色：Master和Slave。</p><pre><code>1.一种是master,Master即可以读，也可以写，设置brokerId=0,只能设置一个。2.另外一种是slave,只允许读，其brokerId为非0。</code></pre><p>　　一个master与多个slave通过指定相同的brokerName被归为一个 broker set（broker集群）。通常生产环境中，我们至少需要2个broker Set。Broker Replication指的就是slave 获取或者复制master的数据。</p><pre><code>1.sync Broker: 生产者发送的每一条消息都至少同步复制到一个slave后才返回告诉生产者成功，即&quot;同步双写&quot;；2.Async Broker: 生产者发送的每一条消息只要写入master就返回告诉生产者成功，然后再&quot;异步复制&quot;到slave.</code></pre><h1 id="3-多-Master-多-Slave-模式，异步复制"><a href="#3-多-Master-多-Slave-模式，异步复制" class="headerlink" title="3.多 Master 多 Slave 模式，异步复制"></a>3.多 Master 多 Slave 模式，异步复制</h1><blockquote><p>每个Master配置一个或多个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟，毫秒级。</p></blockquote><p><strong>优点</strong></p><blockquote><p>　　即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为Master宕机后，消费者仍然可以从Slave消费，此过程对应用透明。不需要人工干预。性能同多Master模式几乎一样。</p></blockquote><p><strong>缺点</strong></p><blockquote><p>　　Master宕机，磁盘损坏情况，会丢失少量消息。当producer向master发送完数据时，这时候还没等到master向slave做同步，master宕机了，则在master上的数据会丢失，消费者在salve上消费不到刚刚的消息。</p></blockquote><h1 id="4-多-Master-多-Slave-模式，同步双写"><a href="#4-多-Master-多-Slave-模式，同步双写" class="headerlink" title="4.多 Master 多 Slave 模式，同步双写"></a>4.多 Master 多 Slave 模式，同步双写</h1><blockquote><p>每个Master配置一个或多个Slave，有多对Master-Slave，HA采用同步双写方式，主备都写成功，向应用返回成功。</p></blockquote><p><strong>优点</strong></p><blockquote><p>数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高。</p></blockquote><p><strong>缺点</strong></p><blockquote><p> 　　性能比异步复制模式略低，大约低10%左右，发送单个消息的RT会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。</p></blockquote><p>在下篇中，我们会进行 2-master集群环境的搭建和配置。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.《RocketMQ用户指南》</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列01--简介及概念</title>
      <link href="/2018/08/25/RocketMQ%E7%B3%BB%E5%88%9701--%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/08/25/RocketMQ%E7%B3%BB%E5%88%9701--%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h1 id="1-RocketMQ是什么？"><a href="#1-RocketMQ是什么？" class="headerlink" title="1.RocketMQ是什么？"></a>1.RocketMQ是什么？</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB1rdyvPXXXXXcBapXXXXXXXXXX" alt=""></p><p>RocketMQ：</p><ul><li><p>是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式的特点；</p></li><li><p>Producer、Consumer、队列都可以分布式部署；</p></li><li><p>Producer向一些队列轮流发送消息，这些队列集合称为”Topic”。Consumer如果做广播消费，则一个Consumer实例消费这个Topic对应的所有的队列，如果是集群消费，则多个Consumer实例平均消费这个topic队列集合；</p></li><li><p>保证严格的消息顺序；</p></li><li><p>提供丰富的消息拉去模式；</p></li><li><p>高效的订阅者水平扩展能力；</p></li><li><p>实时的消息订阅机制；</p></li><li><p>亿级消息堆积能力。</p><p>RocketMQ是Java语言编写，基于通信框架Netty。</p></li></ul><h1 id="2-RocketMQ物理部署结构"><a href="#2-RocketMQ物理部署结构" class="headerlink" title="2.RocketMQ物理部署结构"></a>2.RocketMQ物理部署结构</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB18GKUPXXXXXXRXFXXXXXXXXXX" alt=""></p><p>从上图中，我们可以看到消息队列的主要角色有：</p><ul><li>NameServer:无状态节点，供 Producer 和 Consumer 获取Broker地址。</li><li>Broker:MQ的服务器，消息的中转角色，负责存储和转发消息。</li><li>Producer:发送消息到消息队列(消息生产者)。</li><li>Consumer:从消息队列接收消息（消息消费者）。</li></ul><p>RocketMQ网络部署特点：</p><ul><li><p>　　NameServer是一个无状态的节点，可集群部署，节点之间无任何信息同步。</p></li><li><p>　　Broker:分为Master和Slave.一个Master可以有多个Slave,但是一个Slave只能对应一个Master.Master和Slave的对应关系是通过指定 “相同的BrokerName,不同的BrokerId”来定义。BrokerId=0表示Master,非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有的NameServer。</p></li><li><p>　　Producer与NamerServer中的任意一个节点建立长连接，定期从NameServer中取Topic的路由信息，并与提供Topic服务的Master建立长连接，定时向Master发送心跳。可集群部署。</p></li><li><p>　　Consumer与NamerServer中的任意一个节点建立长连接，定期从NameServer中取Topic的路由信息，并与提供Topic服务的Master和Slave建立长连接，且定时向Master和Slave发送心跳。Consumer既可以从 Master 订阅消息，也可以从 Slave 订阅消息，订阅规则由 Broker 配置决定。</p></li></ul><h1 id="3-RocketMQ逻辑部署结构"><a href="#3-RocketMQ逻辑部署结构" class="headerlink" title="3.RocketMQ逻辑部署结构"></a>3.RocketMQ逻辑部署结构</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB1lEPePXXXXXX8XXXXXXXXXXXX" alt=""></p><p><strong>Producer Group</strong></p><blockquote><p>​　　用来表示一个収送消息应用，一个 Producer Group 下包含多个 Producer 实例，可以是多台机器，也可以是一台机器的多个迕程，戒者一个迕程的多个 Producer 对象。一个 Producer Group 可以収送多个 Topic消息。作用有：</p><p>​    1.标识一类producer;</p><p>​    2.查询返个収送消息应用下有多个 Producer 实例;</p><p>​    3.収送分布式事务消息时，如果 Producer 中途意外宕机，Broker 会主劢回调 Producer Group 内的任意一台机器来确讣事务状态。</p></blockquote><p><strong>Consumer Group</strong></p><blockquote><p>​　　用来表示一个消费消息应用，一个 Consumer Group 下包含多个 Consumer 实例，可以是多台机器，也可以是多个迕程，戒者是一个迕程的多个 Consumer 对象。一个 Consumer Group 下的多个 Consumer 以均摊方式消费消息，如果设置为广播方式，那举返个 Consumer Group 下的每个实例都消费全量数据。</p></blockquote><ul><li><p>Topic：消息的逻辑管理单位；</p></li><li><p>Message Queue:消息物理管理单位，一个Topic可以有若干个Queue;</p></li><li><p>Message:消息</p><ul><li>body：消息体，用于携带消息的内容。</li><li>key:消息key,用于区分不同的消息，一般是业务id信息，根据key可查询到消息；</li><li>tag:消息tag,用于不同的订阅者来过滤消息。</li></ul><p>​</p></li></ul><h1 id="4-概念术语"><a href="#4-概念术语" class="headerlink" title="4.概念术语"></a><strong>4</strong>.概念术语</h1><ul><li>广播消费</li></ul><blockquote><p>　　 一条消息被多个 Consumer 消费，即使返些 Consumer 属亍同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次，广播消费中的 Consumer Group 概念可以讣为在消息划分方面无意义。</p></blockquote><ul><li>集群消费</li></ul><blockquote><p>​　　一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个Consumer Group 有 3 个实例（可能是 3 个迕程，戒者 3 台机器），那举每个实例只消费其中的 3 条消息。在 CORBA Notification 规范中，无此消费方式。<br>​    在 JMS 规范中，JMS point-to-point model 类似，但是 RocketMQ 的集群消费功能大等于 PTP 模型。<br>​    因为 RocketMQ 单个 Consumer Group 内的消费者类似于 PTP，但是一个 Topic/Queue 可以被多个 Consumer Group 消费。</p></blockquote><ul><li>顺序消息</li></ul><blockquote><p>　　消费消息的顺序要同发送消息的顺序一致，在 RocketMQ 中，主要指的是局部顺序，即一类消息为满足顺序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 发送的顺序去消费消息。</p></blockquote><ul><li>普通顺序消息</li></ul><blockquote><p>​    顺序消息的一种，正常情况下可以保证完全的顺序消息，但是一旦发生通信异常，Broker 重启，由于队列总数发生发化，哈希取模后定位的队列会发化，产生短暂的消息顺序不一致。<br>如果业务能容忍在集群异常情况（如某个 Broker 宕机或者重启）下，消息短暂的乱序，使用普通顺序方式比较合适。</p></blockquote><ul><li>严格的顺序消息</li></ul><blockquote><p>​　　顺序消息的一种，无论正常异常情况都能保证顺序，但是牺牲了分布式 Failover 特性，即 Broker 集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。</p></blockquote><blockquote><p>　　如果服务器部署为同步双写模式，此缺陷可通过备机自动切换为主避免，不过仍然会存在几分钟的服务不可用。（依赖同步双写，主备自动切换，自动切换功能目前还未实现）<br>目前已知的应用只有数据库 binlog 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息。</p></blockquote><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h1><p>1.RocketMQ 开发指南（V3.2.4）</p><p>2.<a href="https://blog.csdn.net/gwd1154978352/article/details/80654314" target="_blank" rel="noopener">RocketMQ——初识RocketMQ</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>读书</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>大家好，我是”李乔子的酒”。欢迎来到我的个人技术博客。</p><p>我是一个Java入门2年的”小猿”,今后会在本博客写下自己的工作和生活日常.</p><p>让我们一起,变得更加优秀!</p><h4 id="历史纪录"><a href="#历史纪录" class="headerlink" title="历史纪录"></a>历史纪录</h4><table><thead><tr><th>日期</th><th>优化记录</th><th>完成日期</th><th>责任人</th></tr></thead><tbody><tr><td>2018-08-19</td><td>整理读书资源,对读书页面中的书籍增加 “百度云盘”下载</td><td></td><td>lemon</td></tr><tr><td>2018-08-19</td><td>新增 “Tools”工具页面,提供日常及开发常用工具一站式下载</td><td></td><td>lemon</td></tr><tr><td>2018-08-19</td><td>申请 “七牛云”存储,提供文件存储功能</td><td></td><td>lemon</td></tr></tbody></table>]]></content>
    </entry>
    
    <entry>
      <title>resources</title>
      <link href="/resources/index.html"/>
      <url>/resources/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
