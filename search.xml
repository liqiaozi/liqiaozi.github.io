<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>RocketMQ系列18--双主双从集群搭建及使用</title>
      <link href="/2018/09/10/RocketMQ%E7%B3%BB%E5%88%9718--%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/09/10/RocketMQ%E7%B3%BB%E5%88%9718--%E5%8F%8C%E4%B8%BB%E5%8F%8C%E4%BB%8E%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 双主双从 </tag>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列09--通信机制</title>
      <link href="/2018/09/10/RocketMQ%E7%B3%BB%E5%88%9709--%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/09/10/RocketMQ%E7%B3%BB%E5%88%9709--%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> RPC </tag>
            
            <tag> 通信 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列07--消息存储</title>
      <link href="/2018/09/09/RocketMQ%E7%B3%BB%E5%88%9707--%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/"/>
      <url>/2018/09/09/RocketMQ%E7%B3%BB%E5%88%9707--%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/</url>
      <content type="html"><![CDATA[<h1 id="0-RocketMQ消息存储"><a href="#0-RocketMQ消息存储" class="headerlink" title="0. RocketMQ消息存储"></a>0. RocketMQ消息存储</h1><p>rocketmq的broker消息存储主要包括3个部分,分别是:</p><p>commitLog的存储,<br>consumerQueue的存储,<br>index的存储.</p><h1 id="1-Consumer-Queue"><a href="#1-Consumer-Queue" class="headerlink" title="1. Consumer Queue"></a>1. Consumer Queue</h1><p>consumer queue是消息的逻辑队列,相当于字典的目录,用来指定消息在物理文件commit log上的位置。</p><p>我们可以在配置中指定 consumerqueue 与 commitlog存储的目录。</p><p>每个topic下的每个queue都有一个对应的 consumerqueue文件。</p><pre><code>${rocketmq.home}/store/consumequeue/${topicName}/${queueId}/${fileName}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/11560519-e9d1580352721a01.png" alt=""></p><p><strong>Consume Queue文件组织示意图</strong></p><blockquote><p>1.根据topic和queueId来组织文件，图中TopicA有两个队列0,1，那么TopicA和QueueId=0组成一个ConsumeQueue，TopicA和QueueId=1组成另一个ConsumeQueue。</p><p>2.按照消费端的GroupName来分组重试队列，如果消费端消费失败，消息将被发往重试队列中，比如图中的%RETRY%ConsumerGroupA。</p><p>3.按照消费端的GroupName来分组死信队列，如果消费端消费失败，并重试指定次数后，仍然失败，则发往死信队列，比如图中的%DLQ%ConsumerGroupA。</p></blockquote><p>Consume Queue中存储单元是一个20字节定长的二进制数据，顺序写顺序读，如下图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/175724-7212acc81b91c086.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>CommitLog Offset是指这条消息在CommitLog中的实际偏移量；</li><li>Size 存储消息的大小</li><li>Message Tag Hashcode 存储消息的Tag哈希值：主要用于订阅时消息过滤（订阅时如果指定了Tag，会根据HashCode来快速查找到订阅的消息。）</li></ul><h1 id="2-CommitLog"><a href="#2-CommitLog" class="headerlink" title="2. CommitLog"></a>2. CommitLog</h1><p>消息存放的物理文件，每台broker上的commitlog被本机所有的queue共享，不做任何区分。<br>文件的默认位置如下，可以通过配置文件配置修改：</p><pre><code>${user.home} \store\${commitlog}\${fileName}</code></pre><p>CommitLog的消息存储单元长度不固定，文件顺序写，随机读。消息的存储结构如下表所示，按照编号顺序以及编号对应的内容依次存储。<br><img src="http://upload-images.jianshu.io/upload_images/175724-96ed677eb504abfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="3-消息的索引文件index"><a href="#3-消息的索引文件index" class="headerlink" title="3.消息的索引文件index"></a>3.消息的索引文件index</h1><p>如果一个消息包含key值的话，会使用IndexFile存储消息索引，文件内容结构如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/175724-4deee0fb9d08e02d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/175724-4deee0fb9d08e02d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>索引文件主要用于根据key来查询消息的，流程主要是：</p><p>1.根据查询的key的 (hash值 % slotNum) 得到具体的槽的位置（slotNum）是一个索引文件里面包含的最大槽的数目。</p><p>2.根据 slotValue(slot 位置对应的值)查找到索引项列表的最后一项(倒序排列,slotValue 总是指向最新的一个索引项)</p><p>3.遍历索引项列表返回查询时间范围内的结果集(默认一次最大返回的 32 条记录) .</p><h1 id="4-源码解读"><a href="#4-源码解读" class="headerlink" title="4.源码解读"></a>4.源码解读</h1><p>入口类：SendMessageProcessor.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public RemotingCommand processRequest(ChannelHandlerContext ctx,</span><br><span class="line">                                      RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line">    SendMessageContext mqtraceContext;</span><br><span class="line">    switch (request.getCode()) &#123;</span><br><span class="line">        case RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">            return this.consumerSendMsgBack(ctx, request);</span><br><span class="line">        default:</span><br><span class="line">            SendMessageRequestHeader requestHeader = parseRequestHeader(request);</span><br><span class="line">            if (requestHeader == null) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class="line">            this.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line"></span><br><span class="line">            RemotingCommand response;</span><br><span class="line">            if (requestHeader.isBatch()) &#123;</span><br><span class="line">                response = this.sendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                response = this.sendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            this.executeSendMessageHookAfter(response, mqtraceContext);</span><br><span class="line">            return response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6302559-124bde9f2799a151.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 消息存储 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列16--Consumer重试策略</title>
      <link href="/2018/09/09/RocketMQ%E7%B3%BB%E5%88%9716--Consumer%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5/"/>
      <url>/2018/09/09/RocketMQ%E7%B3%BB%E5%88%9716--Consumer%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<h1 id="1-消息去重简介"><a href="#1-消息去重简介" class="headerlink" title="1.消息去重简介"></a>1.消息去重简介</h1><p>RocketMQ提供了消息重试机制,这时一些其他消息队列没有的功能.我们可以依靠这个优秀的机制,而不用在开发种增加更多的业务代码去实现。</p><p>Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p><ul><li>1.由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如充话费，当前手机号被注销，无法充值）等；</li></ul><p>这种错误通常需要跳过这条消息，再消费其他消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试策略，即过10s后在重试。</p><ul><li>2.由于依赖的下游应用服务不可用，例如db链接不可用，外网不可达等。</li></ul><p>遇到这种错误，即使跳过当前的失败的消息，消费其他消息同样也会报错，这种情况建议应用sleep 30s,再消费吓一跳消息，这样可以减轻Broker重试消息的压力。</p><h1 id="2-消息重试分类"><a href="#2-消息重试分类" class="headerlink" title="2.消息重试分类"></a>2.消息重试分类</h1><p>对于MQ，可能存在各种异常和情况，导致消息无法最终被consumer消费，因此就有了消息失败重试机制。很显然，消息重试分为2种：Producer端重试和Consumer端重试。</p><h2 id="2-1-producer端"><a href="#2-1-producer端" class="headerlink" title="2.1 producer端"></a>2.1 producer端</h2><p>生产端的消息失败，也就是Producer往MQ上发消息没有发送成功，比如网络抖动导致生产者发送消息到MQ失败。这种消息失败重试我们可以手动设置发送失败重试次数，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//发送失败重试次数</span><br><span class="line">producer.setRetryTimesWhenSendFailed(3);</span><br><span class="line">...</span><br><span class="line">// 3s内没有发送成功,即重试发送.</span><br><span class="line">   SendResult sendResult = producer.send(msg,3000);</span><br></pre></td></tr></table></figure></p><p>send（）方法内部重试逻辑：</p><ol><li>至多重试设置的重试的次数，默认为3次；</li><li>如果发送失败，则轮转到下一个broker;</li><li>这个方法的总耗时事件不超过sendMsgTimeout设置的值，默认为10s。</li></ol><p>所以，如果本身向broker发送消息产生超时异常，就不会再做重试。</p><p>以上策略仍然不能保证消息一定发送成功，为保证消息一定成功，建议这样做：<br>如果调用send同步方法发送消息失败，则尝试将消息存储到db中，有后台线程定时重试，保证消息一定到达broker.</p><h2 id="2-2-consumer端"><a href="#2-2-consumer端" class="headerlink" title="2.2 consumer端"></a>2.2 consumer端</h2><p>消费端消费失败的情况分为2种：exception 和 timeout。</p><h3 id="exception"><a href="#exception" class="headerlink" title="exception"></a>exception</h3><p>消息正常到达了消费端，结果消费者发生了异常，处理失败了。（发序列化失败，消息本身无法处理等）。</p><p>我们可以带着问题去找答案：</p><blockquote><p>消费者消费消息的状态有哪些？<br>如果消费失败，mq采用什么策略进行重试？<br>假设10条试拒中，某一条消息消费失败，是消息重试这10条消息呢？还是只是重试失败的某一条？<br>再重试的过程中，需要保证不重复消费吗？</p></blockquote><p>消息消费的状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum ConsumeConcurrentlyStatus &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 消费成功.</span><br><span class="line">     */</span><br><span class="line">    CONSUME_SUCCESS,</span><br><span class="line">    /**</span><br><span class="line">     * 消费失败,稍后重试消费.</span><br><span class="line">     */</span><br><span class="line">    RECONSUME_LATER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看broker的启动日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-08-28 22:14:12 INFO main - messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br><span class="line">2018-08-28 22:14:12 INFO main - flushDelayOffsetInterval=10000</span><br><span class="line">2018-08-28 22:14:12 INFO main - cleanFileForciblyEnable=true</span><br><span class="line">2018-08-28 22:14:28 INFO main - user specfied name server address: rocketmq-nameserv1:9876;rocketmq-nameserv2:9876</span><br></pre></td></tr></table></figure><p>可以看到消息失败重试的策略：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2018-08-28 22:14:12 INFO main - messageDelayLevel=1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br></pre></td></tr></table></figure></p><p>直到2个小时候消费还是失败，那么这条消息就会终止发送给消费者了。再实际中，我们并不会允许这么多次消费的，这样做很浪费资源，我们会把这条消息存储到db中，手动消费。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    if (msgs.get(0).getReconsumeTimes() == 3) &#123;</span><br><span class="line">        // 该条消息可以存储到DB或者LOG日志中，或其他处理方式</span><br><span class="line">        return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;// 成功</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return ConsumeConcurrentlyStatus.RECONSUME_LATER;// 重试</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>由于网络原因导致消息压根就没从MQ到消费者上，那么RocketMQ内部会不断的尝试发送这条消息，直至发送成功为止.(集群中的一个broker失败，就尝试另外一个broker)。延续exception的思路，也就是消费者端没有返回消息的消费状态，无论是消费成功还是稍后重试。这样producer端就认为消息还是没有到达消费者端。</p><p>场景模拟：<br>(1) 同在一个消费者组的2个消费者：consumer1和consumer2;<br>(2) consumer1的业务代码中暂停1分钟，并且不发送状态给MQ。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line">@Override</span><br><span class="line">public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">    try &#123;                   </span><br><span class="line">            String topic = msg.getTopic();</span><br><span class="line">            String msgBody = new String(msg.getBody(),&quot;utf-8&quot;);</span><br><span class="line">            String tags = msg.getTags();</span><br><span class="line">            System.out.println(&quot;收到消息：&quot; + &quot; topic：&quot; + topic + &quot; ,tags：&quot; + tags + &quot; ,msg：&quot; + msgBody);</span><br><span class="line"></span><br><span class="line">            // 表示业务处理时间</span><br><span class="line">            System.out.println(&quot;=========开始暂停==========&quot;);</span><br><span class="line">            Thread.sleep(60000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return ConsumeConcurrentlyStatus.RECONSUME_LATER;// 重试</span><br><span class="line">    &#125;</span><br><span class="line">    return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>(3)先启动consumer1，再启动producer,发送一条消息。<br>(4)发现consumer1接收到了消息，但是因为consumer阻塞，没有返回消息消费的状态；<br>(5)紧接着，启动consumer2，发现consumer接收到了消息，并且消费了消息返回了消费状态。</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 重试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列19--FilterServer机制及消息过滤</title>
      <link href="/2018/09/09/RocketMQ%E7%B3%BB%E5%88%9719--FilterServer%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4/"/>
      <url>/2018/09/09/RocketMQ%E7%B3%BB%E5%88%9719--FilterServer%E6%9C%BA%E5%88%B6%E5%8F%8A%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>RocketMQ的消息过滤方式有别于其他的消息中间件,是在过滤时,再做过滤,我们在前面介绍了Consume Queue存储结构。</p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-85286e339278a139.png" alt=""></p><p>(1)在Broker端进行Message Tag对比，先遍历Consume Queue,如果存储的Message Tag与订阅的MessageTag不符合，则跳过，继续比对下一个，符合的话则传送给我Consumer.(Message Tag是字符串形式，Consume Queue中存储的是其对应的hashcode，比对时也是比对hashcode)</p><p>(2)Consumer收到过滤后的消息后，同样也要执行在Broker端的操作，但是比对的是真是的Message Tag字符串，而不是HashCode.</p><p><strong>为什么过滤要这样做？</strong></p><p>(1). Message Tag 存储 Hashcode，是为了在Consume Queue定长方式存储，节约空间。</p><p>(2). 过滤过程中不会访问 Commit Log 数据，可以保证堆积情况下也能高效过滤。</p><p>(3). 即使存在 Hash 冲突，也可以在 Consumer 端进行修正，保证万无一失。</p><h1 id="1-简单消息过滤"><a href="#1-简单消息过滤" class="headerlink" title="1.简单消息过滤"></a>1.简单消息过滤</h1><p>在Cnsumer端指定订阅的Tag。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//订阅挃定topic下tags分别等亍TagA戒TagC戒TagD</span><br><span class="line"></span><br><span class="line">consumer.subscribe(&quot;TopicTest1&quot;, &quot;TagA || TagC || TagD&quot;);</span><br></pre></td></tr></table></figure><p>简单消息过滤通过指定多个 Tag 来过滤消息，过滤动作在服务器端进行。</p><h1 id="2-高级消息过滤"><a href="#2-高级消息过滤" class="headerlink" title="2.高级消息过滤"></a>2.高级消息过滤</h1><p><img src="https://upload-images.jianshu.io/upload_images/11560519-bb6a4357d185afb0.png" alt=""></p><p>RocketMQ 执行过滤是在Broker端，Broker所在的机器会启动多个FilterServer过滤进程；Consumer启动后，会向FilterServer上传一个过滤的Java类；Consumer从FilterServer拉消息，FilterServer将请求转发给Broker,FilterServer从Broker收到消息后，按照Consumer上传的Java过滤程序做过滤，过滤完后返回给Consumer.这种过滤方法可以节省网络流量，但是增加了Broker的负担。</p><p>1.Broker 所在的机器会启动多个 FilterServer 过滤进程；</p><p>2.Consumer 启动后，会向 FilterServer 上传一个过滤的 Java 类；</p><p>3.Consumer 从 FilterServer拉消息，FilterServer将请求转给Broker，FilterServer 从 Broker 收到消息后，按照Consumer上传的Java过滤程序做过滤，过滤完成后返回给 Consumer。</p><h1 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h1><p>如果我们要使用RocketMQ的Filter组件，则必须启动 mqfiletersrv。<br>组件启动顺序：namesrv broker mqfiltersrv.</p><p>mqfiletersrv启动命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqfiltersrv -c broker.properties</span><br></pre></td></tr></table></figure></p><p>在 broker.properties配置文件添加配置:<br>数量根据自己机器的情况，自行设定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterServerNums=1</span><br></pre></td></tr></table></figure></p><p>代码层：需要实现 MessageFilter接口，进行重写match()方法，可以针对我们自己想要过滤的消息进行细粒度的处理；</p><p>最后，把我们自己实现的Filter类（类中不允许有中文！！！），通过消费端的订阅方式，加入到我们的消费端即可。</p><h1 id="4-producer端"><a href="#4-producer端" class="headerlink" title="4.producer端"></a>4.producer端</h1><p>我们可以在 producer的代码中加入 自定义的过滤的标志：</p><p>部分代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 发送消息.</span><br><span class="line">       for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">           try &#123;</span><br><span class="line"></span><br><span class="line">               Message msg = new Message(&quot;DingDing_Topic&quot;, // topic</span><br><span class="line">                       &quot;sign_up&quot;,                           // tags</span><br><span class="line">                       (&quot;员工&quot; + i + &quot;签到&quot;).getBytes());        // body</span><br><span class="line"></span><br><span class="line">               msg.putUserProperty(&quot;SequenceId&quot;, String.valueOf(i));//设置过了参数</span><br><span class="line">               </span><br><span class="line">               // 3s内没有发送成功,即重试发送.</span><br><span class="line">               SendResult sendResult = producer.send(msg,3000);</span><br><span class="line">               log.info(&quot;发送结果:&quot; + sendResult);</span><br><span class="line">           &#125;</span><br><span class="line">           catch (Exception e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               Thread.sleep(1000);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>msg.putUserProperty(“SequenceId”, String.valueOf(i))中的key和Filter文件中的要key要一致。</strong></p></blockquote><h1 id="5-自定义过滤器MyMessageFilter"><a href="#5-自定义过滤器MyMessageFilter" class="headerlink" title="5.自定义过滤器MyMessageFilter"></a>5.自定义过滤器MyMessageFilter</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @ClassName: MyMessageFilter</span><br><span class="line"> * @Description: 自定义消息过滤器</span><br><span class="line"> * @Author: 李雪飞</span><br><span class="line"> * @Date: 2018/9/10 12:00</span><br><span class="line"> * @Vserion 1.0</span><br><span class="line"> **/</span><br><span class="line">public class MyMessageFilter implements MessageFilter &#123;</span><br><span class="line"></span><br><span class="line">    // no Chinese anyway</span><br><span class="line">    @Override</span><br><span class="line">    public boolean match(MessageExt msg) &#123;</span><br><span class="line">        String property = msg.getUserProperty(&quot;SequenceId&quot;);</span><br><span class="line">        if (property != null) &#123;</span><br><span class="line">            int id = Integer.parseInt(property);</span><br><span class="line">            if((id % 2) == 0) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内容上不得有任何中文，包括注释，否则MixAll.file2String方法返回null.<br>msg.putUserProperty(“SequenceId”, String.valueOf(i))中的key和Filter文件中的要key要一致</p><h1 id="6-consumer端"><a href="#6-consumer端" class="headerlink" title="6.consumer端"></a>6.consumer端</h1><p>consumer代码片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> InputStream insss =new Consumer().getClass().getResourceAsStream(&quot;/application.properties&quot;);</span><br><span class="line">        Properties pss = new Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            pss.load(insss);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            // TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        String devPath=(String)pss.get(&quot;dev.path&quot;);</span><br><span class="line"></span><br><span class="line">//String filterCode = MixAll.file2String(&quot;H:\\idea_workspace\\ssm_project\\src\\main\\java\\com\\xflig\\rocketmq\\helloworld\\MyMessageFilter.java&quot;);</span><br><span class="line">        String filterCode = MixAll.file2String(devPath+&quot;MyMessageFilter.java&quot;);</span><br></pre></td></tr></table></figure></p><h1 id="7-推荐"><a href="#7-推荐" class="headerlink" title="7.推荐"></a>7.推荐</h1><p>【1】<a href="https://blog.csdn.net/prestigeding/article/details/79255328" target="_blank" rel="noopener">源码分析RocketMQ消息过滤机制上篇—–消息消费服务端过滤与TAG模式过滤实现</a><br>【2】</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 消息过滤 </tag>
            
            <tag> filter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列17--Consumer幂等去重</title>
      <link href="/2018/09/09/RocketMQ%E7%B3%BB%E5%88%9717--Consumer%E5%B9%82%E7%AD%89%E5%8E%BB%E9%87%8D/"/>
      <url>/2018/09/09/RocketMQ%E7%B3%BB%E5%88%9717--Consumer%E5%B9%82%E7%AD%89%E5%8E%BB%E9%87%8D/</url>
      <content type="html"><![CDATA[<h1 id="1-幂等性"><a href="#1-幂等性" class="headerlink" title="1. 幂等性"></a>1. 幂等性</h1><h2 id="1-1-什么是幂等性"><a href="#1-1-什么是幂等性" class="headerlink" title="1.1 什么是幂等性"></a>1.1 什么是幂等性</h2><blockquote><p> 它是一种数学上的概念，使f(x)=f(f(x))能够成立的数学性质。用再编程领域，则意为对同一个系统，使用同一样的条件，一次请求和重复的多次请求对系统资源的影响是一致的。</p></blockquote><blockquote><p>幂等性是分布式系统设计中十分重要的概念，具有这一性质的接口再设计时总是坚持这样的一种理念:调用接口发生异常并且重复尝试时，总是会造成系统无法承受的损失。所以必须阻止这种现象的发生。</p></blockquote><blockquote><p>幂等有2个维度：一是空间维度上的幂等，即幂等对象的范围，是个人还是机构，是某一次交易还是某种类型的交易…二是时间维度上的幂等，即幂等的保证时间，是几秒、几分钟还是永久性的…</p></blockquote><h2 id="1-2-幂等适用领域"><a href="#1-2-幂等适用领域" class="headerlink" title="1.2 幂等适用领域"></a>1.2 幂等适用领域</h2><p>试想这样的一种场景：在电商平台上支付后，因为网络原因导致系统提示你支付失败，于是你又重新付款了一次，等完成后检查网银发现被系统扣了两次款，这是一种什么样的体验？</p><p>造成上述问题的原因可能有很多，比如第一次付款时实际支付成功，但是信息返回时网络中断导致系统误判；又比如第一次付款的确失败了，但第二次付款时发生意外，导致支付请求被重复发送等等。在一次支付的过程中，每个环节都有可能会发生问题，我们要如何规避这类问题引发的分险？</p><p>幂等性是解决这类问题的方案之一，所以在电商，银行，互联网金融等对数据准确性要求很高的领域中，这一特性具有十分重要的地位。</p><h2 id="1-3-幂等的思路"><a href="#1-3-幂等的思路" class="headerlink" title="1.3 幂等的思路"></a>1.3 幂等的思路</h2><p><strong>1. MVCC</strong><br>多版本并发控制，乐观锁的一种实现，再数据更新时需要去比较持有数据的版本号，版本号不一致的操作无法成功，例如博客的点在次数自动+1d的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boolean addCount(Long id,Long version);</span><br><span class="line"></span><br><span class="line">update blogTable set count = count + 1,version = version + 1 where id = 123 and version = 123;</span><br></pre></td></tr></table></figure><p>每一个version只有一次执行成功的机会，一旦失败必须重新获取。</p><p><strong>2. 去重表</strong></p><p>利用数据库表单的特性来实现幂等性，常用思路:在表上构建唯一性索引，保证某一类数据一旦执行完毕，后续同样的请求再也无法成功写入。</p><p><strong>3. Token机制</strong></p><p>核心思想：为每一次操作生成一个唯一的凭证，也就是token。一个token在操作的每一个阶段只有一次执行权，一旦执行成功则保存执行结果。对重复的请求，返回同一个结果。</p><p>以电商平台为例子，电商平台上的订单id就是最适合的token。当用户下单时，会经历多个环节，比如生成订单，减库存，减优惠券等等。</p><p>每一个环节执行时都先检测一下该订单id是否已经执行过这一步骤，对未执行的请求，执行操作并缓存结果，而对已经执行过的id，则直接返回之前的执行结果，不做任何操作。这样可以在最大程度上避免操作的重复执行问题，缓存起来的执行结果也能用于事务的控制等。</p><h1 id="2-消息重复及去重"><a href="#2-消息重复及去重" class="headerlink" title="2. 消息重复及去重"></a>2. 消息重复及去重</h1><p>RocketMQ是怎样解决消息重复的问题呢？还是“恰好”不解决。</p><p>造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p><ul><li>消费端处理消息的业务逻辑保持幂等性</li><li>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</li></ul><p>第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。</p><p>第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。</p><p>第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。</p><p>第2条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。</p><p>RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。</p><p>还有一种 <strong>高并发下去重</strong></p><blockquote><p>采用Redis去重（key天然支持原子性并要求不可重复），但是由于不在一个事务，要求有适当的补偿策略</p></blockquote><blockquote><p>利用redis事务，主键（我们必须把全量的操作数据都存放在redis里，然后定时去和数据库做数据同步）—-即消费处理后，该处理本来应该保存在数据库的，先保存在redis，利用redis和关系型数据库一起做去重机制</p></blockquote><blockquote><p>拿到这个消息做redis的set的操作.redis就是天然幂等性。<br>准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将 &lt; id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</p></blockquote><h1 id="3-推荐"><a href="#3-推荐" class="headerlink" title="3. 推荐"></a>3. 推荐</h1><p>【1】<a href="https://blog.csdn.net/yzhou86/article/details/79156458" target="_blank" rel="noopener">幂等性，RocketMQ解决消息顺序和重复，Mysql与Java中的乐观锁悲观锁</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 幂等性 </tag>
            
            <tag> 去重 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列08--Namersrv</title>
      <link href="/2018/09/09/RocketMQ%E7%B3%BB%E5%88%9708--NameServer/"/>
      <url>/2018/09/09/RocketMQ%E7%B3%BB%E5%88%9708--NameServer/</url>
      <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h1><p>主要管理所有的broker信息,让producer和consumer都能获取到正确的broker信息,进行业务处理.类似于zookeeper的服务治理中心.简而言之,主要包含下面几方面的功能:</p><ol><li>Broker启动的时候会向NameSrv发送注册请求，Namesrv接收broker的请求注册路由信息和保存活跃的broker列表，包括master和slave;</li><li>用来保存所有的topic和该topic所有队列的列表；</li><li>Namesrv用来保存所有broker的Filter列表；</li><li>接收producer和consumer的请求，根据某个topic获取到broker的路由信息。</li></ol><h1 id="2-namesrv启动和初始化"><a href="#2-namesrv启动和初始化" class="headerlink" title="2.namesrv启动和初始化"></a>2.namesrv启动和初始化</h1><p>namesrv启动的时候主要涉及 NamesrvStartup/NamesrvController 两个类。NamesrvStartup 负责解析命令行的一些参数到各种 Config 对象中（NamesrvConfig/NettyServerConfig等），如果命令行参数中带有配置文件的路径，也会从配置文件中读取配置到各种 Config 对象中，然后初始化 NamesrvController，配置shutdownHook, 启动 NamesrvController。</p><p>NamesrvController 会去初始化和启动各个组件，主要是:</p><ul><li>创建NettyServer，注册 requestProcessor，用于处理不同的网络请求</li><li>启动 NettyServer</li><li>启动各种 scheduled task.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static NamesrvController main0(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 加载命令行配置信息.初始化NamesrvController配置信息.</span><br><span class="line">            NamesrvController controller = createNamesrvController(args);</span><br><span class="line">            start(controller);</span><br><span class="line">            String tip = &quot;The Name Server boot success. serializeType=&quot; + RemotingCommand.getSerializeTypeConfigInThisServer();</span><br><span class="line">            log.info(tip);</span><br><span class="line">            System.out.printf(&quot;%s%n&quot;, tip);</span><br><span class="line">            return controller;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.exit(-1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public static NamesrvController start(final NamesrvController controller) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">       if (null == controller) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;NamesrvController is null&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       // 初始化 配置信息</span><br><span class="line">       boolean initResult = controller.initialize();</span><br><span class="line">       if (!initResult) &#123;</span><br><span class="line">           controller.shutdown();</span><br><span class="line">           System.exit(-3);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       Runtime.getRuntime().addShutdownHook(new ShutdownHookThread(log, new Callable&lt;Void&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Void call() throws Exception &#123;</span><br><span class="line">               controller.shutdown();</span><br><span class="line">               return null;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;));</span><br><span class="line"></span><br><span class="line">       controller.start();</span><br><span class="line"></span><br><span class="line">       return controller;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public boolean initialize() &#123;</span><br><span class="line">        // 加载NameServer的配置参数，将配置参数加载保存到一个HashMap中</span><br><span class="line">        this.kvConfigManager.load();</span><br><span class="line">        // 初始化 BrokerHousekeepingService 对象为参数初始化</span><br><span class="line">        this.remotingServer = new NettyRemotingServer(this.nettyServerConfig, this.brokerHousekeepingService);</span><br><span class="line"></span><br><span class="line">        this.remotingExecutor =</span><br><span class="line">            Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), new ThreadFactoryImpl(&quot;RemotingExecutorThread_&quot;));</span><br><span class="line"></span><br><span class="line">        // 注册默认的处理类 DefaultRequestProcessor,所有的请求均由该处理类的 processRequest 方法来处理</span><br><span class="line">        this.registerProcessor();</span><br><span class="line"></span><br><span class="line">        // 设置两个定时任务</span><br><span class="line">        // 每隔十秒钟遍历brokerLiveTable集合，查看每个broker的最后更新时间是否超过了两分钟，</span><br><span class="line">        // 超过则关闭broker的渠道并清理 RouteInfoManager 类的topicQueueTable、 brokerAddrTable、 clusterAddrTable、 filterServerTable成员变量</span><br><span class="line">        this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                NamesrvController.this.routeInfoManager.scanNotActiveBroker();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 5, 10, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        // 每隔 10 分钟打印一次 NameServer 的配置参数。即KVConfigManager.configTable 变量的内容</span><br><span class="line">        this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                NamesrvController.this.kvConfigManager.printAllPeriodically();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 1, 10, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">        // 启动 NameServer 的 Netty 服务端（ NettyRemotingServer），监听渠道的请求信息。</span><br><span class="line">        // 当收到客户端的请求信息之后会初始化一个线程，并放入线程池中进行处理,该线程调用 DefaultRequestProcessor. processRequest 方法来处理请求</span><br><span class="line">        if (TlsSystemConfig.tlsMode != TlsMode.DISABLED) &#123;</span><br><span class="line">            // Register a listener to reload SslContext</span><br><span class="line">            try &#123;</span><br><span class="line">                fileWatchService = new FileWatchService(</span><br><span class="line">                    new String[] &#123;</span><br><span class="line">                        TlsSystemConfig.tlsServerCertPath,</span><br><span class="line">                        TlsSystemConfig.tlsServerKeyPath,</span><br><span class="line">                        TlsSystemConfig.tlsServerTrustCertPath</span><br><span class="line">                    &#125;,</span><br><span class="line">                    new FileWatchService.Listener() &#123;</span><br><span class="line">                        boolean certChanged, keyChanged = false;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void onChanged(String path) &#123;</span><br><span class="line">                            if (path.equals(TlsSystemConfig.tlsServerTrustCertPath)) &#123;</span><br><span class="line">                                log.info(&quot;The trust certificate changed, reload the ssl context&quot;);</span><br><span class="line">                                reloadServerSslContext();</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (path.equals(TlsSystemConfig.tlsServerCertPath)) &#123;</span><br><span class="line">                                certChanged = true;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (path.equals(TlsSystemConfig.tlsServerKeyPath)) &#123;</span><br><span class="line">                                keyChanged = true;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (certChanged &amp;&amp; keyChanged) &#123;</span><br><span class="line">                                log.info(&quot;The certificate and private key changed, reload the ssl context&quot;);</span><br><span class="line">                                certChanged = keyChanged = false;</span><br><span class="line">                                reloadServerSslContext();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        private void reloadServerSslContext() &#123;</span><br><span class="line">                            ((NettyRemotingServer) remotingServer).loadSslContext();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                log.warn(&quot;FileWatchService created error, can&apos;t load the certificate dynamically&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="3-处理broker的注册请求"><a href="#3-处理broker的注册请求" class="headerlink" title="3.处理broker的注册请求"></a>3.处理broker的注册请求</h1><p>DefaultRequestProcessor.processRequest处理请求, 如果 request.getCode 是 RequestCode.REGISTER_BROKER, 就去注册。这里会根据request.version来判断，从V3_0_11 开始支持了FilterServer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">case RequestCode.REGISTER_BROKER:</span><br><span class="line">Version brokerVersion = MQVersion.value2Version(request.getVersion());</span><br><span class="line">if (brokerVersion.ordinal() &gt;= MQVersion.Version.V3_0_11.ordinal()) &#123;</span><br><span class="line">    return this.registerBrokerWithFilterServer(ctx, request);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return this.registerBroker(ctx, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public RegisterBrokerResult registerBroker(</span><br><span class="line">      final String clusterName,</span><br><span class="line">      final String brokerAddr,</span><br><span class="line">      final String brokerName,</span><br><span class="line">      final long brokerId,</span><br><span class="line">      final String haServerAddr,</span><br><span class="line">      final TopicConfigSerializeWrapper topicConfigWrapper,</span><br><span class="line">      final List&lt;String&gt; filterServerList,</span><br><span class="line">      final Channel channel) &#123;</span><br><span class="line">      RegisterBrokerResult result = new RegisterBrokerResult();</span><br><span class="line">      try &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              this.lock.writeLock().lockInterruptibly();</span><br><span class="line"></span><br><span class="line">              /**</span><br><span class="line">               * 维护 RouteInfoManager.clusterAddrTable 变量； 若 Broker 集群名字不</span><br><span class="line">               在该 Map 变量中，则初始化一个 Set 集合，将 brokerName 存入该 Set 集合中，</span><br><span class="line">               然后以 clusterName 为 key 值，该 Set 集合为 values 值存入此 Map 变量中</span><br><span class="line">               */</span><br><span class="line">              Set&lt;String&gt; brokerNames = this.clusterAddrTable.get(clusterName);</span><br><span class="line">              if (null == brokerNames) &#123;</span><br><span class="line">                  brokerNames = new HashSet&lt;String&gt;();</span><br><span class="line">                  this.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">              &#125;</span><br><span class="line">              brokerNames.add(brokerName);</span><br><span class="line"></span><br><span class="line">              boolean registerFirst = false;</span><br><span class="line"></span><br><span class="line">              /**</span><br><span class="line">               * 维护 RouteInfoManager.brokerAddrTable 变量，该变量是维护 Broker</span><br><span class="line">               的名称、 ID、地址等信息的。 若该 brokername 不在该 Map 变量中，则创建</span><br><span class="line">               BrokerData 对象，该对象包含了 brokername，以及 brokerId 和 brokerAddr 为</span><br><span class="line">               K-V 的 brokerAddrs 变量；然后以 brokername 为 key 值将 BrokerData 对象存入</span><br><span class="line">               该 brokerAddrTable 变量中； 说明同一个 BrokerName 下面可以有多个不同</span><br><span class="line">               BrokerId 的 Broker 存在，表示一个 BrokerName 有多个 Broker 存在，通过</span><br><span class="line">               BrokerId 来区分主备</span><br><span class="line">               */</span><br><span class="line">              BrokerData brokerData = this.brokerAddrTable.get(brokerName);</span><br><span class="line">              if (null == brokerData) &#123;</span><br><span class="line">                  registerFirst = true;</span><br><span class="line">                  brokerData = new BrokerData(clusterName, brokerName, new HashMap&lt;Long, String&gt;());</span><br><span class="line">                  this.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">              &#125;</span><br><span class="line">              String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">              registerFirst = registerFirst || (null == oldAddr);</span><br><span class="line"></span><br><span class="line">              // 若 Broker 的注册请求消息中 topic 的配置不为空，并且该 Broker 是主用（即 brokerId=0）</span><br><span class="line">              if (null != topicConfigWrapper</span><br><span class="line">                  &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">                  //则根据 NameServer 存储的 Broker 版本信息来判断是否需要更新 NameServer 端的 topic 配置信息</span><br><span class="line">                  if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())</span><br><span class="line">                      || registerFirst) &#123;</span><br><span class="line">                      ConcurrentMap&lt;String, TopicConfig&gt; tcTable =</span><br><span class="line">                          topicConfigWrapper.getTopicConfigTable();</span><br><span class="line">                      if (tcTable != null) &#123;</span><br><span class="line">                          for (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                              this.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              //初始化 BrokerLiveInfo 对象并以 broker 地址为 key 值存入</span><br><span class="line">              // brokerLiveTable:HashMap&lt;String/* brokerAddr */, BrokerLiveInfo&gt;变量中</span><br><span class="line">              BrokerLiveInfo prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddr,</span><br><span class="line">                  new BrokerLiveInfo(</span><br><span class="line">                      System.currentTimeMillis(),</span><br><span class="line">                      topicConfigWrapper.getDataVersion(),</span><br><span class="line">                      channel,</span><br><span class="line">                      haServerAddr));</span><br><span class="line">              if (null == prevBrokerLiveInfo) &#123;</span><br><span class="line">                  log.info(&quot;new broker registered, &#123;&#125; HAServer: &#123;&#125;&quot;, brokerAddr, haServerAddr);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              //对于 filterServerList 不为空的， 以 broker 地址为 key 值存入</span><br><span class="line">              if (filterServerList != null) &#123;</span><br><span class="line">                  if (filterServerList.isEmpty()) &#123;</span><br><span class="line">                      this.filterServerTable.remove(brokerAddr);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      this.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              // 找到该 BrokerName 下面的主用 Broker（ BrokerId=0）</span><br><span class="line">              if (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">                  String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line">                  if (masterAddr != null) &#123;</span><br><span class="line">                      ////主用 Broker 地址从brokerLiveTable 中获取 BrokerLiveInfo 对象，取该对象的 HaServerAddr 值</span><br><span class="line">                      BrokerLiveInfo brokerLiveInfo = this.brokerLiveTable.get(masterAddr);</span><br><span class="line">                      if (brokerLiveInfo != null) &#123;</span><br><span class="line">                          result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">                          result.setMasterAddr(masterAddr);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              this.lock.writeLock().unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          log.error(&quot;registerBroker Exception&quot;, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="4-根据Topic获取Broker信息和Topic配置信息"><a href="#4-根据Topic获取Broker信息和Topic配置信息" class="headerlink" title="4.根据Topic获取Broker信息和Topic配置信息"></a>4.根据Topic获取Broker信息和Topic配置信息</h1><p>接收到GET_ROUTEINTO_BY_TOPIC请求之后，间接调用了 RouteInfoManager.pickupTopicRouteData 方法来获取Broker和topic信息。</p><p>1、获取 topic 配置信息，根据 topic 从 RouteInfoManager.topicQueueTable变量中获取 List队列， 赋值给返回对象 TopicRouteData 的QueueDatas 变量。 表示该 topic 对应的所有 topic 配置信息以及每个配置所属的 BrokerName。 </p><p>2、 从上一步获取到的 List队列中获取 BrokerName 集合，该集合是去重之后的 BrokerName 集合，然后以该 BrokerName 集合的每个 BrokerName从 RouteInfoManager.brokerAddrTable 变量中获取 BrokerData 对象，将所有获取到的 BrokerData 对象集合赋值给返回对象 TopicRouteData 的 BrokerDatas集合变量。表示该 topic 是由哪些 Broker 提供的服务，以及每个 Broker 的名字、BrokerId、 IP 地址。 </p><p>3、然后以“ ORDER_TOPIC_CONFIG”和请求消息中的 topic 值为参数从NamesrvController.kvConfigManager.configTable: HashMap变量中获取orderTopiconf 值（即 broker 的顺序），并赋值给TopicRouteData.orderTopicConf 变量；该 orderTopiconf 的参数格式为：以“ ;”解析成数组，数组的每个成员是以“ :”分隔的，构成数据 “ brokerName:queueNum”；最后将 TopicRouteData 对象返回给调用者.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public TopicRouteData pickupTopicRouteData(final String topic) &#123;</span><br><span class="line">       TopicRouteData topicRouteData = new TopicRouteData();</span><br><span class="line">       boolean foundQueueData = false;</span><br><span class="line">       boolean foundBrokerData = false;</span><br><span class="line">       Set&lt;String&gt; brokerNameSet = new HashSet&lt;String&gt;();</span><br><span class="line">       List&lt;BrokerData&gt; brokerDataList = new LinkedList&lt;BrokerData&gt;();</span><br><span class="line">       topicRouteData.setBrokerDatas(brokerDataList);</span><br><span class="line"></span><br><span class="line">       HashMap&lt;String, List&lt;String&gt;&gt; filterServerMap = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">       topicRouteData.setFilterServerTable(filterServerMap);</span><br><span class="line"></span><br><span class="line">       try &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               this.lock.readLock().lockInterruptibly();</span><br><span class="line">               // 获取 topic 配置信息,表示该 topic 对应的所有 topic 配置信息以及每个配置所属的 BrokerName</span><br><span class="line">               List&lt;QueueData&gt; queueDataList = this.topicQueueTable.get(topic);</span><br><span class="line">               if (queueDataList != null) &#123;</span><br><span class="line">                   topicRouteData.setQueueDatas(queueDataList);</span><br><span class="line">                   foundQueueData = true;</span><br><span class="line"></span><br><span class="line">                   //从上一步获取到的 List队列中获取 BrokerName 集合，该集合是去重之后的 BrokerName 集合</span><br><span class="line">                   Iterator&lt;QueueData&gt; it = queueDataList.iterator();</span><br><span class="line">                   while (it.hasNext()) &#123;</span><br><span class="line">                       QueueData qd = it.next();</span><br><span class="line">                       brokerNameSet.add(qd.getBrokerName());</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   //然后以该 BrokerName 集合的每个 BrokerName从 RouteInfoManager.brokerAddrTable</span><br><span class="line">                   //变量中获取 BrokerData 对象，将所有获取到的 BrokerData 对象集合赋值给返回对象 TopicRouteData 的 BrokerDatas集合变量</span><br><span class="line">                   for (String brokerName : brokerNameSet) &#123;</span><br><span class="line">                       BrokerData brokerData = this.brokerAddrTable.get(brokerName);</span><br><span class="line">                       if (null != brokerData) &#123;</span><br><span class="line">                           BrokerData brokerDataClone = new BrokerData(brokerData.getCluster(), brokerData.getBrokerName(), (HashMap&lt;Long, String&gt;) brokerData</span><br><span class="line">                               .getBrokerAddrs().clone());</span><br><span class="line">                           brokerDataList.add(brokerDataClone);</span><br><span class="line">                           foundBrokerData = true;</span><br><span class="line">                           //然后以“ ORDER_TOPIC_CONFIG”和请求消息中的 topic 值为参数从NamesrvController.kvConfigManager.configTable: HashMap变量中获取orderTopiconf 值（即 broker 的顺序），</span><br><span class="line">                           // 并赋值给TopicRouteData.orderTopicConf 变量；该 orderTopiconf 的参数格式为：以“ ;”解析成数组，数组的每个成员是以“ :”分隔的，</span><br><span class="line">                           // 构成数据 “ brokerName:queueNum”；最后将 TopicRouteData 对象返回给调用者</span><br><span class="line">                           for (final String brokerAddr : brokerDataClone.getBrokerAddrs().values()) &#123;</span><br><span class="line">                               List&lt;String&gt; filterServerList = this.filterServerTable.get(brokerAddr);</span><br><span class="line">                               filterServerMap.put(brokerAddr, filterServerList);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               this.lock.readLock().unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           log.error(&quot;pickupTopicRouteData Exception&quot;, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       log.debug(&quot;pickupTopicRouteData &#123;&#125; &#123;&#125;&quot;, topic, topicRouteData);</span><br><span class="line"></span><br><span class="line">       if (foundBrokerData &amp;&amp; foundQueueData) &#123;</span><br><span class="line">           return topicRouteData;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="5-推荐"><a href="#5-推荐" class="headerlink" title="5.推荐"></a>5.推荐</h1><p>【1】<a href="https://blog.csdn.net/KilluaZoldyck/article/details/76828263" target="_blank" rel="noopener">RocketMQ源码深度解析二之Name Server篇</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> namesrv </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列15--消息模式</title>
      <link href="/2018/09/08/RocketMQ%E7%B3%BB%E5%88%9715--%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/09/08/RocketMQ%E7%B3%BB%E5%88%9715--%E6%B6%88%E6%81%AF%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="0-介绍"><a href="#0-介绍" class="headerlink" title="0.介绍"></a>0.介绍</h1><p>在RocketMQ中,它没有遵循JMS的规范,而是有一套自定义的机制,简单来说,都是使用订阅主题的方式取发送和接受消息的,但是支持2种消息模式:集群和广播.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息模式</span><br><span class="line"> */</span><br><span class="line">public enum MessageModel &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 广播模式</span><br><span class="line">     */</span><br><span class="line">    BROADCASTING(&quot;BROADCASTING&quot;),</span><br><span class="line">    /**</span><br><span class="line">     * 集群模式</span><br><span class="line">     */</span><br><span class="line">    CLUSTERING(&quot;CLUSTERING&quot;);</span><br><span class="line"></span><br><span class="line">    private String modeCN;</span><br><span class="line"></span><br><span class="line">    MessageModel(String modeCN) &#123;</span><br><span class="line">        this.modeCN = modeCN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getModeCN() &#123;</span><br><span class="line">        return modeCN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>集群模式: 设置 消费端对象属性(messageModel)为:MessageModel.CLUSTERING,这种方式可以达到类似于ActiveMQ水平扩展负载均衡消费消息的实现,比较特殊的是,这种方式可以支持先发送数据(也就是producer端先发送数据到MQ),消费端订阅主题发生在生产端之后,也可以接收数据。</p></blockquote><h1 id="1-集群模式"><a href="#1-集群模式" class="headerlink" title="1.集群模式"></a>1.集群模式</h1><p>对于RocketMQ而言，无论是producer还是consumer端，都维护者一个groupname的属性，我们在之前也介绍过，通过ConsumerGroup的机制，消费端实现了天然的负载均衡。也就是说，MQ会将消息平均分发到该消费者组的每个consumer上，这样就要意味着我们可以很方便通过加机器的方式来实现水平扩展！</p><p>默认情况下，RocketMQ设置为集群消息模式。至于消息的分发策略，是可以设置策略的：<br>消息分发策略接口：AllocateMessageQueueStrategy。<br>默认有以下几种分发策略，要使用哪种策略，只需要示例话对应的对象即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AllocateMachineRoomNearby()</span><br><span class="line">AllocateMessageQueueAveragely()</span><br><span class="line">AllocateMessageQueueAveragelyByCircle()</span><br><span class="line">AllocateMessageQueueByConfig()</span><br><span class="line">AllocateMessageQueueByMachineRoom()</span><br><span class="line">AllocateMessageQueueConsistentHash()</span><br></pre></td></tr></table></figure></p><h1 id="2-广播模式"><a href="#2-广播模式" class="headerlink" title="2.广播模式"></a>2.广播模式</h1><p> 广播消息：设置消费端对象属性为：MessageModel.BROADCASTING,这种模式就是相当于生产端发送数据到MQ，多个消费端都可以获取到数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consumer.setMessageModel(MessageModel.BROADCASTING);</span><br></pre></td></tr></table></figure><p>这样，假设producer发送了10条消息，则订阅了该topic的2个消费者，都会接收到这10条消息进行消费。而使用集群模式，会可能会出现consumer1消费序号1-6的消息，而consumer2消费序号7-10的消息。</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 消息模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列14--Consumer消费端-Pull</title>
      <link href="/2018/09/07/RocketMQ%E7%B3%BB%E5%88%9714--Consumer%E6%B6%88%E8%B4%B9%E7%AB%AF-Pull/"/>
      <url>/2018/09/07/RocketMQ%E7%B3%BB%E5%88%9714--Consumer%E6%B6%88%E8%B4%B9%E7%AB%AF-Pull/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>push和pull模式在上一篇已经说过了。push是broker主动去向consumer推送消息，他们之间维持者一个长连接，从而实现broker向消费者推送消息。而本节则讨论拉模式 DefaultPullConsumer的实现。</p><p>RocketMQ拉模式，消费者不自动向消息服务器拉取消息，而是将控制权移交给应用程序，RocketMQ消费者只是提供拉取消息API。</p><h1 id="1-pull消费端代码"><a href="#1-pull消费端代码" class="headerlink" title="1.pull消费端代码"></a>1.pull消费端代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class PullConsumer &#123;</span><br><span class="line">    private static final Map&lt;MessageQueue, Long&gt; OFFSE_TABLE = new HashMap&lt;MessageQueue, Long&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws MQClientException &#123;</span><br><span class="line">        DefaultMQPullConsumer consumer = new DefaultMQPullConsumer(&quot;please_rename_unique_group_name_5&quot;);</span><br><span class="line">        consumer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        Set&lt;MessageQueue&gt; mqs = consumer.fetchSubscribeMessageQueues(&quot;TopicTest1&quot;);</span><br><span class="line"></span><br><span class="line">        for (MessageQueue mq : mqs) &#123;</span><br><span class="line">            System.out.printf(&quot;Consume from the queue: %s%n&quot;, mq);</span><br><span class="line">            SINGLE_MQ:</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    PullResult pullResult =</span><br><span class="line">                        consumer.pullBlockIfNotFound(mq, null, getMessageQueueOffset(mq), 32);</span><br><span class="line">                    System.out.printf(&quot;%s%n&quot;, pullResult);</span><br><span class="line">                    //在本地创建offseTable:Map&lt;MessageQueue, Long&gt;变量，根据上一步返回的结果，</span><br><span class="line">//将该MessageQueue的下一次消费开始位置记录下来</span><br><span class="line">                    putMessageQueueOffset(mq, pullResult.getNextBeginOffset());</span><br><span class="line">                    switch (pullResult.getPullStatus()) &#123;</span><br><span class="line">                        case FOUND:</span><br><span class="line">                            break;</span><br><span class="line">                        case NO_MATCHED_MSG:</span><br><span class="line">                            break;</span><br><span class="line">                        case NO_NEW_MSG:</span><br><span class="line">                            break SINGLE_MQ;</span><br><span class="line">                        case OFFSET_ILLEGAL:</span><br><span class="line">                            break;</span><br><span class="line">                        default:</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        consumer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static long getMessageQueueOffset(MessageQueue mq) &#123;</span><br><span class="line">        Long offset = OFFSE_TABLE.get(mq);</span><br><span class="line">        if (offset != null)</span><br><span class="line">            return offset;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void putMessageQueueOffset(MessageQueue mq, long offset) &#123;</span><br><span class="line">        OFFSE_TABLE.put(mq, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-DefaultMQPullConsumer的启动"><a href="#2-DefaultMQPullConsumer的启动" class="headerlink" title="2.DefaultMQPullConsumer的启动"></a>2.DefaultMQPullConsumer的启动</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() throws MQClientException &#123;</span><br><span class="line">        switch (this.serviceState) &#123;</span><br><span class="line">            case CREATE_JUST:</span><br><span class="line">                this.serviceState = ServiceState.START_FAILED;</span><br><span class="line">                // 检查配置信息</span><br><span class="line">                this.checkConfig();</span><br><span class="line">                // 复制订阅信息</span><br><span class="line">                this.copySubscription();</span><br><span class="line"></span><br><span class="line">                if (this.defaultMQPullConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                    this.defaultMQPullConsumer.changeInstanceNameToPID();</span><br><span class="line">                &#125;</span><br><span class="line">                // 创建 MQClientInstance 对象.</span><br><span class="line">                this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQPullConsumer, this.rpcHook);</span><br><span class="line"></span><br><span class="line">                // 设置消费端负载均衡配置.</span><br><span class="line">                this.rebalanceImpl.setConsumerGroup(this.defaultMQPullConsumer.getConsumerGroup());</span><br><span class="line">                this.rebalanceImpl.setMessageModel(this.defaultMQPullConsumer.getMessageModel());</span><br><span class="line">                this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPullConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">                this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);</span><br><span class="line"></span><br><span class="line">// 构造PullAPIWrapper</span><br><span class="line">                this.pullAPIWrapper = new PullAPIWrapper(</span><br><span class="line">                    mQClientFactory,</span><br><span class="line">                    this.defaultMQPullConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">                this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br><span class="line"></span><br><span class="line">                // 获取 offsetStore</span><br><span class="line">                if (this.defaultMQPullConsumer.getOffsetStore() != null) &#123;</span><br><span class="line">                    this.offsetStore = this.defaultMQPullConsumer.getOffsetStore();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    switch (this.defaultMQPullConsumer.getMessageModel()) &#123;</span><br><span class="line">                        case BROADCASTING:</span><br><span class="line">                            this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPullConsumer.getConsumerGroup());</span><br><span class="line">                            break;</span><br><span class="line">                        case CLUSTERING:</span><br><span class="line">                            this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPullConsumer.getConsumerGroup());</span><br><span class="line">                            break;</span><br><span class="line">                        default:</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.defaultMQPullConsumer.setOffsetStore(this.offsetStore);</span><br><span class="line">                &#125;</span><br><span class="line">                // 加载 offsetStore 进度条.</span><br><span class="line">                this.offsetStore.load();</span><br><span class="line"></span><br><span class="line">                // 注册该消费者.</span><br><span class="line">                boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPullConsumer.getConsumerGroup(), this);</span><br><span class="line">                if (!registerOK) &#123;</span><br><span class="line">                    this.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line"></span><br><span class="line">                    throw new MQClientException(&quot;The consumer group[&quot; + this.defaultMQPullConsumer.getConsumerGroup()</span><br><span class="line">                        + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                        null);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mQClientFactory.start();</span><br><span class="line">                log.info(&quot;the consumer [&#123;&#125;] start OK&quot;, this.defaultMQPullConsumer.getConsumerGroup());</span><br><span class="line">                this.serviceState = ServiceState.RUNNING;</span><br><span class="line">                break;</span><br><span class="line">            case RUNNING:</span><br><span class="line">            case START_FAILED:</span><br><span class="line">            case SHUTDOWN_ALREADY:</span><br><span class="line">                throw new MQClientException(&quot;The PullConsumer service state not OK, maybe started once, &quot;</span><br><span class="line">                    + this.serviceState</span><br><span class="line">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                    null);</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一开始的serverState的状态自然为CREAT_JUST，调用checkConfig()，其中先是对ConsumerGroup进行验证，非空，合法(符合正则规则，且长度不超过配置最大值)，且不为默认值(防止消费者集群名冲突)，然后对消费者消息模式、消息队列分配算法进行非空、合法校验。</p><p>调用copySubscription()方法，将配置在DefaultMQPullConsumer中的topic信息构造成subscriptionData数据结构，以topic为key以subscriptionData为value以键值对形式存到rebalanceImpl的subscriptionInner中。</p><p>接下来从MQCLientManager中得到MQClient的实例</p><p>再往后是对rebalanceImpl的配置，我们重点看下rebalanceImpl，它是在DefaultMQPullConsumerImpl成员中直接构造private RebalanceImpl rebalanceImpl = new RebalancePullImpl(this);即在DefaultMQPullConsumerImpl初始化的时候构造。接下来对其消费者组名、消息模式(默认集群)、队列分配算法(默认平均分配)、消费者客户端实例进行配置，配置信息都是从DefaultMQPullConsumer中取得。</p><p>初始化消费者的offsetStore，offset即偏移量，可以理解为消费进度，这里根据不同的消息模式来选择不同的策略。如果是广播模式，那么所有消费者都应该收到订阅的消息，那么每个消费者只应该自己消费的消费队列的进度，那么需要把消费进度即offsetStore存于本地采用LocalFileOffsetStroe，相反的如果是集群模式，那么集群中的消费者来平均消费消息队列，那么应该把消费进度存于远程采用RemoteBrokerOffsetStore。</p><p>调用相应的load方法加载。</p><p>将当前消费者注册在MQ客户端实例上之后，调用MQClientInstance的start()方法，启动消费者客户端</p><h1 id="3-根据topic获取对应的MessageQueue（即可被订阅的队列）"><a href="#3-根据topic获取对应的MessageQueue（即可被订阅的队列）" class="headerlink" title="3.根据topic获取对应的MessageQueue（即可被订阅的队列）"></a>3.根据topic获取对应的MessageQueue（即可被订阅的队列）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public Set&lt;MessageQueue&gt; fetchSubscribeMessageQueues(String topic) throws MQClientException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 1. 从 namesrv 获取该topic对应的broker信息和topic配置信息.</span><br><span class="line">            TopicRouteData topicRouteData = this.mQClientFactory.getMQClientAPIImpl().getTopicRouteInfoFromNameServer(topic, timeoutMillis);</span><br><span class="line"></span><br><span class="line">            // 2. 遍历 TopicRouteData 对象中的 QueueData 列表中的每个QueueMessage的值.</span><br><span class="line">            //    2.1 判断该 QueueData 对象是否有读权限,有权限的话则创建 MessageQueue对象,并构成MessageQueue集合,并返回.</span><br><span class="line">            // 反走,抛出异常.</span><br><span class="line">            if (topicRouteData != null) &#123;</span><br><span class="line">                Set&lt;MessageQueue&gt; mqList = MQClientInstance.topicRouteData2TopicSubscribeInfo(topic, topicRouteData);</span><br><span class="line">                if (!mqList.isEmpty()) &#123;</span><br><span class="line">                    return mqList;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new MQClientException(&quot;Can not find Message Queue for this topic, &quot; + topic + &quot; Namesrv return empty&quot;, null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new MQClientException(</span><br><span class="line">                &quot;Can not find Message Queue for this topic, &quot; + topic + FAQUrl.suggestTodo(FAQUrl.MQLIST_NOT_EXIST),</span><br><span class="line">                e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        throw new MQClientException(&quot;Unknow why, Can not find Message Queue for this topic, &quot; + topic, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="4-DefaultMQPullConsumer-pullBlockIfNotFound-…"><a href="#4-DefaultMQPullConsumer-pullBlockIfNotFound-…" class="headerlink" title="4.DefaultMQPullConsumer.pullBlockIfNotFound(…)"></a>4.DefaultMQPullConsumer.pullBlockIfNotFound(…)</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public PullResult pullBlockIfNotFound(MessageQueue mq, String subExpression, long offset, int maxNums)</span><br></pre></td></tr></table></figure><blockquote><p>mq:要消费的队列；<br>subExpression：消费过滤规则<br>offset：该messageQueue对象的开始消费位置<br>maxNums：32，表示获取的最大消息个数。</p></blockquote><p>该方法最终调用DefaultMQPullConsumerImpl.pullSyncImpl(MessageQueue mq, String subExpression, long offset, int maxNums, boolean block)方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">private PullResult pullSyncImpl(MessageQueue mq, String subExpression, long offset, int maxNums, boolean block,</span><br><span class="line">    long timeout)</span><br><span class="line">    throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    // 0.确保该消费者处于运行状态.</span><br><span class="line">    this.makeSureStateOK();</span><br><span class="line">    if (null == mq) &#123;</span><br><span class="line">        throw new MQClientException(&quot;mq is null&quot;, null);</span><br><span class="line">    &#125;</span><br><span class="line">    if (offset &lt; 0) &#123;</span><br><span class="line">        throw new MQClientException(&quot;offset &lt; 0&quot;, null);</span><br><span class="line">    &#125;</span><br><span class="line">    if (maxNums &lt;= 0) &#123;</span><br><span class="line">        throw new MQClientException(&quot;maxNums &lt;= 0&quot;, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 1.topic是否在RebalanceImpl.subscriptionInner:ConcurrentHashMap&lt;String,SubscriptionData&gt;变量中;</span><br><span class="line">    // 不存在话,构造SubscriptionData对象保存到RebalanceImpl.subscriptionInner变量中</span><br><span class="line">    this.subscriptionAutomatically(mq.getTopic());</span><br><span class="line"></span><br><span class="line">    // 2.构建消息的标志位sysFlag，其中suspend和subscription为true（即该标记位的第2/3位为1），其他commit和classFilter两位为false（第1/4位为0）</span><br><span class="line">    int sysFlag = PullSysFlag.buildSysFlag(false, block, true, false);</span><br><span class="line"></span><br><span class="line">    // 3.构造SubscriptionData对象并返回</span><br><span class="line">    SubscriptionData subscriptionData;</span><br><span class="line">    try &#123;</span><br><span class="line">        subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPullConsumer.getConsumerGroup(),</span><br><span class="line">            mq.getTopic(), subExpression);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new MQClientException(&quot;parse subscription error&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long timeoutMillis = block ? this.defaultMQPullConsumer.getConsumerTimeoutMillisWhenSuspend() : timeout;</span><br><span class="line"></span><br><span class="line">    // 4.从Broker拉取消息内容.</span><br><span class="line">    PullResult pullResult = this.pullAPIWrapper.pullKernelImpl(</span><br><span class="line">        mq,</span><br><span class="line">        subscriptionData.getSubString(),</span><br><span class="line">        0L,</span><br><span class="line">        offset,</span><br><span class="line">        maxNums,</span><br><span class="line">        sysFlag,</span><br><span class="line">        0,</span><br><span class="line">        this.defaultMQPullConsumer.getBrokerSuspendMaxTimeMillis(),</span><br><span class="line">        timeoutMillis,</span><br><span class="line">        CommunicationMode.SYNC,</span><br><span class="line">        null</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    // 5.对拉取消息的响应结果进行处理，主要是消息反序列化</span><br><span class="line">    this.pullAPIWrapper.processPullResult(mq, pullResult, subscriptionData);</span><br><span class="line">    if (!this.consumeMessageHookList.isEmpty()) &#123;</span><br><span class="line">        ConsumeMessageContext consumeMessageContext = null;</span><br><span class="line">        consumeMessageContext = new ConsumeMessageContext();</span><br><span class="line">        consumeMessageContext.setConsumerGroup(this.groupName());</span><br><span class="line">        consumeMessageContext.setMq(mq);</span><br><span class="line">        consumeMessageContext.setMsgList(pullResult.getMsgFoundList());</span><br><span class="line">        consumeMessageContext.setSuccess(false);</span><br><span class="line">        this.executeHookBefore(consumeMessageContext);</span><br><span class="line">        consumeMessageContext.setStatus(ConsumeConcurrentlyStatus.CONSUME_SUCCESS.toString());</span><br><span class="line">        consumeMessageContext.setSuccess(true);</span><br><span class="line">        this.executeHookAfter(consumeMessageContext);</span><br><span class="line">    &#125;</span><br><span class="line">    return pullResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-获取消费进度-fetchConsumeOffset（…）"><a href="#5-获取消费进度-fetchConsumeOffset（…）" class="headerlink" title="5.获取消费进度 fetchConsumeOffset（…）"></a>5.获取消费进度 fetchConsumeOffset（…）</h1><p>调用DefaultMQPullConsumer.fetchConsumeOffset(MessageQueue mq, boolean fromStore)方法获取MessageQueue队列的消费进度，其中fromStore为true表示从存储端（即Broker端）获取消费进度；若fromStore为false表示从本地内存获取消费进度；</p><p>1、对于从存储端获取消费进度（即fromStore=true）的情况：</p><p>1.1)对于LocalFileOffsetStore对象，从本地加载offsets.json文件，然后获取该MessageQueue对象的offset值；</p><p>1.2)对于RemoteBrokerOffsetStore对象,获取逻辑如下：</p><p>A）以MessageQueue对象的brokername从MQClientInstance. brokerAddrTable中获取Broker的地址；若没有获取到则立即调用updateTopicRouteInfoFromNameServer方法然后再次获取；</p><p>B）构造QueryConsumerOffsetRequestHeader对象，其中包括topic、consumerGroup、queueId；然后调用MQClientAPIImpl.queryConsumerOffset (String addr, QueryConsumerOffsetRequestHeader requestHeader, long timeoutMillis)方法向Broker发送QUERY_CONSUMER_OFFSET请求码，获取消费进度Offset；</p><p>C）用上一步从Broker获取的offset更新本地内存的消费进度列表数据RemoteBrokerOffsetStore.offsetTable:ConcurrentHashMap&lt;MessageQueue, AtomicLong&gt;变量值；</p><p>D）返回该offset值；</p><p>2、对于从本地内存获取消费进度（即fromStore=false）的情况：</p><p>对于LocalFileOffsetStore或者RemoteBrokerOffsetStore对象，均是以MessageQueue对象作为key值从各自对象的offsetTable变量中获取相应的消费进度。</p><h1 id="6-推荐"><a href="#6-推荐" class="headerlink" title="6.推荐"></a>6.推荐</h1><p>【1】 <a href="https://blog.csdn.net/meilong_whpu/article/details/77081676" target="_blank" rel="noopener">RocketMQ——Consumer篇：PULL模式下的消息消费（DefaultMQPullConsumer）</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> Producer </tag>
            
            <tag> Consumer </tag>
            
            <tag> Pull </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列13--Consumer消费端-Push</title>
      <link href="/2018/09/03/RocketMQ%E7%B3%BB%E5%88%9713--Consumer%E6%B6%88%E8%B4%B9%E7%AB%AF-Push/"/>
      <url>/2018/09/03/RocketMQ%E7%B3%BB%E5%88%9713--Consumer%E6%B6%88%E8%B4%B9%E7%AB%AF-Push/</url>
      <content type="html"><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0.概述"></a>0.概述</h1><p>任何消息中间件,消费者端一般有2种方式从消息中间件获取消息并消费:</p><p><strong>Push方式:</strong>由消息中间件(MQ消息服务器代理)主动将消息推送给消费者。采用Push方式，可以尽可能的实时将消息发送给消费者进行消费。但是，当你的消费者消费消息的能力比较弱的时候，但是MQ仍然会不断的向消费者push最新的消息，消费者端的缓冲区可能会溢出，导致异常。</p><p>Pull方式: 由消费者客户端主动向消息中间件（MQ消息服务器代理）拉取消息，采用pull方式，需要关注的时消费者端去拉取的频率。如果每次pull的时间间隔比较久，会增加消息的延迟，即消息到达消费者的时间加长，MQ的消息的会堆积。若每次的pull时间间隔短，有可能在MQ中这段时间内正好没有消息可以消费，那么会产生很多无效的RPC开销，影响整个MQ整体的网络性能。</p><h1 id="1-RocketMQ消息订阅及长轮询机制"><a href="#1-RocketMQ消息订阅及长轮询机制" class="headerlink" title="1.RocketMQ消息订阅及长轮询机制"></a>1.RocketMQ消息订阅及长轮询机制</h1><p>同样，RocketMQ消息订阅有两种模式，一种是Push模式，即MQServer主动向消费端推送；另外一种是Pull模式，即消费端在需要时，主动到MQServer拉取。通过研究源码可知，RocketMQ的消费方式都是基于拉模式拉取消息的。<br>那么在RocketMQ中如何解决以做到高效的消息消费呢？</p><p>答案就是在rocketmq中有一种长轮询机制（对普通轮询的一种优化），来平衡上面push/pull模型的各自缺点。基本设计思路：</p><p>消费者端如果第一次尝试pull消息失败（比如：broker端没有消息可以被消费），这时并不立即给消费者端返回response的响应，而是先hold住并挂起该请求（将该请求保存至pullRequestTable本地缓存变量中），然后broker端的后台独立线程（PullRequestHoldService）会从pullRequestTable本地缓存变量中不断去取信息（查询待拉取消息的偏移量是否小于消费队列的最大偏移量，如果条件成立则说明有新消息到达broker端）。同时,另外一个ReputMessageService线程不断的构建ConsumerQueue/IndexFile数据，并取出hold住的pull请求进行二次处理。如果有新消息到达broker端，则通过重新调用一次业务处理器-pullmessageProcessor的处理请求方法-processRequest来重新尝试拉取消息。</p><h1 id="2-demo代码"><a href="#2-demo代码" class="headerlink" title="2.demo代码"></a>2.demo代码</h1><p>push模式下的消费者端代码.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, MQClientException &#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;DingDing&quot;);</span><br><span class="line">        //设置 nameserver地址.</span><br><span class="line">        consumer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">        /**</span><br><span class="line">         * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span><br><span class="line">         * 如果非第一次启动，那么按照上次消费的位置继续消费</span><br><span class="line">         */</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(&quot;DingDing_Topic&quot;, &quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        consumer.setConsumeMessageBatchMaxSize(10);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            // 接收消息.</span><br><span class="line">            @Override</span><br><span class="line">            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">                for(MessageExt msg : msgs)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        String topic = msg.getTopic();</span><br><span class="line">                        String tags = msg.getTags();</span><br><span class="line">                        String msgBody =  new String(msg.getBody(),&quot;utf-8&quot;);</span><br><span class="line">                        System.out.println(&quot;收到消息--&quot; + &quot; topic:&quot; + topic + &quot; ,tags:&quot; + tags + &quot; ,msg:&quot; +msgBody);</span><br><span class="line">                    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line"></span><br><span class="line">                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Consumer Started.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当使用 push模式的消费者时,只需要在消费者端注册一个监听器(new MessageListenerConcurrently),Consumer在收到消息后主动调用这个监听器完成消费并进行自己业务逻辑处理.</p><h1 id="3-Push方式的启动流程分析"><a href="#3-Push方式的启动流程分析" class="headerlink" title="3.Push方式的启动流程分析"></a>3.Push方式的启动流程分析</h1><p><img src="https://upload-images.jianshu.io/upload_images/11560519-67bc66230732b52f.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void start() throws MQClientException &#123;</span><br><span class="line">        switch (this.serviceState) &#123;</span><br><span class="line">            case CREATE_JUST:</span><br><span class="line">                log.info(&quot;the consumer [&#123;&#125;] start beginning. messageModel=&#123;&#125;, isUnitMode=&#123;&#125;&quot;, this.defaultMQPushConsumer.getConsumerGroup(),</span><br><span class="line">                    this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());</span><br><span class="line">                this.serviceState = ServiceState.START_FAILED;</span><br><span class="line">                // 检查配置信息.</span><br><span class="line">                this.checkConfig();</span><br><span class="line">                // 复制订阅信息.</span><br><span class="line">                this.copySubscription();</span><br><span class="line"></span><br><span class="line">                if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">                    this.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 创建 MQClientInstance 对象.</span><br><span class="line">                this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);</span><br><span class="line"></span><br><span class="line">                // 设置负载均衡示例 rebalanceImpl 的属性值.</span><br><span class="line">                this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">                this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">                this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);</span><br><span class="line"></span><br><span class="line">                // 初始化 pullAPIWrapper</span><br><span class="line">                this.pullAPIWrapper = new PullAPIWrapper(</span><br><span class="line">                    mQClientFactory,</span><br><span class="line">                    this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">                this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br><span class="line"></span><br><span class="line">                // 根据配置初始化 offsetStore 并加载进度条.</span><br><span class="line">                if (this.defaultMQPushConsumer.getOffsetStore() != null) &#123;</span><br><span class="line">                    this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    switch (this.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                        case BROADCASTING:</span><br><span class="line">                            this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                            break;</span><br><span class="line">                        case CLUSTERING:</span><br><span class="line">                            this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                            break;</span><br><span class="line">                        default:</span><br><span class="line">                            break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);</span><br><span class="line">                &#125;</span><br><span class="line">                this.offsetStore.load();</span><br><span class="line"></span><br><span class="line">                // 初始化消息消费服务并且启动.</span><br><span class="line">                if (this.getMessageListenerInner() instanceof MessageListenerOrderly) &#123;</span><br><span class="line">                    this.consumeOrderly = true;</span><br><span class="line">                    this.consumeMessageService =</span><br><span class="line">                        new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());</span><br><span class="line">                &#125; else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) &#123;</span><br><span class="line">                    this.consumeOrderly = false;</span><br><span class="line">                    this.consumeMessageService =</span><br><span class="line">                        new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());</span><br><span class="line">                &#125;</span><br><span class="line">                this.consumeMessageService.start();</span><br><span class="line"></span><br><span class="line">                boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);</span><br><span class="line">                if (!registerOK) &#123;</span><br><span class="line">                    this.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                    this.consumeMessageService.shutdown();</span><br><span class="line">                    throw new MQClientException(&quot;The consumer group[&quot; + this.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                        + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                        null);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mQClientFactory.start();</span><br><span class="line">                log.info(&quot;the consumer [&#123;&#125;] start OK.&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                this.serviceState = ServiceState.RUNNING;</span><br><span class="line">                break;</span><br><span class="line">            case RUNNING:</span><br><span class="line">            case START_FAILED:</span><br><span class="line">            case SHUTDOWN_ALREADY:</span><br><span class="line">                throw new MQClientException(&quot;The PushConsumer service state not OK, maybe started once, &quot;</span><br><span class="line">                    + this.serviceState</span><br><span class="line">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span><br><span class="line">                    null);</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 更新订阅主题信息.</span><br><span class="line">        this.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line">        // 检查broker上的所有客户端.</span><br><span class="line">        this.mQClientFactory.checkClientInBroker();</span><br><span class="line">        // 枷锁并向所有的broker端发送心跳.</span><br><span class="line">        this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">        // 重新负载均衡.</span><br><span class="line">        this.mQClientFactory.rebalanceImmediately();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void start() throws MQClientException &#123;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            switch (this.serviceState) &#123;</span><br><span class="line">                case CREATE_JUST:</span><br><span class="line">                    this.serviceState = ServiceState.START_FAILED;</span><br><span class="line">                    // If not specified,looking address from name server</span><br><span class="line">                    // 路由到namesrv 地址.</span><br><span class="line">                    if (null == this.clientConfig.getNamesrvAddr()) &#123;</span><br><span class="line">                        this.mQClientAPIImpl.fetchNameServerAddr();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Start request-response channel</span><br><span class="line">                    this.mQClientAPIImpl.start();</span><br><span class="line">                    // Start various schedule tasks</span><br><span class="line">                    this.startScheduledTask();</span><br><span class="line">                    // Start pull service</span><br><span class="line">                    this.pullMessageService.start();</span><br><span class="line">                    // Start rebalance service</span><br><span class="line">                    this.rebalanceService.start();</span><br><span class="line">                    // Start push service</span><br><span class="line">                    this.defaultMQProducer.getDefaultMQProducerImpl().start(false);</span><br><span class="line">                    log.info(&quot;the client factory [&#123;&#125;] start OK&quot;, this.clientId);</span><br><span class="line">                    this.serviceState = ServiceState.RUNNING;</span><br><span class="line">                    break;</span><br><span class="line">                case RUNNING:</span><br><span class="line">                    break;</span><br><span class="line">                case SHUTDOWN_ALREADY:</span><br><span class="line">                    break;</span><br><span class="line">                case START_FAILED:</span><br><span class="line">                    throw new MQClientException(&quot;The Factory object[&quot; + this.getClientId() + &quot;] has been created before, and failed.&quot;, null);</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="6-参考"><a href="#6-参考" class="headerlink" title="6.参考"></a>6.参考</h1><p>[1]<a href="https://www.jianshu.com/p/f071d5069059" target="_blank" rel="noopener"> 消息中间件—RocketMQ消息消费（一）</a></p><p>[2] <a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> Producer </tag>
            
            <tag> Consumer </tag>
            
            <tag> 消费 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列12--Producer 事务消息</title>
      <link href="/2018/09/01/RocketMQ%E7%B3%BB%E5%88%9712--Producer%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/09/01/RocketMQ%E7%B3%BB%E5%88%9712--Producer%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>RocketMQ除了支持普通消息，顺序消息，另外还支持事务消息。首先讨论一下什么是事务消息以及支持事务消息的必要性。我们以一个转帐的场景为例来说明这个问题：Bob向Smith转账100块。</p><p><a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">转账业务</a></p><h1 id="1-事务消息"><a href="#1-事务消息" class="headerlink" title="1. 事务消息"></a>1. 事务消息</h1><p>通过消息的异步事务,可以保证本地事务和消息发送同时执行成功或者失败,从而保证了数据的最终一致性.</p><p>rocketmq事务消息是发生在 producer和broker之间,是事务的二阶段提交，如图：</p><p><img src="http://lifestack.cn/wp-content/uploads/2015/09/%E4%BA%8B%E5%8A%A1%E9%80%BB%E8%BE%91.jpg" alt=""></p><p>只有在消息发送成功，并且本地操作执行成功时，才发送提交事务消息，做事务提交；</p><p>其他的情况，例如消息的发送失败，则直接发送回滚消息，进行回滚，或者发送消息成功，但是本地执行操作失败，也是发送回滚消息，进行回滚。</p><p>阶段解读：</p><p><strong>一阶段(步骤 1 2 3)</strong>:Producer 向Broker发送一条 PROPERTY_TRANSACTION_PREPARED 的消息，Broker接收到消息后保存在 CommitLog中，然后返回结果给 Producer,但是该类型的消息对Consumer是不可见的，Consumer无法消费。因为该类型消息在保存的时候，commitLogOffset没有被保存到 consumerQueue 中，所以客户端通过 consumerQueue 取不到 consumerQueue,所以无法被消费。</p><p><strong>二阶段(步骤 4 5)</strong>: Producer端的 tranExecuter.executeLocalTransaction 执行本地操作，返回本地事务的状态，然后发送一条类型为TransactionCommitType或者TransactionRollbackType的消息到Broker确认提交或者回滚。<br>Broker通过Request中的commitLogOffset，获取到上面状态为TransactionPreparedType的消息（简称消息A），然后重新构造一条与消息A内容相同的消息B，设置状态为TransactionCommitType或者TransactionRollbackType，然后保存。其中TransactionCommitType类型的，会放commitLogOffset到consumerQueue中，TransactionRollbackType类型的，消息体设置为空，不会放commitLogOffset到consumerQueue中。</p><p>所以，整个事务消息过程中，broker一共保存2条消息。</p><h1 id="2-producer端"><a href="#2-producer端" class="headerlink" title="2. producer端"></a>2. producer端</h1><p>在最新版本 4.4.0-SNAPSHOT 中，TransactionMQProducer已经把 本地执行事务的代码 和 broker回查 producer本地事务的方法封装到了一个监听器中TransactionListener。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionMQProducer extends DefaultMQProducer &#123;</span><br><span class="line">    private TransactionListener transactionListener;</span><br><span class="line"></span><br><span class="line">    private ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionListener &#123;</span><br><span class="line">    /**</span><br><span class="line">     * When send transactional prepare(half) message succeed, this method will be invoked to execute local transaction.</span><br><span class="line">     *</span><br><span class="line">     * @param msg Half(prepare) message</span><br><span class="line">     * @param arg Custom business parameter</span><br><span class="line">     * @return Transaction state</span><br><span class="line">     */</span><br><span class="line">    LocalTransactionState executeLocalTransaction(final Message msg, final Object arg);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * When no response to prepare(half) message. broker will send check message to check the transaction status, and this</span><br><span class="line">     * method will be invoked to get local transaction status.</span><br><span class="line">     *</span><br><span class="line">     * @param msg Check message</span><br><span class="line">     * @return Transaction state</span><br><span class="line">     */</span><br><span class="line">    LocalTransactionState checkLocalTransaction(final MessageExt msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionProducer &#123;</span><br><span class="line">    public static void main(String[] args) throws MQClientException, InterruptedException &#123;</span><br><span class="line">        // 本地事务执行逻辑及broker回查事务状态实现类.</span><br><span class="line">        TransactionListener transactionListener = new TransactionListenerImpl();</span><br><span class="line">        TransactionMQProducer producer = new TransactionMQProducer(&quot;Transaction_MQProducer_Group&quot;);</span><br><span class="line">        //设置 nameserver地址.</span><br><span class="line">        producer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line"></span><br><span class="line">        //设置broker回查prodducer的并发数</span><br><span class="line">        ExecutorService executorService = new ThreadPoolExecutor(2, 5, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(2000), new ThreadFactory() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Thread newThread(Runnable r) &#123;</span><br><span class="line">                Thread thread = new Thread(r);</span><br><span class="line">                thread.setName(&quot;client-transaction-msg-check-thread&quot;);</span><br><span class="line">                return thread;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        producer.setExecutorService(executorService);</span><br><span class="line">        producer.setTransactionListener(transactionListener);</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        String[] tags = new String[] &#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;&#125;;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Message msg = new Message(&quot;TopicTest1234&quot;, </span><br><span class="line">                        tags[i % tags.length], &quot;KEY&quot; + i,</span><br><span class="line">                        (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                </span><br><span class="line">                SendResult sendResult = producer.sendMessageInTransaction(msg, i);</span><br><span class="line">                System.out.printf(&quot;%s%n&quot;, sendResult);</span><br><span class="line"></span><br><span class="line">                Thread.sleep(10);</span><br><span class="line">            &#125; catch (MQClientException | UnsupportedEncodingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">            Thread.sleep(1000);</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 根据业务需要，自己实现 TransactionListener接口中的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionListenerImpl implements TransactionListener &#123;</span><br><span class="line">    private AtomicInteger transactionIndex = new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    private ConcurrentHashMap&lt;String, Integer&gt; localTrans = new ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        int value = transactionIndex.getAndIncrement();</span><br><span class="line">        int status = value % 3;</span><br><span class="line">        localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">        return LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;</span><br><span class="line">        Integer status = localTrans.get(msg.getTransactionId());</span><br><span class="line">        if (null != status) &#123;</span><br><span class="line">            switch (status) &#123;</span><br><span class="line">                case 0:</span><br><span class="line">                    return LocalTransactionState.UNKNOW;</span><br><span class="line">                case 1:</span><br><span class="line">                    return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">                case 2:</span><br><span class="line">                    return LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-consumer端"><a href="#3-consumer端" class="headerlink" title="3. consumer端"></a>3. consumer端</h1><p>同普通消息消费一样。</p><h1 id="4-发送消息详解"><a href="#4-发送消息详解" class="headerlink" title="4. 发送消息详解"></a>4. 发送消息详解</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">public TransactionSendResult sendMessageInTransaction(final Message msg,</span><br><span class="line">                                                          final TransactionListener tranExecuter, final Object arg)</span><br><span class="line">        throws MQClientException &#123;</span><br><span class="line"></span><br><span class="line">        // 判断是否有本地事务监听器</span><br><span class="line">        if (null == tranExecuter) &#123;</span><br><span class="line">            throw new MQClientException(&quot;tranExecutor is null&quot;, null);</span><br><span class="line">        &#125;</span><br><span class="line">        // 校验message信息.</span><br><span class="line">        Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">        // 标记该消息为 事务消息.</span><br><span class="line">        SendResult sendResult = null;</span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;);</span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());</span><br><span class="line">        // 第一次发送消息.</span><br><span class="line">        try &#123;</span><br><span class="line">            sendResult = this.send(msg);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new MQClientException(&quot;send message Exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">        Throwable localException = null;</span><br><span class="line">        switch (sendResult.getSendStatus()) &#123;</span><br><span class="line">            case SEND_OK: &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (sendResult.getTransactionId() != null) &#123;</span><br><span class="line">                        msg.putUserProperty(&quot;__transactionId__&quot;, sendResult.getTransactionId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                    if (null != transactionId &amp;&amp; !&quot;&quot;.equals(transactionId)) &#123;</span><br><span class="line">                        // 将 transactionId 设置到消息中.</span><br><span class="line">                        msg.setTransactionId(transactionId);</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 执行本地事务.*********重要.</span><br><span class="line">                    // 判断 localTransactionState 是否是 COMMIT_MESSAGE状态.</span><br><span class="line">                    localTransactionState = tranExecuter.executeLocalTransaction(msg, arg);</span><br><span class="line">                    if (null == localTransactionState) &#123;</span><br><span class="line">                        localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) &#123;</span><br><span class="line">                        log.info(&quot;executeLocalTransactionBranch return &#123;&#125;&quot;, localTransactionState);</span><br><span class="line">                        log.info(msg.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    log.info(&quot;executeLocalTransactionBranch exception&quot;, e);</span><br><span class="line">                    log.info(msg.toString());</span><br><span class="line">                    localException = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">            case FLUSH_DISK_TIMEOUT:</span><br><span class="line">            case FLUSH_SLAVE_TIMEOUT:</span><br><span class="line">            case SLAVE_NOT_AVAILABLE:</span><br><span class="line">                localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">// 第二次发送消息.</span><br><span class="line">            this.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            log.warn(&quot;local transaction execute &quot; + localTransactionState + &quot;, but end broker transaction failed&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 构造返回信息 TransactionSendResult</span><br><span class="line">        TransactionSendResult transactionSendResult = new TransactionSendResult();</span><br><span class="line">        transactionSendResult.setSendStatus(sendResult.getSendStatus());</span><br><span class="line">        transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</span><br><span class="line">        transactionSendResult.setMsgId(sendResult.getMsgId());</span><br><span class="line">        transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</span><br><span class="line">        transactionSendResult.setTransactionId(sendResult.getTransactionId());</span><br><span class="line">        transactionSendResult.setLocalTransactionState(localTransactionState);</span><br><span class="line">        return transactionSendResult;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void endTransaction(</span><br><span class="line">        final SendResult sendResult,</span><br><span class="line">        final LocalTransactionState localTransactionState,</span><br><span class="line">        final Throwable localException) throws RemotingException, MQBrokerException, InterruptedException, UnknownHostException &#123;</span><br><span class="line">        // 得到message的地址信息</span><br><span class="line">        final MessageId id;</span><br><span class="line">        if (sendResult.getOffsetMsgId() != null) &#123;</span><br><span class="line">            id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            id = MessageDecoder.decodeMessageId(sendResult.getMsgId());</span><br><span class="line">        &#125;</span><br><span class="line">        // 得到事务消息的Id</span><br><span class="line">        String transactionId = sendResult.getTransactionId();</span><br><span class="line">        // 根据brokerName 找到broker的地址.</span><br><span class="line">        final String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());</span><br><span class="line"></span><br><span class="line">        // 构造结束事务请求头信息.</span><br><span class="line">        EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader();</span><br><span class="line">        requestHeader.setTransactionId(transactionId);</span><br><span class="line">        requestHeader.setCommitLogOffset(id.getOffset());</span><br><span class="line">        switch (localTransactionState) &#123;</span><br><span class="line">            case COMMIT_MESSAGE:</span><br><span class="line">                requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">                break;</span><br><span class="line">            case ROLLBACK_MESSAGE:</span><br><span class="line">                requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line">                break;</span><br><span class="line">            case UNKNOW:</span><br><span class="line">                requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());</span><br><span class="line">        requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());</span><br><span class="line">        requestHeader.setMsgId(sendResult.getMsgId());</span><br><span class="line">        String remark = localException != null ? (&quot;executeLocalTransactionBranch exception: &quot; + localException.toString()) : null;</span><br><span class="line"></span><br><span class="line">        // oneway 形式发送事务应答信息.</span><br><span class="line">        this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark,</span><br><span class="line">            this.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="5-推荐及参考"><a href="#5-推荐及参考" class="headerlink" title="5. 推荐及参考"></a>5. 推荐及参考</h1><p>【1】 <a href="https://yq.aliyun.com/articles/55630" target="_blank" rel="noopener">事务消息</a></p><p>【2】 <a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> Producer </tag>
            
            <tag> 事务消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列10--Producer介绍</title>
      <link href="/2018/08/31/RocketMQ%E7%B3%BB%E5%88%9710--Producer%E4%BB%8B%E7%BB%8D/"/>
      <url>/2018/08/31/RocketMQ%E7%B3%BB%E5%88%9710--Producer%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>rocketmq支持3种形式的消息:</p><ul><li>普通消息</li><li>顺序消息</li><li>事务消息</li></ul><p>同时支持3种不同的发送方式</p><ul><li>同步</li><li>异步</li><li>One-Way</li></ul><p>本篇将以 DefaultMQProducer(普通消息)为例讲解 producer的一些属性配置、发送机制和消息结果的处理事项。</p><h1 id="1-MQProducer属性配置"><a href="#1-MQProducer属性配置" class="headerlink" title="1. MQProducer属性配置"></a>1. MQProducer属性配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"># Producer 组名，多个 Producer 如果属于一个应用，发送同样的消息，则应该将它们归为同一组</span><br><span class="line">   private String producerGroup;</span><br><span class="line"></span><br><span class="line">   # 在发送消息时，自动创建服务器不存在的topic，需要指定 Key。</span><br><span class="line"># 建议线下测试时开启，线上环境关闭</span><br><span class="line">   private String createTopicKey = MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC;</span><br><span class="line"></span><br><span class="line">   # 在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">   private volatile int defaultTopicQueueNums = 4;</span><br><span class="line"></span><br><span class="line">   # 发送消息超时时间，单位毫秒</span><br><span class="line">   private int sendMsgTimeout = 3000;</span><br><span class="line"></span><br><span class="line"># 消息 Body 超过多大开始压缩（Consumer收到消息会自动解压缩），单位字节</span><br><span class="line">   private int compressMsgBodyOverHowmuch = 1024 * 4;</span><br><span class="line"></span><br><span class="line"># 消息同步发送失败最大重试次数，超过这个设置次数后，需要开发者自己去解决。</span><br><span class="line">   private int retryTimesWhenSendFailed = 2;</span><br><span class="line"></span><br><span class="line"># 消息异步发送失败最大重试次数，超过这个设置次数后，需要开发者自己去解决。</span><br><span class="line">   private int retryTimesWhenSendAsyncFailed = 2;</span><br><span class="line"></span><br><span class="line">   # 如果发送消息返回 sendResult，但是 sendStatus!=SEND_OK，是否重试发送</span><br><span class="line">   private boolean retryAnotherBrokerWhenNotStoreOK = false;</span><br><span class="line"></span><br><span class="line">   # 客户端限制的消息大小，超过报错，同时服务端也会限制</span><br><span class="line">   private int maxMessageSize = 1024 * 1024 * 4; // 4M</span><br></pre></td></tr></table></figure><h1 id="2-发送消息"><a href="#2-发送消息" class="headerlink" title="2.发送消息"></a>2.发送消息</h1><h2 id="2-1-构造Message"><a href="#2-1-构造Message" class="headerlink" title="2.1 构造Message"></a>2.1 构造Message</h2><p>发送消息，第一步构造消息对象 Message。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Message(String topic, String tags, String keys, int flag, byte[] body, boolean waitStoreMsgOK) &#123;</span><br><span class="line">        this.topic = topic;</span><br><span class="line">        this.flag = flag;</span><br><span class="line">        this.body = body;</span><br><span class="line"></span><br><span class="line">        if (tags != null &amp;&amp; tags.length() &gt; 0)</span><br><span class="line">            this.setTags(tags);</span><br><span class="line"></span><br><span class="line">        if (keys != null &amp;&amp; keys.length() &gt; 0)</span><br><span class="line">            this.setKeys(keys);</span><br><span class="line"></span><br><span class="line">        this.setWaitStoreMsgOK(waitStoreMsgOK);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　一个应用尽可能用一个 Topic，消息子类型用 tags 来标识，tags 可以由应用自由设置。只有发送消息设置了tags，消费方在订阅消息时，才可以利用 tags 在 broker 做消息过滤。</p><p>　　每个消息在业务局面的唯一标识码，要设置到 keys 字段，方便将来定位消息丢失问题。服务器会为每个消息创建索引（哈希索引），应用可以通过 topic，key 来查询返条消息内容，以及消息被谁消费。由于是哈希索引，请务必保证 key 尽可能唯一，返样可以避免潜在的哈希冲突。</p><blockquote><p>如在订单业务中，可以将订单号设置进去：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String orderId = &quot;20034568923546&quot;;</span><br><span class="line">message.setKeys(orderId);</span><br></pre></td></tr></table></figure></p></blockquote><p>将具体的消息放到 body 字段中，waitStoreMsgOK标识是否等待Broker处存放消息ok.</p><h2 id="2-2-发送消息"><a href="#2-2-发送消息" class="headerlink" title="2.2 发送消息"></a>2.2 发送消息</h2><p>构造好Message消息后，调用 producer.send()方法完成对消息的发送。<br>底层调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public SendResult send(Message msg,</span><br><span class="line">       long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">       return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://www.iocoder.cn/images/RocketMQ/2017_04_18/02.png" alt=""></p><p>步骤：获取消息路由信息，选择要发送到的消息队列，执行消息发送核心方法，并对发送结果进行封装返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line">private SendResult sendDefaultImpl(</span><br><span class="line">        Message msg,</span><br><span class="line">        final CommunicationMode communicationMode,</span><br><span class="line">        final SendCallback sendCallback,</span><br><span class="line">        final long timeout</span><br><span class="line">    ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">        // 校验 Producer 处于运行状态(ServiceState.RUNNING)</span><br><span class="line">        this.makeSureStateOK();</span><br><span class="line">        // 校验消息格式</span><br><span class="line">        Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">        // 调用编号,调用时间,用于下面打印日志,标记为同义词发送消息,为监控平台链路追踪</span><br><span class="line">        final long invokeID = random.nextLong();</span><br><span class="line">        long beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line">        long beginTimestampPrev = beginTimestampFirst;</span><br><span class="line">        long endTimestamp = beginTimestampFirst;</span><br><span class="line"></span><br><span class="line">        // 从namesrv中获取Topic的路由信息.</span><br><span class="line">        TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">        if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">            boolean callTimeout = false; // 判断是否发送超时</span><br><span class="line">            MessageQueue mq = null;      // 最后选择消息要发送的队列</span><br><span class="line">            Exception exception = null;</span><br><span class="line">            SendResult sendResult = null; // 最后一次的发送结果.</span><br><span class="line">            // 判断发送模式是否是同步,同步的话可能需要发送多次.</span><br><span class="line">            int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1;</span><br><span class="line">            int times = 0;  // 第几次发送.</span><br><span class="line">            String[] brokersSent = new String[timesTotal]; // 存储每次发送消息选择的broker名</span><br><span class="line">            // 循环调用发送消息，直到成功</span><br><span class="line">            for (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">                String lastBrokerName = null == mq ? null : mq.getBrokerName();</span><br><span class="line">                // 选择要发送的消息队列.</span><br><span class="line">                MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">                if (mqSelected != null) &#123;</span><br><span class="line">                    mq = mqSelected;</span><br><span class="line">                    brokersSent[times] = mq.getBrokerName();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                        long costTime = beginTimestampPrev - beginTimestampFirst;</span><br><span class="line">                        if (timeout &lt; costTime) &#123;</span><br><span class="line">                            callTimeout = true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        // 调用发送消息的核心方法.</span><br><span class="line">                        sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        // 更新broker的可用性信息.</span><br><span class="line">                        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);</span><br><span class="line">                        switch (communicationMode) &#123;</span><br><span class="line">                            case ASYNC:</span><br><span class="line">                                return null;</span><br><span class="line">                            case ONEWAY:</span><br><span class="line">                                return null;</span><br><span class="line">                            case SYNC:</span><br><span class="line">                                // 同步发送成功但存储有问题时 &amp;&amp; 配置存储异常时重新发送开关 时，进行重试</span><br><span class="line">                                if (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                                    if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                        continue;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                return sendResult;</span><br><span class="line">                            default:</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (RemotingException e) &#123; // 打印异常，更新Broker可用性信息，更新继续循环</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);</span><br><span class="line">                        log.warn(String.format(&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125; catch (MQClientException e) &#123; // 打印异常，更新Broker可用性信息，继续循环</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);</span><br><span class="line">                        log.warn(String.format(&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125; catch (MQBrokerException e) &#123; // 打印异常，更新Broker可用性信息，部分情况下的异常，直接返回，结束循环</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);</span><br><span class="line">                        log.warn(String.format(&quot;sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        switch (e.getResponseCode()) &#123;</span><br><span class="line">                            case ResponseCode.TOPIC_NOT_EXIST:</span><br><span class="line">                            case ResponseCode.SERVICE_NOT_AVAILABLE:</span><br><span class="line">                            case ResponseCode.SYSTEM_ERROR:</span><br><span class="line">                            case ResponseCode.NO_PERMISSION:</span><br><span class="line">                            case ResponseCode.NO_BUYER_ID:</span><br><span class="line">                            case ResponseCode.NOT_IN_CURRENT_UNIT:</span><br><span class="line">                                continue;</span><br><span class="line">                            default:</span><br><span class="line">                                if (sendResult != null) &#123;</span><br><span class="line">                                    return sendResult;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                throw e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);</span><br><span class="line">                        log.warn(String.format(&quot;sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s&quot;, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">                        log.warn(&quot;sendKernelImpl exception&quot;, e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        throw e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 返回发送结果</span><br><span class="line">            if (sendResult != null) &#123;</span><br><span class="line">                return sendResult;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 根据不同情况，抛出不同的异常</span><br><span class="line">            String info = String.format(&quot;Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s&quot;,</span><br><span class="line">                times,</span><br><span class="line">                System.currentTimeMillis() - beginTimestampFirst,</span><br><span class="line">                msg.getTopic(),</span><br><span class="line">                Arrays.toString(brokersSent));</span><br><span class="line"></span><br><span class="line">            info += FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);</span><br><span class="line"></span><br><span class="line">            MQClientException mqClientException = new MQClientException(info, exception);</span><br><span class="line">            if (callTimeout) &#123;</span><br><span class="line">                throw new RemotingTooMuchRequestException(&quot;sendDefaultImpl call timeout&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (exception instanceof MQBrokerException) &#123;</span><br><span class="line">                mqClientException.setResponseCode(((MQBrokerException) exception).getResponseCode());</span><br><span class="line">            &#125; else if (exception instanceof RemotingConnectException) &#123;</span><br><span class="line">                mqClientException.setResponseCode(ClientErrorCode.CONNECT_BROKER_EXCEPTION);</span><br><span class="line">            &#125; else if (exception instanceof RemotingTimeoutException) &#123;</span><br><span class="line">                mqClientException.setResponseCode(ClientErrorCode.ACCESS_BROKER_TIMEOUT);</span><br><span class="line">            &#125; else if (exception instanceof MQClientException) &#123;</span><br><span class="line">                mqClientException.setResponseCode(ClientErrorCode.BROKER_NOT_EXIST_EXCEPTION);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            throw mqClientException;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Namesrv找不到异常</span><br><span class="line">        List&lt;String&gt; nsList = this.getmQClientFactory().getMQClientAPIImpl().getNameServerAddressList();</span><br><span class="line">        if (null == nsList || nsList.isEmpty()) &#123;</span><br><span class="line">            throw new MQClientException(</span><br><span class="line">                &quot;No name server address, please set it.&quot; + FAQUrl.suggestTodo(FAQUrl.NAME_SERVER_ADDR_NOT_EXIST_URL), null).setResponseCode(ClientErrorCode.NO_NAME_SERVER_EXCEPTION);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 消息路由找不到异常</span><br><span class="line">        throw new MQClientException(&quot;No route info of this topic, &quot; + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),</span><br><span class="line">            null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="3-消息发送结果处理"><a href="#3-消息发送结果处理" class="headerlink" title="3.消息发送结果处理"></a>3.消息发送结果处理</h1><p>　　消息发送成功或者失败，要打印消息日志，务必要打印 sendresult 和 key 字段。<br>send 消息方法，只要不抛异常，就代表发送成功。但是发送成功会有多个状态，在 sendResult 里定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public enum SendStatus &#123;</span><br><span class="line">    // 消息发送成功</span><br><span class="line">    SEND_OK,</span><br><span class="line">    // 消息发送成功，但是服务器刷盘超时，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失</span><br><span class="line">    FLUSH_DISK_TIMEOUT,</span><br><span class="line">    // 消发发送成功，但是服务器同步到 Slave 时超时，消息已经迕入服务器队列，只有此时服务器宕机，消息才会丢失</span><br><span class="line">    FLUSH_SLAVE_TIMEOUT,</span><br><span class="line">    // 消息发送成功，但是此时 slave 不可用，消息已经进入服务器队列，只有此时服务器宕机，消息才会丢失</span><br><span class="line">    SLAVE_NOT_AVAILABLE,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-发送形式"><a href="#4-发送形式" class="headerlink" title="4.发送形式"></a>4.发送形式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 消息发送模式</span><br><span class="line"> */</span><br><span class="line">public enum CommunicationMode &#123;</span><br><span class="line">    SYNC,   //同步.</span><br><span class="line">    ASYNC,  //异步.</span><br><span class="line">    ONEWAY, //只管发送</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SYNC<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.send(msg)</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>　　同步的发送方式，会等待发送结果后才返回。可以用 send(msg, timeout) 的方式指定等待时间，如果不指定，就是默认的 3000ms. 这个timeout 最终会被设置到 ResponseFuture 里，在发送完消息后，用 countDownLatch 去 await timeout的时间，如果过期，就会抛出异常。</p></blockquote><ul><li>ASYNC<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">producer.send(msg, new SendCallback() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onSuccess(SendResult sendResult) &#123;</span><br><span class="line">        System.out.printf(&quot;%-10d OK %s %n&quot;, index, sendResult.getMsgId());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onException(Throwable e) &#123;</span><br><span class="line">        System.out.printf(&quot;%-10d Exception %s %n&quot;, index, e);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>　　异步的发送方式，发送完后，立刻返回。Client 在拿到 Broker 的响应结果后，会回调指定的 callback. 这个 API 也可以指定 Timeout，不指定也是默认的 3000ms.</p></blockquote><ul><li>ONEWAY</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.sendOneway(msg);</span><br></pre></td></tr></table></figure><blockquote><p>一个 RPC 调用，通常是这样一个过程</p><ol><li>客户端发送请求到服务器</li><li>服务器处理该请求</li><li>服务器吐客户端返回应答</li></ol><p>　　 所以一个 RPC 的耗时时间是上述三个步骤的总和，而某些场景要求耗时非常短，但是对可靠性要求并不高，例如<br>日志收集类应用，此类应用可以采用 oneway 形式调用，oneway 形式只发送请求并等待应答，而发送请求在客<br>户端实现局面仅仅是一个 os 系统调用的开销，即将数据写入客户端的 socket 缓冲区，此过程耗时通常在微秒级。</p></blockquote>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> Producer </tag>
            
            <tag> 发送消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列11--Producer 顺序消息</title>
      <link href="/2018/08/31/RocketMQ%E7%B3%BB%E5%88%9711--Producer%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/08/31/RocketMQ%E7%B3%BB%E5%88%9711--Producer%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>顺序消息（FIFO消息）是MQ提供的一种严格按照顺序进行发布和消费的消息类型。顺序消息指消息发布和消息消费都按照顺序进行。</p><ul><li>顺序发布: 对于指定的一个Topic,客户端将按照一定的先后顺序发送消息；</li><li>顺序消费: 对于指定的一个Topic,按照一定的先后顺序接收消息，即先发送的消息一定会被消费段先接受到并处理。</li></ul><p>　　例如：一笔订单产生了3条消息，分别是：订单创建、订单付款、订单完成。消费时，要按照顺序一次消费才有意义。于此同时多笔订单之间又是可以并行消费的。</p><p><strong>全局顺序</strong></p><p>对于指定的一个Topic,所有的消息按照严格的先入先出（FIFO）的顺序进行发布和消费。</p><p><img src="http://docs-aliyun.cn-hangzhou.oss.aliyun-inc.com/assets/pic/49319/cn_zh/1534917028902/%E5%85%A8%E5%B1%80%E9%A1%BA%E5%BA%8F.png" alt=""></p><p>请参考 阿里的《<a href="https://help.aliyun.com/document_detail/49319.html?spm=a2c4g.11186623.4.6.6a0a292dCAyla4" target="_blank" rel="noopener">顺序消息</a>》说明。</p><h1 id="1-RocketMQ的顺序消息的实现"><a href="#1-RocketMQ的顺序消息的实现" class="headerlink" title="1.RocketMQ的顺序消息的实现"></a>1.RocketMQ的顺序消息的实现</h1><p>　　顺序消息主要是指局部顺序，即生产者通过将某一类消息发送至同一个队列来实现。与发生普通消息相比，在发送顺序消息时要对同一类型的消息选择同一个队列，即同一个　<strong>MessageQueue</strong>　对象。 目前RocketMQ定义了选择MessageQueue对象的接口MessageQueueSelector，里面有方法select(final List mqs, final Message msg, final Object arg)，并且RocketMQ默认实现了提供了两个实现类SelectMessageQueueByHash和SelectMessageQueueByRandoom，即根据arg参数通过Hash或者随机方式选择MessageQueue对象。 为了业务层根据业务需要能自定义选择规则，也可以在业务层自定义选择规则，然后调用DefaultMQProducer.send(Message msg, MessageQueueSelector selector, Object arg)方法完成顺序消息的方式。 </p><p>　　消息发布是有序的含义：producer发送消息应该是依次发送的，所以要求发送消息的时候保证：</p><ul><li>消息不能异步发送，同步发送的时候才能保证broker收到是有序的。</li><li>每次发送选择的是同一个MessageQueue</li></ul><h1 id="2-Producer实现"><a href="#2-Producer实现" class="headerlink" title="2.Producer实现"></a>2.Producer实现</h1><p>　　参考网上的例子，编写如下的producer发送顺序消息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">public class Producer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws UnsupportedEncodingException, RemotingException, MQClientException, MQBrokerException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //设置 producerGroup 名称</span><br><span class="line">            DefaultMQProducer producer = new DefaultMQProducer(&quot;Order_Producer_Group&quot;);</span><br><span class="line">            //设置 nameserver地址.</span><br><span class="line">            producer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">            producer.start();</span><br><span class="line"></span><br><span class="line">            // 订单创建 订单支付 订单完成</span><br><span class="line">            String[] tags = new String[] &#123;&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;&#125;;</span><br><span class="line"></span><br><span class="line">            List&lt;Order&gt; orders = buildOrders();</span><br><span class="line">            for(int i = 0; i &lt; orders.size(); i++)&#123;</span><br><span class="line">                String body = &quot;Hello Rocket&quot; + orders.get(i);</span><br><span class="line">                long orderId = orders.get(i).getOrderId();</span><br><span class="line"></span><br><span class="line">                Message message = new Message(&quot;Topic_Order&quot;,</span><br><span class="line">                        tags[i % tags.length],</span><br><span class="line">                        &quot;KEY&quot; + i,</span><br><span class="line">                        body.getBytes());</span><br><span class="line"></span><br><span class="line">                SendResult sendResult = producer.send(message, new SelectMessageQueueByHash(), orderId);</span><br><span class="line">                System.out.println(&quot;content=&quot; + body + &quot;. sendResult = &quot; + sendResult);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125; catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; // end main.</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成模拟订单数据</span><br><span class="line">     */</span><br><span class="line">    private static List&lt;Order&gt; buildOrders() &#123;</span><br><span class="line">        List&lt;Order&gt; orderList = new ArrayList&lt;Order&gt;();</span><br><span class="line"></span><br><span class="line">        Order orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111039L);</span><br><span class="line">        orderDemo.setDesc(&quot;创建&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111065L);</span><br><span class="line">        orderDemo.setDesc(&quot;创建&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111039L);</span><br><span class="line">        orderDemo.setDesc(&quot;付款&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103117235L);</span><br><span class="line">        orderDemo.setDesc(&quot;创建&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111065L);</span><br><span class="line">        orderDemo.setDesc(&quot;付款&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103117235L);</span><br><span class="line">        orderDemo.setDesc(&quot;付款&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111065L);</span><br><span class="line">        orderDemo.setDesc(&quot;完成&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111039L);</span><br><span class="line">        orderDemo.setDesc(&quot;推送&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103117235L);</span><br><span class="line">        orderDemo.setDesc(&quot;完成&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        orderDemo = new Order();</span><br><span class="line">        orderDemo.setOrderId(15103111039L);</span><br><span class="line">        orderDemo.setDesc(&quot;完成&quot;);</span><br><span class="line">        orderList.add(orderDemo);</span><br><span class="line"></span><br><span class="line">        return orderList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">class Order&#123;</span><br><span class="line">    private long orderId;</span><br><span class="line"></span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-Consumer实现"><a href="#3-Consumer实现" class="headerlink" title="3.Consumer实现"></a>3.Consumer实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws MQClientException &#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;Order_Consumer_Group&quot;);</span><br><span class="line">        consumer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(&quot;Topic_Order&quot;, &quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(new MessageListenerOrderly() &#123;</span><br><span class="line">            Random random = new Random();</span><br><span class="line">            @Override</span><br><span class="line">            public ConsumeOrderlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeOrderlyContext context) &#123;</span><br><span class="line">                context.setAutoCommit(true);</span><br><span class="line">                System.out.print(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; );</span><br><span class="line">                for (MessageExt msg: msgs) &#123;</span><br><span class="line">                    System.out.println(msg + &quot;, content:&quot; + new String(msg.getBody()));</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //模拟业务逻辑处理中...</span><br><span class="line">                    TimeUnit.SECONDS.sleep(random.nextInt(10));</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                return ConsumeOrderlyStatus.SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(&quot;Consumer Started.%n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-结果"><a href="#4-结果" class="headerlink" title="4.结果"></a>4.结果</h1><p><strong>producer端发送的消息</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">content=Hello RocketOrder(orderId=15103111039, desc=创建). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A62E, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=0], queueOffset=0]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111065, desc=创建). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A6E5, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=2], queueOffset=0]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111039, desc=付款). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A79C, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=0], queueOffset=1]</span><br><span class="line">content=Hello RocketOrder(orderId=15103117235, desc=创建). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518400002A9F0000000000033BBC, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-a, queueId=0], queueOffset=0]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111065, desc=付款). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A853, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=2], queueOffset=1]</span><br><span class="line">content=Hello RocketOrder(orderId=15103117235, desc=付款). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518400002A9F0000000000033C73, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-a, queueId=0], queueOffset=1]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111065, desc=完成). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A90A, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=2], queueOffset=2]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111039, desc=推送). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002A9C1, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=0], queueOffset=2]</span><br><span class="line">content=Hello RocketOrder(orderId=15103117235, desc=完成). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518400002A9F0000000000033D2A, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-a, queueId=0], queueOffset=2]</span><br><span class="line">content=Hello RocketOrder(orderId=15103111039, desc=完成). sendResult = SendResult [sendStatus=SEND_OK, msgId=C0A8518600002A9F000000000002AA78, messageQueue=MessageQueue [topic=Topic_Order, brokerName=broker-b, queueId=0], queueOffset=3]</span><br></pre></td></tr></table></figure><p><strong>consumer端消费消息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConsumeMessageThread_4 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=0, sysFlag=0, bornTimestamp=1535694773214, bornHost=/192.168.81.1:61621, storeTimestamp=1535723526505, storeHost=/192.168.81.132:10911, msgId=C0A8518400002A9F0000000000033BBC, commitLogOffset=211900, bodyCRC=1826716009, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY3, WAIT=true, TAGS=TagA&#125;, body=51]], content:Hello RocketOrder(orderId=15103117235, desc=创建)</span><br><span class="line">ConsumeMessageThread_5 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=0, sysFlag=0, bornTimestamp=1535694772791, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553085, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A62E, commitLogOffset=173614, bodyCRC=1934949583, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=4, KEYS=KEY0, WAIT=true, TAGS=TagA&#125;, body=51]], content:Hello RocketOrder(orderId=15103111039, desc=创建)</span><br><span class="line">ConsumeMessageThread_6 Receive New Messages: MessageExt [queueId=2, storeSize=183, queueOffset=0, sysFlag=0, bornTimestamp=1535694773081, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553244, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A6E5, commitLogOffset=173797, bodyCRC=1291356221, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY1, WAIT=true, TAGS=TagB&#125;, body=51]], content:Hello RocketOrder(orderId=15103111065, desc=创建)</span><br><span class="line">ConsumeMessageThread_6 Receive New Messages: MessageExt [queueId=2, storeSize=183, queueOffset=1, sysFlag=0, bornTimestamp=1535694773360, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553455, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A853, commitLogOffset=174163, bodyCRC=1081168709, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY4, WAIT=true, TAGS=TagB&#125;, body=51]], content:Hello RocketOrder(orderId=15103111065, desc=付款)</span><br><span class="line">ConsumeMessageThread_4 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=1, sysFlag=0, bornTimestamp=1535694773369, bornHost=/192.168.81.1:61621, storeTimestamp=1535723526572, storeHost=/192.168.81.132:10911, msgId=C0A8518400002A9F0000000000033C73, commitLogOffset=212083, bodyCRC=1617469969, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY5, WAIT=true, TAGS=TagC&#125;, body=51]], content:Hello RocketOrder(orderId=15103117235, desc=付款)</span><br><span class="line">ConsumeMessageThread_5 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=1, sysFlag=0, bornTimestamp=1535694773157, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553299, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A79C, commitLogOffset=173980, bodyCRC=2145200055, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=4, KEYS=KEY2, WAIT=true, TAGS=TagC&#125;, body=51]], content:Hello RocketOrder(orderId=15103111039, desc=付款)</span><br><span class="line">ConsumeMessageThread_6 Receive New Messages: MessageExt [queueId=2, storeSize=183, queueOffset=2, sysFlag=0, bornTimestamp=1535694773377, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553489, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A90A, commitLogOffset=174346, bodyCRC=339615115, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY6, WAIT=true, TAGS=TagA&#125;, body=51]], content:Hello RocketOrder(orderId=15103111065, desc=完成)</span><br><span class="line">ConsumeMessageThread_5 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=2, sysFlag=0, bornTimestamp=1535694773404, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553494, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002A9C1, commitLogOffset=174529, bodyCRC=742301160, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=4, KEYS=KEY7, WAIT=true, TAGS=TagB&#125;, body=51]], content:Hello RocketOrder(orderId=15103111039, desc=推送)</span><br><span class="line">ConsumeMessageThread_4 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=2, sysFlag=0, bornTimestamp=1535694773411, bornHost=/192.168.81.1:61621, storeTimestamp=1535723526623, storeHost=/192.168.81.132:10911, msgId=C0A8518400002A9F0000000000033D2A, commitLogOffset=212266, bodyCRC=875031775, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=3, KEYS=KEY8, WAIT=true, TAGS=TagC&#125;, body=51]], content:Hello RocketOrder(orderId=15103117235, desc=完成)</span><br><span class="line">ConsumeMessageThread_5 Receive New Messages: MessageExt [queueId=0, storeSize=183, queueOffset=3, sysFlag=0, bornTimestamp=1535694773426, bornHost=/192.168.81.1:61618, storeTimestamp=1535723553517, storeHost=/192.168.81.134:10911, msgId=C0A8518600002A9F000000000002AA78, commitLogOffset=174712, bodyCRC=731015545, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message [topic=Topic_Order, flag=0, properties=&#123;MIN_OFFSET=0, MAX_OFFSET=4, KEYS=KEY9, WAIT=true, TAGS=TagA&#125;, body=51]], content:Hello RocketOrder(orderId=15103111039, desc=完成)</span><br></pre></td></tr></table></figure><h1 id="5-Producer发送顺序消息过程"><a href="#5-Producer发送顺序消息过程" class="headerlink" title="5.Producer发送顺序消息过程"></a>5.Producer发送顺序消息过程</h1><p>　　上面我们已经说过，要保证消息是顺序消息，在发送顺序消息时要对同一类型的消息选择同一个队列，即同一个　<strong>MessageQueue</strong>　对象。<br>　　在这里，我们要保证的是同一订单的消息要投放到同一个队列中，所以我们根据订单号去hash运算，一样的订单号得到的hash值可定是相同的，只要保证其队列的个数是不变的，则同一订单号的消息会被放到同一个队列中。</p><p>之前发送普通消息时，我们调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public SendResult send(Message msg)</span><br></pre></td></tr></table></figure></p><p>但发送顺序消息时，由于我们要把同一特征的消息放到同一队列中，所以我们使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public SendResult send(Message msg, MessageQueueSelector selector, Object arg)</span><br></pre></td></tr></table></figure><p>根据传入的arg值，选择路由到同一个队列中。</p><h2 id="5-1MessageQueueSelector"><a href="#5-1MessageQueueSelector" class="headerlink" title="5.1MessageQueueSelector"></a>5.1MessageQueueSelector</h2><p>第二个参数 MessageQueueSelector 是一个接口，rocketmq默认提供了3种实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MessageQueueSelector &#123;</span><br><span class="line">    MessageQueue select(List&lt;MessageQueue&gt; var1, Message var2, Object var3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-b735612943499713.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  发送消息，随机选择队列</span><br><span class="line"> */</span><br><span class="line">public class SelectMessageQueueByRandom implements MessageQueueSelector &#123;</span><br><span class="line">    private Random random = new Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">        int value = random.nextInt(mqs.size());</span><br><span class="line">        return mqs.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>随机选择，也就是谁也不知道它到底会选择谁，这种效率其实很差，没有负载均衡，谁也不知道会不会堵塞起来，谁也不知道某个队列是否已经塞满</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 使用哈希算法来选择队列，顺序消息推荐该实现.</span><br><span class="line"> */</span><br><span class="line">public class SelectMessageQueueByHash implements MessageQueueSelector &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">        int value = arg.hashCode();</span><br><span class="line">        if (value &lt; 0) &#123;</span><br><span class="line">            value = Math.abs(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        value = value % mqs.size();</span><br><span class="line">        return mqs.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们每个传递进入的对象都会被哈希算法计算出 一个哈希值，比如我们传递的是订单号，那么无疑我们可以保证相同的订单号可以传递给相同的topic去处理，那么只要再保证是一致的tag就可以保证顺序的一致性啦</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 根据机房来选择发往哪个队列，支付宝逻辑机房使用</span><br><span class="line"> */</span><br><span class="line">public class SelectMessageQueueByMachineRoom implements MessageQueueSelector &#123;</span><br><span class="line">    private Set&lt;String&gt; consumeridcs;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Set&lt;String&gt; getConsumeridcs() &#123;</span><br><span class="line">        return consumeridcs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setConsumeridcs(Set&lt;String&gt; consumeridcs) &#123;</span><br><span class="line">        this.consumeridcs = consumeridcs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>机房选择，算法是木有啦，应该是根据ip地址去区分。</p></blockquote><p>　　同理，我们在使用时可以根据自己的业务需要来选择合适的方案，也可以自定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SendResult sendResult = producer.send(msg, new MessageQueueSelector() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">                        Integer id = (Integer) arg;</span><br><span class="line">                        int index = id % mqs.size();</span><br><span class="line">                        return mqs.get(index);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, arg);</span><br></pre></td></tr></table></figure><h2 id="5-2-顺序消息发送"><a href="#5-2-顺序消息发送" class="headerlink" title="5.2 顺序消息发送"></a>5.2 顺序消息发送</h2><p>底层调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private SendResult sendSelectImpl(</span><br><span class="line">       Message msg,</span><br><span class="line">       MessageQueueSelector selector,</span><br><span class="line">       Object arg,</span><br><span class="line">       final CommunicationMode communicationMode,</span><br><span class="line">       final SendCallback sendCallback, final long timeout</span><br><span class="line">   )</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">private SendResult sendSelectImpl(</span><br><span class="line">       Message msg,</span><br><span class="line">       MessageQueueSelector selector,</span><br><span class="line">       Object arg,</span><br><span class="line">       final CommunicationMode communicationMode,</span><br><span class="line">       final SendCallback sendCallback, final long timeout</span><br><span class="line">   ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">       // 确定producer的状态时Running.</span><br><span class="line">       long beginStartTime = System.currentTimeMillis();</span><br><span class="line">       this.makeSureStateOK();</span><br><span class="line">       // 校验message的格式.</span><br><span class="line">       Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line"></span><br><span class="line">       // 找到topic的路由信息,否则抛出异常.</span><br><span class="line">       TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">       if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">           </span><br><span class="line">           MessageQueue mq = null;</span><br><span class="line">           try &#123;</span><br><span class="line">               // 路由到消息要发送的消息队列.</span><br><span class="line">               mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);</span><br><span class="line">           &#125; catch (Throwable e) &#123;</span><br><span class="line">               throw new MQClientException(&quot;select message queue throwed exception.&quot;, e);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 判断是否超时.</span><br><span class="line">           long costTime = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">           if (timeout &lt; costTime) &#123;</span><br><span class="line">               throw new RemotingTooMuchRequestException(&quot;sendSelectImpl call timeout&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           // 如果找到了要发送的消息队列,则发送该消息,否则跑相互异常信息.</span><br><span class="line">           if (mq != null) &#123;</span><br><span class="line">               return this.sendKernelImpl(msg, mq, communicationMode, sendCallback, null, timeout - costTime);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               throw new MQClientException(&quot;select message queue return null.&quot;, null);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       throw new MQClientException(&quot;No route info for this topic, &quot; + msg.getTopic(), null);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) &#123;</span><br><span class="line">        //  private final ConcurrentMap&lt;String, TopicPublishInfo&gt; topicPublishInfoTable = new ConcurrentHashMap&lt;String, TopicPublishInfo&gt;();</span><br><span class="line">        TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic);</span><br><span class="line">        </span><br><span class="line">        // 如果 topic的路由信息查询不到,或者该topic的消息队列还未初始化好,则创建该topic路由</span><br><span class="line">        // 并更新到namesrv上.</span><br><span class="line">        if (null == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">            this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo());</span><br><span class="line">            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">            topicPublishInfo = this.topicPublishInfoTable.get(topic);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">            return topicPublishInfo;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer);</span><br><span class="line">            topicPublishInfo = this.topicPublishInfoTable.get(topic);</span><br><span class="line">            return topicPublishInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-consumer端接收"><a href="#5-3-consumer端接收" class="headerlink" title="5.3 consumer端接收"></a>5.3 consumer端接收</h2><p>　　普通消息consumer注册的监听器是： MessageListenerConcurrently：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void registerMessageListener(MessageListenerConcurrently messageListener) &#123;</span><br><span class="line">        this.messageListener = messageListener;</span><br><span class="line">        this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　而顺序消息consumer注册的监听器时是 MessageListenerOrderly：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void registerMessageListener(MessageListenerOrderly messageListener) &#123;</span><br><span class="line">        this.messageListener = messageListener;</span><br><span class="line">        this.defaultMQPushConsumerImpl.registerMessageListener(messageListener);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public enum ConsumeOrderlyStatus &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Success consumption</span><br><span class="line">     */</span><br><span class="line">    SUCCESS,</span><br><span class="line">    /**</span><br><span class="line">     * Rollback consumption(only for binlog consumption)</span><br><span class="line">     */</span><br><span class="line">    @Deprecated</span><br><span class="line">    ROLLBACK,</span><br><span class="line">    /**</span><br><span class="line">     * Commit offset(only for binlog consumption)</span><br><span class="line">     */</span><br><span class="line">    @Deprecated</span><br><span class="line">    COMMIT,</span><br><span class="line">    /**</span><br><span class="line">     * Suspend current queue a moment</span><br><span class="line">     */</span><br><span class="line">    SUSPEND_CURRENT_QUEUE_A_MOMENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　本地消费的事务控制，</p><ul><li>ConsumeOrderlyStatus.SUCCESS（提交）</li><li>ConsumeOrderlyStatus.SUSPEND_CURRENT_QUEUE_A_MOMENT（挂起一会再消费）</li></ul><p>　<br>　　在此之前还有一个变量ConsumeOrderlyContext context的setAutoCommit()是否自动提交。</p><p>　　当SUSPEND_CURRENT_QUEUE_A_MOMENT时，autoCommit设置为true或者false没有区别，本质跟消费相反，把消息从msgTreeMapTemp转移回msgTreeMap，等待下次消费。</p><p>当SUCCESS时，autoCommit设置为true时比设置为false多做了2个动作，</p><pre><code># 本质是删除msgTreeMapTemp里的消息，msgTreeMapTemp里的消息在上面消费时从msgTreeMap转移过来的consumeRequest.getProcessQueue().commit()# 本质是把拉消息的偏移量更新到本地，然后定时更新到brokerthis.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, false);</code></pre><p>　　那么少了这2个动作会怎么样呢，随着消息的消费进行，msgTreeMapTemp里的消息堆积越来越多，消费消息的偏移量一直没有更新到broker导致consumer每次重新启动后都要从头开始重复消费。所以 autoCommit建议设置为true.</p><p>　　好的，本篇顺序消息主要介绍了 顺序消息的发送、消费、以及与普通消息的不同。下篇将介绍 事务消息的发送。</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> Producer </tag>
            
            <tag> 顺序消息 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列06--整体架构概述</title>
      <link href="/2018/08/30/RocketMQ%E7%B3%BB%E5%88%9706--%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/"/>
      <url>/2018/08/30/RocketMQ%E7%B3%BB%E5%88%9706--%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>　　本篇,我主要根据 rocketmq的源码目录,简单介绍下 rocketmq各模块的功能,及其各自间的相互调用。接着大体上说一下 其中的nameserver，底层通信和数据存储。但里面的东西还需要大家去阅读源码，仔细体会。这里只是做个引子。我在文章的最后推荐了 【Rocketmq源码阅读】的系列博客，对大家阅读源码可能会有帮助。<br>废话不多说，直入主题。</p><h1 id="1-源码目录"><a href="#1-源码目录" class="headerlink" title="1. 源码目录"></a>1. 源码目录</h1><p>　　我这里是下载的 最新的 RocekyMQ 4.4.0-SNAPSHOT版本的<a href="https://github.com/apache/rocketmq/" target="_blank" rel="noopener">源码</a><br>导入到 IDEA中，目录结构如图：</p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-53e6a18b34657498.png" alt=""></p><ul><li><p>distribution</p><blockquote><p>　　存放系统中的脚本，以及一些broker集群的配置文件，用户可以根据自己的项目信息更改配置文件或脚本中的内容，来启动 nameserver 和 broker,集合 example中的Producer/Consumer来做一些小测试。</p></blockquote></li><li><p>broker</p><blockquote><p>　　消息代理，起到 串联 Producer/Consumer 和 Store的作用。我们所谓的消息的存储、接收、拉去、推送等操作都是在broker上进行的。</p></blockquote></li><li><p>client</p><blockquote><p>　　包含 Producer 和 Consumer，负责消息的发和收。</p></blockquote></li><li><p>common</p><blockquote><p>　　通用的常量枚举、基类方法或数据结构，按描述的目标来分包，</p></blockquote></li><li><p>example</p><blockquote><p>　　使用样例，包含各种使用方法，Pull/Push模式，广播模式、有序消息，事务消息。</p></blockquote></li><li><p>filter</p><blockquote><p>　　过滤器，用于服务端的过滤方式，实现了真正意义的高内聚低耦合的设计思想。<br>　　在使用filter模块的时候需要启动filter的服务。</p></blockquote></li><li><p>logappender logging</p><blockquote><p>　　日志相关。</p></blockquote></li><li><p>namesrv</p><blockquote><p>　　注册中心，每个broker都会在这里注册，client也会从这里获取broker 的相关信息。</p></blockquote></li><li><p>openmessaging</p><blockquote></blockquote></li><li><p>remoting</p><blockquote><p>　　基于Netty实现的额昂罗通信模块，包括server和client,client broker filter 等模块都对他有依赖。</p></blockquote></li><li><p>srvutil</p><blockquote><p>　　用来处理命令行的，一个用来配置shutdownHook.目的为了拆分客户端依赖，尽可能减少客户端的依赖。</p></blockquote></li><li><p>store</p><blockquote><p>　　负责消息的存储和读取。</p></blockquote></li><li><p>test</p><blockquote><p>　　测试用例代码</p></blockquote></li><li><p>tools</p><blockquote><p>　　一些工具类，基于他们可以写一些工具来管理、查看MQ系统的一些信息。</p></blockquote></li></ul><h1 id="2-模块调用图及层次说明"><a href="#2-模块调用图及层次说明" class="headerlink" title="2. 模块调用图及层次说明"></a>2. 模块调用图及层次说明</h1><p><img src="https://upload-images.jianshu.io/upload_images/11560519-f4bf6ba3b4f5bc93.png" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-aa7a629b10e20a53.png" alt=""></p><h1 id="3-nameserver介绍"><a href="#3-nameserver介绍" class="headerlink" title="3. nameserver介绍"></a>3. nameserver介绍</h1><p>　　在rocketmq早期版本中，是没有namersrv的，而是用 zookeeper做分布式协调和服务发现的。但是后期阿里根据业务需要自主研发了轻量级的 namesrv，用于注册client服务与broker的请求路由工作，namesrv上不做任何消息的位置存储（之前的zookeeper的位置存储数据会影响整体集群性能）</p><ul><li>　　rocketmq-namesrv扮演着nameNode角色，记录着运行时消息相关的meta信息以及broker和filtersrv的运行时信息，可以部署集群；</li><li>　　可以看作是轻量级的zookeeper，但比zookeeper性能更好，可靠性更强；</li><li>　　rocketmq-namesrv主要是节点之间相互进行心跳检测、数据通信、集群高可靠性，一致性、容错性等方面的核心模块；</li><li>　　roketmq-namesrv的底层通信机制与Netty进行联系，上层通信与各个模块产生强一致性的对应关系。当broker producer consumer 都运行后，maerserv一共有8类线程：<ul><li>守护线程</li><li>定时任务线程</li><li>Netty的boss线程</li><li>NettyEventExecute线程</li><li>DestroyJavaVM线程</li><li>Work线程</li><li>Handler线程</li><li>RemotingExxecutorThread线程</li></ul></li></ul><h1 id="4-底层通信介绍"><a href="#4-底层通信介绍" class="headerlink" title="4. 底层通信介绍"></a>4. 底层通信介绍</h1><ul><li><p>ServerHouseKeepingService</p><blockquote><p>守护线程，本质是 ChannelEventListner,监听broker的channel变化来更新本地的RouteInfo.</p></blockquote></li><li><p>NSScheduledThread：定时任务线程，定时跑2个线程，第一个：每个10分钟&gt; &gt; 扫描出不活动的broker,然后 从routeInfo中剔除；第二个：每10分钟定时打印configTable的信息。</p></li><li><p>NettyBossSelector</p><blockquote><p>Metty的boss线程，</p></blockquote></li><li><p>NettyEventExecuter</p><blockquote><p>一个单独的线程，监听NettyChannel状态变化来通知ChannelEventListener做响应动作。</p></blockquote></li><li><p>DestroyJavaVM</p><blockquote><p>Java虚拟机解析钩子，已办是当虚拟机关闭时用来清理或者释放资源；</p></blockquote></li><li><p>NettyServerSelector</p><blockquote><p>Netty的work线程，可能有多个。</p></blockquote></li><li><p>NettyServerWorkerThread_x</p><blockquote><p>执行ChannelHandler方法的线程。</p></blockquote></li><li><p>RemotingExecutorThread_x</p><blockquote><p>服务端逻辑线程</p></blockquote></li></ul><h1 id="6-推荐"><a href="#6-推荐" class="headerlink" title="6. 推荐"></a>6. 推荐</h1><p><a href="https://mp.weixin.qq.com/s/UIPgD7EaaiOArwctdVmJAA" target="_blank" rel="noopener">【Rocketmq源码阅读】</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 源码目录 </tag>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列05--Hello world入门篇</title>
      <link href="/2018/08/29/RocketMQ%E7%B3%BB%E5%88%9705--HelloWorld%E5%85%A5%E9%97%A8/"/>
      <url>/2018/08/29/RocketMQ%E7%B3%BB%E5%88%9705--HelloWorld%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>前面几篇介绍了rocketmq的基本概念,结构,集群搭建方案,上一篇搭建了2m-noslave双主集群模式的broker。接下来，我们下载 rocketmq的源码包，根据里面的示例来进一步了解 rocketmq的各种特性。</p><p>源码地址： <a href="https://github.com/apache/rocketmq/" target="_blank" rel="noopener">https://github.com/apache/rocketmq/</a><br>我们会参考 example的示例代码来入门。（我这里依然采用的时3.2.6版本）</p><h1 id="1-pom依赖"><a href="#1-pom依赖" class="headerlink" title="1.pom依赖"></a>1.pom依赖</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--rocketmq--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.alibaba.rocketmq&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.2.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h1 id="2-producer示例代码"><a href="#2-producer示例代码" class="headerlink" title="2.producer示例代码"></a>2.producer示例代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class Producer &#123;</span><br><span class="line">    public static void main(String[] args) throws MQClientException, InterruptedException &#123;</span><br><span class="line">        //设置 producerGroup 名称,保证不同的业务唯一性.</span><br><span class="line">        DefaultMQProducer producer = new DefaultMQProducer(&quot;DingDing&quot;);</span><br><span class="line">        //设置 nameserver地址.</span><br><span class="line">        producer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">        //启动 producer.</span><br><span class="line">        producer.start();</span><br><span class="line"></span><br><span class="line">        // 发送消息.</span><br><span class="line">        for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line"></span><br><span class="line">                Message msg = new Message(&quot;DingDing_Topic&quot;, // topic</span><br><span class="line">                        &quot;sign_up&quot;,                           // tags</span><br><span class="line">                        (&quot;员工&quot; + i + &quot;签到&quot;).getBytes());        // body</span><br><span class="line"></span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                log.info(&quot;发送结果:&quot; + sendResult);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 关闭 producer.</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤</strong></p><blockquote><p>1.设置 producer group name，用来区分不同业务的producer，因此需要保证不同业务改名称不同；</p><p>2.指定链接的nameserver的地址，集群的话地址间以 ； 分割；</p><p>3.启动消息生产者；</p><p>4.构造消息对象，发送消息，处理发送结果；</p><p>5.当发送消息结束后，应该关闭producer.</p></blockquote><h1 id="3-consumer示例代码"><a href="#3-consumer示例代码" class="headerlink" title="3.consumer示例代码"></a>3.consumer示例代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Consumer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException, MQClientException &#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(&quot;DingDing&quot;);</span><br><span class="line">        //设置 nameserver地址.</span><br><span class="line">        consumer.setNamesrvAddr(&quot;192.168.81.132:9876;192.168.81.134:9876&quot;);</span><br><span class="line">        /**</span><br><span class="line">         * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费&lt;br&gt;</span><br><span class="line">         * 如果非第一次启动，那么按照上次消费的位置继续消费</span><br><span class="line">         */</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line"></span><br><span class="line">        consumer.subscribe(&quot;DingDing_Topic&quot;, &quot;*&quot;);</span><br><span class="line"></span><br><span class="line">//        consumer.setConsumeMessageBatchMaxSize(10);</span><br><span class="line"></span><br><span class="line">        consumer.registerMessageListener(new MessageListenerConcurrently() &#123;</span><br><span class="line"></span><br><span class="line">            // 接收消息.</span><br><span class="line">            @Override</span><br><span class="line">            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,</span><br><span class="line">                                                            ConsumeConcurrentlyContext context) &#123;</span><br><span class="line">//                System.out.println(Thread.currentThread().getName() + &quot; 收到消息 &quot; + msgs);</span><br><span class="line">                System.out.println(&quot;本批次收到消息的数量 &quot; + msgs.size());</span><br><span class="line">                for(MessageExt msg : msgs)&#123;</span><br><span class="line"></span><br><span class="line">                    try &#123;</span><br><span class="line">                        String topic = msg.getTopic();</span><br><span class="line">                        String tags = msg.getTags();</span><br><span class="line">                        String msgBody =  new String(msg.getBody(),&quot;utf-8&quot;);</span><br><span class="line">                        System.out.println(&quot;收到消息--&quot; + &quot; topic:&quot; + topic + &quot; ,tags:&quot; + tags + &quot; ,msg:&quot; +msgBody);</span><br><span class="line">//                        System.out.println();</span><br><span class="line">                    &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">//有异常抛出来，不要全捕获了，这样保证不能消费的消息下次重推，每次重新消费间隔：10s,30s,1m,2m,3m</span><br><span class="line">                        return ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        consumer.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Consumer Started.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>步骤</strong></p><blockquote><p>1.同producer 需要设置 producer group一样，消费者同样需要设置 consumer group name;<br>2.指定nameserver的地址，需要同要处理的producer的nameserver的地址相同；<br>3.指定消费者要消费的位置（通常设置为：从头开始 CONSUME_FROM_FIRST_OFFSET）；<br>4.订阅要处理的主题 topic 及 细分 tags；<br>5.注册监听器开始监听broker中是否有消息队列，编写消费逻辑；如果没有return success ，consumer会重新消费该消息，直到return success。<br>6.启动消费者实例。</p></blockquote><h1 id="4-运行结果"><a href="#4-运行结果" class="headerlink" title="4.运行结果"></a>4.运行结果</h1><p><strong>启动顺序</strong></p><blockquote><p>先启动 consumer实例，再启动 producer 实例；默认 是单线程的一条一条的去处理消息，原子性，保证了消息处理的实时性。</p></blockquote><p><strong>持久化</strong><br>RocketMQ是一定会把消息持久化的。</p><p><strong>单批次消息消费的数量</strong></p><p>如果是先启动 consumer，后启动 producer，理论上rocketmq发送的消息的数量都是1。<br>当然，如果有消息挤压的情况下，设置 consumer.setConsumeMessageBatchMaxSize(10)，可能会出现一次消息的消费数量可能是多条，这里设置的数量是 10，是最大条数是10，而不是每次批量消费的数量都是10.</p><p>结果：<br>1.先启动 Consumer，后启动 Producer，会发现每次的过来的消息数量仍然是1，说明没有消息挤压，实时消费；</p><p>2.先启动 Producer,发送一定数量的消息，然后再启动 Consumer,会发现，消费者这边接收到的消息的数量是不固定的。</p><hr><p>本次的rocketmq，简单入门就到这里，大家再运行代码的时候，可以看看重要类的属性、方法等，加深了解。</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> hello world </tag>
            
            <tag> 入门 </tag>
            
            <tag> 上手 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列04--Broker 配置文件</title>
      <link href="/2018/08/28/RocketMQ%E7%B3%BB%E5%88%9704--Broker%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/2018/08/28/RocketMQ%E7%B3%BB%E5%88%9704--Broker%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h1 id="Broker配置"><a href="#Broker配置" class="headerlink" title="Broker配置"></a>Broker配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#所属集群名字</span><br><span class="line">#注意:一个集群中如果有多个master，那么每个master配置的 brokerClusterName 名字应该一样，要不然识别不了对方，不知道是一个集群内部的</span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line">#broker名字，注意此处不同的配置文件填写的不一样</span><br><span class="line">#建议:按配置文件文件名来匹配</span><br><span class="line">brokerName=broker-a|broker-b</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId=0</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">#此处nameserver跟host配置相匹配，9876为默认rk服务默认端口</span><br><span class="line">#broker启动时会跟nameserver建一个长连接，broker通过长连接才会向nameserver发新建的topic主题，然后java的客户端才能跟nameserver端发起长连接，向nameserver索取topic，找到topic主题之后，判断其所属的broker，建立长连接进行通讯，这是一个至关重要的路由的概念，重点，也是区别于其它版本的一个重要特性</span><br><span class="line">namesrvAddr=rocketmq-nameserv1:9876;rocketmq-nameserv2:9876</span><br><span class="line"></span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort=10911</span><br><span class="line"></span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen=04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">fileReservedTime=120</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line">#destroyMapedFileIntervalForcibly=120000</span><br><span class="line">#redeleteHangedFileInterval=120000</span><br><span class="line">#检测物理文件磁盘空间</span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"></span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/usr/local/rocketmq/store</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">#消息实际存储位置，和ConsumeQueue是mq的核心存储概念，之前搭建2m环境的时候创建在store下面，用于数据存储，consumequeue是一个逻辑的概念，消息过来之后，consumequeue并不是把消息所有保存起来，而是记录一个数据的位置，记录好之后再把消息存到commitlog文件里</span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/usr/local/rocketmq/store/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span><br><span class="line">#abort 文件存储路径</span><br><span class="line">abortFile=/usr/local/rocketmq/store/abort</span><br><span class="line"></span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize=65536</span><br><span class="line">#flushCommitLogLeastPages=4</span><br><span class="line">#flushConsumeQueueLeastPages=2</span><br><span class="line">#flushCommitLogThoroughInterval=10000</span><br><span class="line">#flushConsumeQueueThoroughInterval=60000</span><br><span class="line"></span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"></span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">#checkTransactionMessageEnable=false</span><br><span class="line"></span><br><span class="line">#发消息线程池数量</span><br><span class="line">#sendMessageThreadPoolNums=128</span><br><span class="line">#拉消息线程池数量</span><br><span class="line">#pullMessageThreadPoolNums=128</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> Broker </tag>
            
            <tag> 配置文件 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列03--双主模式集群搭建(2m-noslave)</title>
      <link href="/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9703--%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9703--%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>　　在上一篇中,我们介绍了 rocketmq 的支持的集群方式,并且介绍了各自的优缺点。本次以多Master集群模式为例搭建一个双机Master的RocketMQ集群环境（<strong>2m-noslave</strong>集群模式）。</p><h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h1><p>　　因为rocketmq底层是 Java 语言编写，所以搭建此环境的服务器，必须已经安装和配置了 JDK。</p><h2 id="1-1-工具下载"><a href="#1-1-工具下载" class="headerlink" title="　  1.1 工具下载"></a>　  1.1 工具下载</h2><p>　　这里，我提供了本次安装rocketmq所用到的工具包。分别是：<br><img src="http://upload-images.jianshu.io/upload_images/11560519-fc516f3822f919d7" alt=""></p><p>提供了<a href="https://pan.baidu.com/s/1N4QrAgNrdwi3PacqqwxYUg#list/path=%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8C%85%2Frocketmq-software&amp;parentPath=%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8C%85" title="rocketmq安装包" target="_blank" rel="noopener">百度云盘</a>（密码：wdvm）。大家可自行下载。</p><h2 id="1-2-服务器规划"><a href="#1-2-服务器规划" class="headerlink" title="　  1.2 服务器规划"></a>　  1.2 服务器规划</h2><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">IP</th><th style="text-align:center">角色</th><th style="text-align:center">模式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">192.168.81.132</td><td style="text-align:center">nameServer1,brokerServer1</td><td style="text-align:center">Master1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">192.168.81.134</td><td style="text-align:center">nameServer2,brokerServer2</td><td style="text-align:center">Master2</td></tr></tbody></table><h2 id="1-3-基础环境搭建"><a href="#1-3-基础环境搭建" class="headerlink" title="　  1.3 基础环境搭建"></a>　  1.3 基础环境搭建</h2><ol><li>将压缩包上传到2台机器</li></ol><blockquote><p>我这里使用root用户登录,把软件包放在根目录下。</p></blockquote><ol start="2"><li>检查是否安装了JDK,如果没有安装过,则先进行安装和配置JDK(参考 <a href="https://blog.csdn.net/o135248/article/details/79931693" target="_blank" rel="noopener">linux下JDK的安装</a>)<br>3.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#检查JDK是否已安装</span><br><span class="line">[root@localhost ~]# java -version</span><br><span class="line">java version &quot;1.8.0_11&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_11-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.11-b03, mixed mode)</span><br></pre></td></tr></table></figure><h1 id="2-集群搭建"><a href="#2-集群搭建" class="headerlink" title="2.集群搭建　"></a>2.集群搭建　</h1><blockquote><p>说明：安装时，请按照自己的实际服务器环境替换相应的IP即可。</p></blockquote><h2 id="2-1-Hosts-添加信息"><a href="#2-1-Hosts-添加信息" class="headerlink" title="　  2.1 Hosts 添加信息"></a>　  2.1 Hosts 添加信息</h2><p>这里为了方便我们将 nameserver 和 broker 配置到了一台机器上,可以分开进行配置.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#编辑2台机器的hosts文件</span><br><span class="line">vim  /etc/hosts</span><br><span class="line"></span><br><span class="line">#配置如下的信息:</span><br><span class="line">192.168.81.132 rocketmq-nameserv1</span><br><span class="line">192.168.81.132 rocketmq-master1</span><br><span class="line"></span><br><span class="line">192.168.81.134 rocketmq-nameserv2</span><br><span class="line">192.168.81.134 rocketmq-master2</span><br><span class="line"></span><br><span class="line">#重启网卡</span><br><span class="line">service network restart</span><br></pre></td></tr></table></figure><h2 id="2-2-解压压缩包-2台机器"><a href="#2-2-解压压缩包-2台机器" class="headerlink" title="　  2.2 解压压缩包(2台机器)"></a>　  2.2 解压压缩包(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#解压 alibaba-rocketmq-3.2.6.tar.gz 至 /usr/local</span><br><span class="line">tar -zxvf alibaba-rocketmq-3.2.6.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">#重命名(带上版本号)</span><br><span class="line">mv alibaba-rocketmq alibaba-rocketmq-3.2.6</span><br><span class="line"></span><br><span class="line">#创建软连接</span><br><span class="line">ln -s alibaba-rocketmq-3.2.6 rocketmq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ls看下</span><br><span class="line">rocketmq -&gt; alibaba-rocketmq-3.2.6</span><br></pre></td></tr></table></figure><h2 id="2-3-创建存储路径-2台机器"><a href="#2-3-创建存储路径-2台机器" class="headerlink" title="　  2.3 创建存储路径(2台机器)"></a>　  2.3 创建存储路径(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/rocketmq/store</span><br><span class="line">mkdir /usr/local/rocketmq/store/commitlog</span><br><span class="line">mkdir /usr/local/rocketmq/store/consumequeue</span><br><span class="line">mkdir /usr/local/rocketmq/store/index</span><br><span class="line"></span><br><span class="line">#或者执行下面的一条命令：</span><br><span class="line">mkdir -p /usr/local/rocketmq/store/&#123;commitlog,consumequeue,index&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-RocketMQ配置文件-2台机器"><a href="#2-4-RocketMQ配置文件-2台机器" class="headerlink" title="　  2.4 RocketMQ配置文件(2台机器)"></a>　  2.4 RocketMQ配置文件(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/rocketmq/conf/2m-noslave/broker-a.properties</span><br><span class="line">vim /usr/local/rocketmq/conf/2m-noslave/broker-b.properties</span><br></pre></td></tr></table></figure><p>删除里面的配置，粘贴下面的配置信息。(注意更改brokerName 和 namesrvAddr 的配置)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">#所属集群名字</span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line">#broker名字，注意此处不同的配置文件填写的不一样</span><br><span class="line">brokerName=broker-a|broker-b</span><br><span class="line">#0 表示 Master， &gt;0 表示 Slave</span><br><span class="line">brokerId=0</span><br><span class="line">#nameServer地址，分号分割</span><br><span class="line">namesrvAddr=rocketmq-nameserv1:9876;rocketmq-nameserv2:9876</span><br><span class="line"></span><br><span class="line">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span><br><span class="line">autoCreateTopicEnable=true</span><br><span class="line">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span><br><span class="line">autoCreateSubscriptionGroup=true</span><br><span class="line">#Broker 对外服务的监听端口</span><br><span class="line">listenPort=10911</span><br><span class="line"></span><br><span class="line">#删除文件时间点，默认凌晨 4点</span><br><span class="line">deleteWhen=04</span><br><span class="line">#文件保留时间，默认 48 小时</span><br><span class="line">fileReservedTime=120</span><br><span class="line">#commitLog每个文件的大小默认1G</span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line">#destroyMapedFileIntervalForcibly=120000</span><br><span class="line">#redeleteHangedFileInterval=120000</span><br><span class="line">#检测物理文件磁盘空间</span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"></span><br><span class="line">#存储路径</span><br><span class="line">storePathRootDir=/usr/local/rocketmq/store</span><br><span class="line">#commitLog 存储路径</span><br><span class="line">storePathCommitLog=/usr/local/rocketmq/store/commitlog</span><br><span class="line">#消费队列存储路径存储路径</span><br><span class="line">storePathConsumeQueue=/usr/local/rocketmq/store/consumequeue</span><br><span class="line">#消息索引存储路径</span><br><span class="line">storePathIndex=/usr/local/rocketmq/store/index</span><br><span class="line">#checkpoint 文件存储路径</span><br><span class="line">storeCheckpoint=/usr/local/rocketmq/store/checkpoint</span><br><span class="line">#abort 文件存储路径</span><br><span class="line">abortFile=/usr/local/rocketmq/store/abort</span><br><span class="line"></span><br><span class="line">#限制的消息大小</span><br><span class="line">maxMessageSize=65536</span><br><span class="line">#flushCommitLogLeastPages=4</span><br><span class="line">#flushConsumeQueueLeastPages=2</span><br><span class="line">#flushCommitLogThoroughInterval=10000</span><br><span class="line">#flushConsumeQueueThoroughInterval=60000</span><br><span class="line"></span><br><span class="line">#Broker 的角色</span><br><span class="line">#- ASYNC_MASTER 异步复制Master</span><br><span class="line">#- SYNC_MASTER 同步双写Master</span><br><span class="line">#- SLAVE</span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"></span><br><span class="line">#刷盘方式</span><br><span class="line">#- ASYNC_FLUSH 异步刷盘</span><br><span class="line">#- SYNC_FLUSH 同步刷盘</span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">#checkTransactionMessageEnable=false</span><br><span class="line"></span><br><span class="line">#发消息线程池数量</span><br><span class="line">#sendMessageThreadPoolNums=128</span><br><span class="line">#拉消息线程池数量</span><br><span class="line">#pullMessageThreadPoolNums=128</span><br></pre></td></tr></table></figure><h2 id="2-5-修改日志配置文件-2台机器"><a href="#2-5-修改日志配置文件-2台机器" class="headerlink" title="　  2.5 修改日志配置文件(2台机器)"></a>　  2.5 修改日志配置文件(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#创建日志目录logs</span><br><span class="line">mkdir -p /usr/local/rocketmq/logs</span><br><span class="line">#修改日志配置文件</span><br><span class="line">cd /usr/local/rocketmq/conf &amp;&amp; sed -i &apos;s#$&#123;user.home&#125;#/usr/local/rocketmq#g&apos; *.xml</span><br></pre></td></tr></table></figure><h2 id="2-6-修改启动脚本参数-2台机器"><a href="#2-6-修改启动脚本参数-2台机器" class="headerlink" title="　  2.6 修改启动脚本参数(2台机器)"></a>　  2.6 修改启动脚本参数(2台机器)</h2><p>切换到 /usr/local/devTool/rocketmq/bin 目录下，我们发现这里存在 rocketmq的各种命令（win linux）。启动rocketmq，应该先启动nameserver,再启动broker。而broker的启动需要合适的JVM内存配置，阿里官方推荐的是4G。可以根据实际生产环境进行合理配置。</p><p><strong>编辑文件 runbroker.sh</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/rocketmq/bin/runbroker.sh</span><br><span class="line"></span><br><span class="line">#修改 runbroker 的配置 </span><br><span class="line">#===========================================================================================</span><br><span class="line"># JVM Configuration</span><br><span class="line">#===========================================================================================</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:PermSize=128m -XX:MaxPermSize=320m&quot;</span><br></pre></td></tr></table></figure></p><p><strong>编辑文件 runserver.sh</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/local/rocketmq/bin/runserver.sh</span><br><span class="line"></span><br><span class="line">#修改配置</span><br><span class="line">#===========================================================================================</span><br><span class="line"># JVM Configuration</span><br><span class="line">#===========================================================================================</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m -XX:PermSize=128m -XX:MaxPermSize=320m&quot;</span><br></pre></td></tr></table></figure><h2 id="2-7-启动NameServer-2台机器"><a href="#2-7-启动NameServer-2台机器" class="headerlink" title="　  2.7 启动NameServer(2台机器)"></a>　  2.7 启动NameServer(2台机器)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/rocketmq/bin</span><br><span class="line">#后台启动nameserver</span><br><span class="line">nohup sh mqnamesrv &amp;</span><br><span class="line"></span><br><span class="line">#查看namesrv日志</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><h2 id="2-8-启动BrokerServer-A"><a href="#2-8-启动BrokerServer-A" class="headerlink" title="　  2.8 启动BrokerServer A"></a>　  2.8 启动BrokerServer A</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -c /usr/local/rocketmq/conf/2m-noslave/broker-a.properties &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">#查看进程及日志</span><br><span class="line">jps</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/broker.log</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><h2 id="2-9-启动BrokerServer-B"><a href="#2-9-启动BrokerServer-B" class="headerlink" title="　  2.9 启动BrokerServer B"></a>　  2.9 启动BrokerServer B</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh mqbroker -c /usr/local/rocketmq/conf/2m-noslave/broker-b.properties &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">tail -f -n 500 /usr/local/rocketmq/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure><h2 id="2-10-安装-RocketMq-Console"><a href="#2-10-安装-RocketMq-Console" class="headerlink" title="　  2.10 安装 RocketMq Console"></a>　  2.10 安装 RocketMq Console</h2><ol><li><p><strong>解压缩 tomcat 到 /usr/local目录下，并且重命名为 rocketmq-console-tomcat.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#解压缩 tomcat 到 /usr/local目录下</span><br><span class="line">tar -zxvf apache-tomcat-8.5.30.tar.gz -C /usr/local/</span><br><span class="line"></span><br><span class="line">#重命名为 rocketmq-console-tomcat</span><br><span class="line">cd /usr/local</span><br><span class="line">mv apache-tomcat-8.5.30/ rocketmq-console-tomcat</span><br></pre></td></tr></table></figure></li><li><p><strong>安装 rocketmq-console.war，修改配置并启动</strong></p></li></ol><p>我这里将 rocketmq-console安装在【134】的机器上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#将war包放到 刚解压缩的tomcat 的webapps目录下</span><br><span class="line">cp rocketmq-console.war /usr/local/rocketmq-console-tomcat/webapps/</span><br><span class="line"></span><br><span class="line">#解压缩war包</span><br><span class="line">unzip rocketmq-console.war -d rocketmq-console</span><br><span class="line"></span><br><span class="line">#修改配置</span><br><span class="line">vim /usr/local/rocketmq-console-tomcat/webapps/rocketmq-console/WEB-INF/classes/config.properties </span><br><span class="line">修改 rocketmq.namesrv.addr 项的内容为：</span><br><span class="line">rocketmq.namesrv.addr = rocketmq-nameserv1:9876;rocketmq-nameserv2:9876</span><br><span class="line"></span><br><span class="line">#切换到tomcat的bin路径下，启动tomcat,浏览器访问</span><br><span class="line">cd /usr/local/rocketmq-console-tomcat/bin/</span><br><span class="line">./startup.sh</span><br><span class="line"></span><br><span class="line">#启动日志</span><br><span class="line">tail -f -n 500 /usr/local/rocketmq-console-tomcat/logs/catalina.out </span><br><span class="line"></span><br><span class="line">#浏览器访问：（确认防火墙已关闭）</span><br><span class="line">http://192.168.81.134:8080/rocketmq-console</span><br></pre></td></tr></table></figure><p>效果图：</p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-f6910b13c30e3f90.png" alt=""></p><h2 id="2-11-数据清理"><a href="#2-11-数据清理" class="headerlink" title="　  2.11 数据清理"></a>　  2.11 数据清理</h2><p>启动时，先启动 nameserver,再启动 broker;</p><p>关闭时，则相反，先关闭 broker,再 关闭 nameserver(早起晚归)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/rocketmq/bin</span><br><span class="line">sh mqshutdown broker</span><br><span class="line">sh mqshutdown namesrv</span><br><span class="line"></span><br><span class="line">##等待停止</span><br><span class="line">rm -rf /usr/local/devTool/rocketmq/store</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store/commitlog</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store/consumequeue</span><br><span class="line">mkdir /usr/local/devTool/rocketmq/store/index</span><br></pre></td></tr></table></figure></p><p>到此,2m-noslave集群模式已搭建完毕,下一篇,我们会对 broker的配置文件中的配置项做介绍,这样有利于后期的更自如得学习.</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 集群 </tag>
            
            <tag> 2m-noslave </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列02--集群构建模型</title>
      <link href="/2018/08/26/RocketMQ%E7%B3%BB%E5%88%9702--%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/26/RocketMQ%E7%B3%BB%E5%88%9702--%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>　　本篇主要是对 RocketMQ的集群搭建的几种方式做简单介绍及其优缺点，便于自己在项目中，根据自己的业务需要做技术选型。在上一篇中，我们介绍了RocketMQ的物理部署结构，知道了它是由NameServer、Producer、Consumer和Broker来组成，各自的作用也做了说明。而这篇介绍的集群的搭建，这里的“集群”指的就是 Broker集群的搭建。</p><p>　　Broker 分为 Master 和 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master，Master 和 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerId 来定义，BrokerId为 0 表示 Master，非 0 表示 Slave。Master 也可以部署多个。</p><p>​　　推荐的几种 Broker 集群部署方式，这里的 Slave 不可写，但可读，类似于 Mysql 主备方式。</p><h1 id="1-单-Master"><a href="#1-单-Master" class="headerlink" title="1.单 Master"></a>1.单 Master</h1><blockquote><p>　　即系统所有的消息都存储在一个 Broker上，这种方式风险较大，一旦 Broker 重启或者宕机时，会导致整个服务不可用。这种只适合入门helloworld实例，强烈不建议线上环境使用。</p></blockquote><h1 id="2-多-Master-模式"><a href="#2-多-Master-模式" class="headerlink" title="2.多 Master 模式"></a>2.多 Master 模式</h1><blockquote><p>​    一个集群无Slave，全是Master，例如2个Master或者3个Master。</p></blockquote><p><strong>优点</strong></p><blockquote><p>​　　配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。</p></blockquote><p><strong>缺点</strong></p><blockquote><p>​    单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响。</p></blockquote><p>　　这里介绍下【异步刷盘】、【同步刷盘】、【Broker间数据同步/复制】。</p><p>【异步刷盘】：ASYNC_FLUSH,生产者发送的每一条消息并不是立即保存到磁盘,而是暂时缓存起来,然后就返回生产者成功。然后再异步的将缓存数据保存到磁盘，这里有2种情况：</p><pre><code>1.定期将缓存种更新的数据进行刷盘；2.当缓存中更新的数据条数达到某一设定值进行刷盘。</code></pre><p>这种方式会存在消息丢失（场景：在还未来得及同步到磁盘的时候宕机），但是性能很好，rokectmq默认是这种模式。</p><p>【同步刷盘】：生产者发送的每一条消息都在保存到磁盘成功后才返回告诉生产者成功。这种方式不会存在消息丢失的问题，但是有很大的磁盘IO开销，性能有一定影响。</p><p>【Broker Replication】:Broker间数据同步/复制。集群环境下需要部署多个Broker，Broker分2种角色：Master和Slave。</p><pre><code>1.一种是master,Master即可以读，也可以写，设置brokerId=0,只能设置一个。2.另外一种是slave,只允许读，其brokerId为非0。</code></pre><p>　　一个master与多个slave通过指定相同的brokerName被归为一个 broker set（broker集群）。通常生产环境中，我们至少需要2个broker Set。Broker Replication指的就是slave 获取或者复制master的数据。</p><pre><code>1.sync Broker: 生产者发送的每一条消息都至少同步复制到一个slave后才返回告诉生产者成功，即&quot;同步双写&quot;；2.Async Broker: 生产者发送的每一条消息只要写入master就返回告诉生产者成功，然后再&quot;异步复制&quot;到slave.</code></pre><h1 id="3-多-Master-多-Slave-模式，异步复制"><a href="#3-多-Master-多-Slave-模式，异步复制" class="headerlink" title="3.多 Master 多 Slave 模式，异步复制"></a>3.多 Master 多 Slave 模式，异步复制</h1><blockquote><p>每个Master配置一个或多个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟，毫秒级。</p></blockquote><p><strong>优点</strong></p><blockquote><p>　　即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为Master宕机后，消费者仍然可以从Slave消费，此过程对应用透明。不需要人工干预。性能同多Master模式几乎一样。</p></blockquote><p><strong>缺点</strong></p><blockquote><p>　　Master宕机，磁盘损坏情况，会丢失少量消息。当producer向master发送完数据时，这时候还没等到master向slave做同步，master宕机了，则在master上的数据会丢失，消费者在salve上消费不到刚刚的消息。</p></blockquote><h1 id="4-多-Master-多-Slave-模式，同步双写"><a href="#4-多-Master-多-Slave-模式，同步双写" class="headerlink" title="4.多 Master 多 Slave 模式，同步双写"></a>4.多 Master 多 Slave 模式，同步双写</h1><blockquote><p>每个Master配置一个或多个Slave，有多对Master-Slave，HA采用同步双写方式，主备都写成功，向应用返回成功。</p></blockquote><p><strong>优点</strong></p><blockquote><p>数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高。</p></blockquote><p><strong>缺点</strong></p><blockquote><p> 　　性能比异步复制模式略低，大约低10%左右，发送单个消息的RT会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。</p></blockquote><p>在下篇中，我们会进行 2-master集群环境的搭建和配置。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.《RocketMQ用户指南》</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列01--简介及概念</title>
      <link href="/2018/08/25/RocketMQ%E7%B3%BB%E5%88%9701--%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/08/25/RocketMQ%E7%B3%BB%E5%88%9701--%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h1 id="1-RocketMQ是什么？"><a href="#1-RocketMQ是什么？" class="headerlink" title="1.RocketMQ是什么？"></a>1.RocketMQ是什么？</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB1rdyvPXXXXXcBapXXXXXXXXXX" alt=""></p><p>RocketMQ：</p><ul><li><p>是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式的特点；</p></li><li><p>Producer、Consumer、队列都可以分布式部署；</p></li><li><p>Producer向一些队列轮流发送消息，这些队列集合称为”Topic”。Consumer如果做广播消费，则一个Consumer实例消费这个Topic对应的所有的队列，如果是集群消费，则多个Consumer实例平均消费这个topic队列集合；</p></li><li><p>保证严格的消息顺序；</p></li><li><p>提供丰富的消息拉去模式；</p></li><li><p>高效的订阅者水平扩展能力；</p></li><li><p>实时的消息订阅机制；</p></li><li><p>亿级消息堆积能力。</p><p>RocketMQ是Java语言编写，基于通信框架Netty。</p></li></ul><h1 id="2-RocketMQ物理部署结构"><a href="#2-RocketMQ物理部署结构" class="headerlink" title="2.RocketMQ物理部署结构"></a>2.RocketMQ物理部署结构</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB18GKUPXXXXXXRXFXXXXXXXXXX" alt=""></p><p>从上图中，我们可以看到消息队列的主要角色有：</p><ul><li>NameServer:无状态节点，供 Producer 和 Consumer 获取Broker地址。</li><li>Broker:MQ的服务器，消息的中转角色，负责存储和转发消息。</li><li>Producer:发送消息到消息队列(消息生产者)。</li><li>Consumer:从消息队列接收消息（消息消费者）。</li></ul><p>RocketMQ网络部署特点：</p><ul><li><p>　　NameServer是一个无状态的节点，可集群部署，节点之间无任何信息同步。</p></li><li><p>　　Broker:分为Master和Slave.一个Master可以有多个Slave,但是一个Slave只能对应一个Master.Master和Slave的对应关系是通过指定 “相同的BrokerName,不同的BrokerId”来定义。BrokerId=0表示Master,非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有的NameServer。</p></li><li><p>　　Producer与NamerServer中的任意一个节点建立长连接，定期从NameServer中取Topic的路由信息，并与提供Topic服务的Master建立长连接，定时向Master发送心跳。可集群部署。</p></li><li><p>　　Consumer与NamerServer中的任意一个节点建立长连接，定期从NameServer中取Topic的路由信息，并与提供Topic服务的Master和Slave建立长连接，且定时向Master和Slave发送心跳。Consumer既可以从 Master 订阅消息，也可以从 Slave 订阅消息，订阅规则由 Broker 配置决定。</p></li></ul><h1 id="3-RocketMQ逻辑部署结构"><a href="#3-RocketMQ逻辑部署结构" class="headerlink" title="3.RocketMQ逻辑部署结构"></a>3.RocketMQ逻辑部署结构</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB1lEPePXXXXXX8XXXXXXXXXXXX" alt=""></p><p><strong>Producer Group</strong></p><blockquote><p>​　　用来表示一个収送消息应用，一个 Producer Group 下包含多个 Producer 实例，可以是多台机器，也可以是一台机器的多个迕程，戒者一个迕程的多个 Producer 对象。一个 Producer Group 可以収送多个 Topic消息。作用有：</p><p>​    1.标识一类producer;</p><p>​    2.查询返个収送消息应用下有多个 Producer 实例;</p><p>​    3.収送分布式事务消息时，如果 Producer 中途意外宕机，Broker 会主劢回调 Producer Group 内的任意一台机器来确讣事务状态。</p></blockquote><p><strong>Consumer Group</strong></p><blockquote><p>​　　用来表示一个消费消息应用，一个 Consumer Group 下包含多个 Consumer 实例，可以是多台机器，也可以是多个迕程，戒者是一个迕程的多个 Consumer 对象。一个 Consumer Group 下的多个 Consumer 以均摊方式消费消息，如果设置为广播方式，那举返个 Consumer Group 下的每个实例都消费全量数据。</p></blockquote><ul><li><p>Topic：消息的逻辑管理单位；</p></li><li><p>Message Queue:消息物理管理单位，一个Topic可以有若干个Queue;</p></li><li><p>Message:消息</p><ul><li>body：消息体，用于携带消息的内容。</li><li>key:消息key,用于区分不同的消息，一般是业务id信息，根据key可查询到消息；</li><li>tag:消息tag,用于不同的订阅者来过滤消息。</li></ul><p>​</p></li></ul><h1 id="4-概念术语"><a href="#4-概念术语" class="headerlink" title="4.概念术语"></a><strong>4</strong>.概念术语</h1><ul><li>广播消费</li></ul><blockquote><p>　　 一条消息被多个 Consumer 消费，即使返些 Consumer 属亍同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次，广播消费中的 Consumer Group 概念可以讣为在消息划分方面无意义。</p></blockquote><ul><li>集群消费</li></ul><blockquote><p>​　　一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个Consumer Group 有 3 个实例（可能是 3 个迕程，戒者 3 台机器），那举每个实例只消费其中的 3 条消息。在 CORBA Notification 规范中，无此消费方式。<br>​    在 JMS 规范中，JMS point-to-point model 类似，但是 RocketMQ 的集群消费功能大等于 PTP 模型。<br>​    因为 RocketMQ 单个 Consumer Group 内的消费者类似于 PTP，但是一个 Topic/Queue 可以被多个 Consumer Group 消费。</p></blockquote><ul><li>顺序消息</li></ul><blockquote><p>　　消费消息的顺序要同发送消息的顺序一致，在 RocketMQ 中，主要指的是局部顺序，即一类消息为满足顺序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 发送的顺序去消费消息。</p></blockquote><ul><li>普通顺序消息</li></ul><blockquote><p>​    顺序消息的一种，正常情况下可以保证完全的顺序消息，但是一旦发生通信异常，Broker 重启，由于队列总数发生发化，哈希取模后定位的队列会发化，产生短暂的消息顺序不一致。<br>如果业务能容忍在集群异常情况（如某个 Broker 宕机或者重启）下，消息短暂的乱序，使用普通顺序方式比较合适。</p></blockquote><ul><li>严格的顺序消息</li></ul><blockquote><p>​　　顺序消息的一种，无论正常异常情况都能保证顺序，但是牺牲了分布式 Failover 特性，即 Broker 集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。</p></blockquote><blockquote><p>　　如果服务器部署为同步双写模式，此缺陷可通过备机自动切换为主避免，不过仍然会存在几分钟的服务不可用。（依赖同步双写，主备自动切换，自动切换功能目前还未实现）<br>目前已知的应用只有数据库 binlog 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息。</p></blockquote><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h1><p>1.RocketMQ 开发指南（V3.2.4）</p><p>2.<a href="https://blog.csdn.net/gwd1154978352/article/details/80654314" target="_blank" rel="noopener">RocketMQ——初识RocketMQ</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq </tag>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>读书</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>resources</title>
      <link href="/resources/index.html"/>
      <url>/resources/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>大家好，我是”李乔子的酒”。欢迎来到我的个人技术博客。</p><p>我是一个Java入门2年的”小猿”,今后会在本博客写下自己的工作和生活日常.</p><p>让我们一起,变得更加优秀!</p><h4 id="历史纪录"><a href="#历史纪录" class="headerlink" title="历史纪录"></a>历史纪录</h4><table><thead><tr><th>日期</th><th>优化记录</th><th>完成日期</th><th>责任人</th></tr></thead><tbody><tr><td>2018-08-19</td><td>整理读书资源,对读书页面中的书籍增加 “百度云盘”下载</td><td></td><td>lemon</td></tr><tr><td>2018-08-19</td><td>新增 “Tools”工具页面,提供日常及开发常用工具一站式下载</td><td></td><td>lemon</td></tr><tr><td>2018-08-19</td><td>申请 “七牛云”存储,提供文件存储功能</td><td></td><td>lemon</td></tr></tbody></table>]]></content>
    </entry>
    
  
</search>
