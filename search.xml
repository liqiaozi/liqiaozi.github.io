<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>RocketMQ系列02--集群构建模型</title>
      <link href="/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9702--%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9702--%E9%9B%86%E7%BE%A4%E6%9E%84%E5%BB%BA%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>　　本篇主要是对 RocketMQ的集群搭建的几种方式做简单介绍及其优缺点，便于自己在项目中，根据自己的业务需要做技术选型。在上一篇中，我们介绍了RocketMQ的物理部署结构，知道了它是由NameServer、Producer、Consumer和Broker来组成，各自的作用也做了说明。而这篇介绍的集群的搭建，这里的“集群”指的就是 Broker集群的搭建。</p><p>　　Broker 分为 Master 和 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master，Master 和 Slave 的对应关系通过指定相同的 BrokerName，不同的 BrokerId 来定义，BrokerId为 0 表示 Master，非 0 表示 Slave。Master 也可以部署多个。</p><p>​　　推荐的几种 Broker 集群部署方式，这里的 Slave 不可写，但可读，类似于 Mysql 主备方式。</p><h1 id="1-单-Master"><a href="#1-单-Master" class="headerlink" title="1.单 Master"></a>1.单 Master</h1><blockquote><p>　　即系统所有的消息都存储在一个 Broker上，这种方式风险较大，一旦 Broker 重启或者宕机时，会导致整个服务不可用。这种只适合入门helloworld实例，强烈不建议线上环境使用。</p></blockquote><h1 id="2-多-Master-模式"><a href="#2-多-Master-模式" class="headerlink" title="2.多 Master 模式"></a>2.多 Master 模式</h1><blockquote><p>​    一个集群无Slave，全是Master，例如2个Master或者3个Master。</p></blockquote><p><strong>优点</strong></p><blockquote><p>​　　配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）。性能最高。</p></blockquote><p><strong>缺点</strong></p><blockquote><p>​    单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到受到影响。</p></blockquote><p>　　这里介绍下【异步刷盘】、【同步刷盘】、【Broker间数据同步/复制】。</p><p>【异步刷盘】：ASYNC_FLUSH,生产者发送的每一条消息并不是立即保存到磁盘,而是暂时缓存起来,然后就返回生产者成功。然后再异步的将缓存数据保存到磁盘，这里有2种情况：</p><pre><code>1.定期将缓存种更新的数据进行刷盘；2.当缓存中更新的数据条数达到某一设定值进行刷盘。</code></pre><p>这种方式会存在消息丢失（场景：在还未来得及同步到磁盘的时候宕机），但是性能很好，rokectmq默认是这种模式。</p><p>【同步刷盘】：生产者发送的每一条消息都在保存到磁盘成功后才返回告诉生产者成功。这种方式不会存在消息丢失的问题，但是有很大的磁盘IO开销，性能有一定影响。</p><p>【Broker Replication】:Broker间数据同步/复制。集群环境下需要部署多个Broker，Broker分2种角色：Master和Slave。</p><pre><code>1.一种是master,Master即可以读，也可以写，设置brokerId=0,只能设置一个。2.另外一种是slave,只允许读，其brokerId为非0。</code></pre><p>　　一个master与多个slave通过指定相同的brokerName被归为一个 broker set（broker集群）。通常生产环境中，我们至少需要2个broker Set。Broker Replication指的就是slave 获取或者复制master的数据。</p><pre><code>1.sync Broker: 生产者发送的每一条消息都至少同步复制到一个slave后才返回告诉生产者成功，即&quot;同步双写&quot;；2.Async Broker: 生产者发送的每一条消息只要写入master就返回告诉生产者成功，然后再&quot;异步复制&quot;到slave.</code></pre><h1 id="3-多-Master-多-Slave-模式，异步复制"><a href="#3-多-Master-多-Slave-模式，异步复制" class="headerlink" title="3.多 Master 多 Slave 模式，异步复制"></a>3.多 Master 多 Slave 模式，异步复制</h1><blockquote><p>每个Master配置一个或多个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟，毫秒级。</p></blockquote><p><strong>优点</strong></p><blockquote><p>　　即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，因为Master宕机后，消费者仍然可以从Slave消费，此过程对应用透明。不需要人工干预。性能同多Master模式几乎一样。</p></blockquote><p><strong>缺点</strong></p><blockquote><p>　　Master宕机，磁盘损坏情况，会丢失少量消息。当producer向master发送完数据时，这时候还没等到master向slave做同步，master宕机了，则在master上的数据会丢失，消费者在salve上消费不到刚刚的消息。</p></blockquote><h1 id="4-多-Master-多-Slave-模式，同步双写"><a href="#4-多-Master-多-Slave-模式，同步双写" class="headerlink" title="4.多 Master 多 Slave 模式，同步双写"></a>4.多 Master 多 Slave 模式，同步双写</h1><blockquote><p>每个Master配置一个或多个Slave，有多对Master-Slave，HA采用同步双写方式，主备都写成功，向应用返回成功。</p></blockquote><p><strong>优点</strong></p><blockquote><p>数据与服务都无单点，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高。</p></blockquote><p><strong>缺点</strong></p><blockquote><p> 　　性能比异步复制模式略低，大约低10%左右，发送单个消息的RT会略高。目前主宕机后，备机不能自动切换为主机，后续会支持自动切换功能。</p></blockquote><p>在下篇中，我们会进行 2-master集群环境的搭建和配置。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.《RocketMQ用户指南》</p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq ; 集群 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列01--简介及概念</title>
      <link href="/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9701--%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5/"/>
      <url>/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9701--%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5/</url>
      <content type="html"><![CDATA[<h1 id="1-RocketMQ是什么？"><a href="#1-RocketMQ是什么？" class="headerlink" title="1.RocketMQ是什么？"></a>1.RocketMQ是什么？</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB1rdyvPXXXXXcBapXXXXXXXXXX" alt=""></p><p>RocketMQ：</p><ul><li><p>是一个队列模型的消息中间件，具有高性能、高可靠、高实时、分布式的特点；</p></li><li><p>Producer、Consumer、队列都可以分布式部署；</p></li><li><p>Producer向一些队列轮流发送消息，这些队列集合称为”Topic”。Consumer如果做广播消费，则一个Consumer实例消费这个Topic对应的所有的队列，如果是集群消费，则多个Consumer实例平均消费这个topic队列集合；</p></li><li><p>保证严格的消息顺序；</p></li><li><p>提供丰富的消息拉去模式；</p></li><li><p>高效的订阅者水平扩展能力；</p></li><li><p>实时的消息订阅机制；</p></li><li><p>亿级消息堆积能力。</p><p>RocketMQ是Java语言编写，基于通信框架Netty。</p></li></ul><h1 id="2-RocketMQ物理部署结构"><a href="#2-RocketMQ物理部署结构" class="headerlink" title="2.RocketMQ物理部署结构"></a>2.RocketMQ物理部署结构</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB18GKUPXXXXXXRXFXXXXXXXXXX" alt=""></p><p>从上图中，我们可以看到消息队列的主要角色有：</p><ul><li>NameServer:无状态节点，供 Producer 和 Consumer 获取Broker地址。</li><li>Broker:MQ的服务器，消息的中转角色，负责存储和转发消息。</li><li>Producer:发送消息到消息队列(消息生产者)。</li><li>Consumer:从消息队列接收消息（消息消费者）。</li></ul><p>RocketMQ网络部署特点：</p><ul><li><p>　　NameServer是一个无状态的节点，可集群部署，节点之间无任何信息同步。</p></li><li><p>　　Broker:分为Master和Slave.一个Master可以有多个Slave,但是一个Slave只能对应一个Master.Master和Slave的对应关系是通过指定 “相同的BrokerName,不同的BrokerId”来定义。BrokerId=0表示Master,非0表示Slave。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有的NameServer。</p></li><li><p>　　Producer与NamerServer中的任意一个节点建立长连接，定期从NameServer中取Topic的路由信息，并与提供Topic服务的Master建立长连接，定时向Master发送心跳。可集群部署。</p></li><li><p>　　Consumer与NamerServer中的任意一个节点建立长连接，定期从NameServer中取Topic的路由信息，并与提供Topic服务的Master和Slave建立长连接，且定时向Master和Slave发送心跳。Consumer既可以从 Master 订阅消息，也可以从 Slave 订阅消息，订阅规则由 Broker 配置决定。</p></li></ul><h1 id="3-RocketMQ逻辑部署结构"><a href="#3-RocketMQ逻辑部署结构" class="headerlink" title="3.RocketMQ逻辑部署结构"></a>3.RocketMQ逻辑部署结构</h1><p><img src="http://img3.tbcdn.cn/5476e8b07b923/TB1lEPePXXXXXX8XXXXXXXXXXXX" alt=""></p><p><strong>Producer Group</strong></p><blockquote><p>​　　用来表示一个収送消息应用，一个 Producer Group 下包含多个 Producer 实例，可以是多台机器，也可以是一台机器的多个迕程，戒者一个迕程的多个 Producer 对象。一个 Producer Group 可以収送多个 Topic消息。作用有：</p><p>​    1.标识一类producer;</p><p>​    2.查询返个収送消息应用下有多个 Producer 实例;</p><p>​    3.収送分布式事务消息时，如果 Producer 中途意外宕机，Broker 会主劢回调 Producer Group 内的任意一台机器来确讣事务状态。</p></blockquote><p><strong>Consumer Group</strong></p><blockquote><p>​　　用来表示一个消费消息应用，一个 Consumer Group 下包含多个 Consumer 实例，可以是多台机器，也可以是多个迕程，戒者是一个迕程的多个 Consumer 对象。一个 Consumer Group 下的多个 Consumer 以均摊方式消费消息，如果设置为广播方式，那举返个 Consumer Group 下的每个实例都消费全量数据。</p></blockquote><ul><li><p>Topic：消息的逻辑管理单位；</p></li><li><p>Message Queue:消息物理管理单位，一个Topic可以有若干个Queue;</p></li><li><p>Message:消息</p><ul><li>body：消息体，用于携带消息的内容。</li><li>key:消息key,用于区分不同的消息，一般是业务id信息，根据key可查询到消息；</li><li>tag:消息tag,用于不同的订阅者来过滤消息。</li></ul><p>​</p></li></ul><h1 id="4-概念术语"><a href="#4-概念术语" class="headerlink" title="4.概念术语"></a><strong>4</strong>.概念术语</h1><ul><li>广播消费</li></ul><blockquote><p>　　 一条消息被多个 Consumer 消费，即使返些 Consumer 属亍同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次，广播消费中的 Consumer Group 概念可以讣为在消息划分方面无意义。</p></blockquote><ul><li>集群消费</li></ul><blockquote><p>​　　一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个Consumer Group 有 3 个实例（可能是 3 个迕程，戒者 3 台机器），那举每个实例只消费其中的 3 条消息。在 CORBA Notification 规范中，无此消费方式。<br>​    在 JMS 规范中，JMS point-to-point model 类似，但是 RocketMQ 的集群消费功能大等于 PTP 模型。<br>​    因为 RocketMQ 单个 Consumer Group 内的消费者类似于 PTP，但是一个 Topic/Queue 可以被多个 Consumer Group 消费。</p></blockquote><ul><li>顺序消息</li></ul><blockquote><p>　　消费消息的顺序要同发送消息的顺序一致，在 RocketMQ 中，主要指的是局部顺序，即一类消息为满足顺序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 发送的顺序去消费消息。</p></blockquote><ul><li>普通顺序消息</li></ul><blockquote><p>​    顺序消息的一种，正常情况下可以保证完全的顺序消息，但是一旦发生通信异常，Broker 重启，由于队列总数发生发化，哈希取模后定位的队列会发化，产生短暂的消息顺序不一致。<br>如果业务能容忍在集群异常情况（如某个 Broker 宕机或者重启）下，消息短暂的乱序，使用普通顺序方式比较合适。</p></blockquote><ul><li>严格的顺序消息</li></ul><blockquote><p>​　　顺序消息的一种，无论正常异常情况都能保证顺序，但是牺牲了分布式 Failover 特性，即 Broker 集群中只要有一台机器不可用，则整个集群都不可用，服务可用性大大降低。</p></blockquote><blockquote><p>　　如果服务器部署为同步双写模式，此缺陷可通过备机自动切换为主避免，不过仍然会存在几分钟的服务不可用。（依赖同步双写，主备自动切换，自动切换功能目前还未实现）<br>目前已知的应用只有数据库 binlog 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息。</p></blockquote><h1 id="5-参考"><a href="#5-参考" class="headerlink" title="5.参考"></a>5.参考</h1><p>1.RocketMQ 开发指南（V3.2.4）</p><p>2.<a href="https://blog.csdn.net/gwd1154978352/article/details/80654314" target="_blank" rel="noopener">RocketMQ——初识RocketMQ</a></p>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq ; 概念 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RocketMQ系列03--双主模式集群搭建(2m-noslave)</title>
      <link href="/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9703--%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/08/27/RocketMQ%E7%B3%BB%E5%88%9703--%E5%8F%8C%E4%B8%BB%E6%A8%A1%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>　　在上一篇中,我们介绍了 rocketmq 的支持的集群方式,并且介绍了各自的优缺点。本次以多Master集群模式为例搭建一个双机Master的RocketMQ集群环境（<strong>2m-noslave</strong>集群模式）。</p><h1 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1.环境准备"></a>1.环境准备</h1><p>　　因为rocketmq底层是 Java 语言编写，所以搭建此环境的服务器，必须已经安装和配置了 JDK。</p><h2 id="1-1-工具下载"><a href="#1-1-工具下载" class="headerlink" title="　  1.1 工具下载"></a>　  1.1 工具下载</h2><p>　　这里，我提供了本次安装rocketmq所用到的工具包。分别是：<br><img src="https://note.youdao.com/yws/public/resource/bb13fe8da08ed6f3d4eac0318734b976/xmlnote/E929F5CED76743B3BB6D93B211DD28C9/3039" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/11560519-c57a649016bc35a0.png" alt=""></p><p>提供了<a href="https://pan.baidu.com/s/1N4QrAgNrdwi3PacqqwxYUg#list/path=%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8C%85%2Frocketmq-software&amp;parentPath=%2F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7%E5%8C%85" title="rocketmq安装包" target="_blank" rel="noopener">百度云盘</a>（密码：wdvm）。大家可自行下载。</p><h2 id="1-2-服务器规划"><a href="#1-2-服务器规划" class="headerlink" title="　  1.2 服务器规划"></a>　  1.2 服务器规划</h2><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">IP</th><th style="text-align:center">角色</th><th style="text-align:center">模式</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">192.168.81.132</td><td style="text-align:center">nameServer1,brokerServer1</td><td style="text-align:center">Master1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">192.168.81.132</td><td style="text-align:center">nameServer2,brokerServer2</td><td style="text-align:center">Master2</td></tr></tbody></table><h2 id="1-3-基础环境搭建"><a href="#1-3-基础环境搭建" class="headerlink" title="　  1.3 基础环境搭建"></a>　  1.3 基础环境搭建</h2><ol><li>将压缩包上传到2台机器;</li><li>安装和配置JDK;(参考 <a href="https://blog.csdn.net/o135248/article/details/79931693" target="_blank" rel="noopener">linux下JDK的安装</a>)</li></ol><h1 id="2-集群搭建"><a href="#2-集群搭建" class="headerlink" title="2.集群搭建　"></a>2.集群搭建　</h1><h2 id="2-1-Hosts-添加信息"><a href="#2-1-Hosts-添加信息" class="headerlink" title="　  2.1 Hosts 添加信息"></a>　  2.1 Hosts 添加信息</h2><p>这里为了方便我们将 nameserver 和 broker 配置到了一台机器上,可以分开进行配置.</p><h2 id="2-2-解压压缩包-2台机器"><a href="#2-2-解压压缩包-2台机器" class="headerlink" title="　  2.2 解压压缩包(2台机器)"></a>　  2.2 解压压缩包(2台机器)</h2><h2 id="2-3-创建存储路径-2台机器"><a href="#2-3-创建存储路径-2台机器" class="headerlink" title="　  2.3 创建存储路径(2台机器)"></a>　  2.3 创建存储路径(2台机器)</h2><h2 id="2-4-RocketMQ配置文件-2台机器"><a href="#2-4-RocketMQ配置文件-2台机器" class="headerlink" title="　  2.4 RocketMQ配置文件(2台机器)"></a>　  2.4 RocketMQ配置文件(2台机器)</h2><h2 id="2-5-修改日志配置文件-2台机器"><a href="#2-5-修改日志配置文件-2台机器" class="headerlink" title="　  2.5 修改日志配置文件(2台机器)"></a>　  2.5 修改日志配置文件(2台机器)</h2><h2 id="2-6-修改启动脚本参数-2台机器"><a href="#2-6-修改启动脚本参数-2台机器" class="headerlink" title="　  2.6 修改启动脚本参数(2台机器)"></a>　  2.6 修改启动脚本参数(2台机器)</h2><h2 id="2-7-启动NameServer-2台机器"><a href="#2-7-启动NameServer-2台机器" class="headerlink" title="　  2.7 启动NameServer(2台机器)"></a>　  2.7 启动NameServer(2台机器)</h2><h2 id="2-8-启动BrokerServer-A"><a href="#2-8-启动BrokerServer-A" class="headerlink" title="　  2.8 启动BrokerServer A"></a>　  2.8 启动BrokerServer A</h2><h2 id="2-9-启动BrokerServer-B"><a href="#2-9-启动BrokerServer-B" class="headerlink" title="　  2.9 启动BrokerServer B"></a>　  2.9 启动BrokerServer B</h2><h2 id="2-10-安装-RocketMq-Console"><a href="#2-10-安装-RocketMq-Console" class="headerlink" title="　  2.10 安装 RocketMq Console"></a>　  2.10 安装 RocketMq Console</h2><h2 id="2-11-数据清理"><a href="#2-11-数据清理" class="headerlink" title="　  2.11 数据清理"></a>　  2.11 数据清理</h2>]]></content>
      
      <categories>
          
          <category> RocketMQ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rocketmq   集群  2m-noslave </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<p>大家好，我是”李乔子的酒”。欢迎来到我的个人技术博客。</p><p>我是一个Java入门2年的”小猿”,今后会在本博客写下自己的工作和生活日常.</p><p>让我们一起,变得更加优秀!</p><h4 id="历史纪录"><a href="#历史纪录" class="headerlink" title="历史纪录"></a>历史纪录</h4><table><thead><tr><th>日期</th><th>优化记录</th><th>完成日期</th><th>责任人</th></tr></thead><tbody><tr><td>2018-08-19</td><td>整理读书资源,对读书页面中的书籍增加 “百度云盘”下载</td><td></td><td>lemon</td></tr><tr><td>2018-08-19</td><td>新增 “Tools”工具页面,提供日常及开发常用工具一站式下载</td><td></td><td>lemon</td></tr><tr><td>2018-08-19</td><td>申请 “七牛云”存储,提供文件存储功能</td><td></td><td>lemon</td></tr></tbody></table>]]></content>
    </entry>
    
    <entry>
      <title>resources</title>
      <link href="/resources/index.html"/>
      <url>/resources/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>读书</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
